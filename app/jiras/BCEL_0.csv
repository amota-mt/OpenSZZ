issueKey;title;resolution;status;assignee;createdDateEpoch;resolvedDateEpoch;type;attachments;brokenBy;description;comments;
BCEL-2;[BCEL-2] constant pool does not have unused entries removed after calling getFinalConstantPool;Won't Fix;Resolved;Apache Commons Developers;1021893930000;1100631939000;Bug;[];[];[I have been trying to use the BCEL api to work out which methods and fields in a collection of java class files are unused and can be removed. This was relatively easy. Unfortunately when using the BCEL api to actually remove methods and fields it would appear that the constant pool is left unaltered by this removal procedure. I.e. the names of fields and methods which now no longer exist are still apparent in the constant pool. I had assumed that assigning the result of calling getFinalConstantPool to be the java classes new constant pool would do this. It does not];[This is due to the fact that it would impose reordering the whole constant pool which is out of the scope of the API. To many places may reference CP entries which are sometimes hard to find. There are however tools based on BCEL that will do this for you, in particular JOpt, the URL is on the project page.];
BCEL-3;[BCEL-3] ClassLoader missing in distributed jar;Fixed;Resolved;Apache Commons Developers;1022071543000;1100631939000;Bug;[];[];[The classfile for the class org.apache.bcel.util.ClassLoader is missing from the distributed bcel.jar file in http://jakarta.apache.org/builds/jakarta-bcel/release/v5.0rc1/bcel-5.0rc1.tar.gz Output of jar -tf bcel.jar | grep util : org/apache/bcel/util/org/apache/bcel/util/ClassPath.classorg/apache/bcel/util/ClassPath$1.classorg/apache/bcel/util/ClassPath$2.classorg/apache/bcel/util/ClassPath$3.classorg/apache/bcel/util/ClassPath$PathEntry.classorg/apache/bcel/util/ClassPath$ClassFile.classorg/apache/bcel/util/ClassPath$Dir.classorg/apache/bcel/util/ClassPath$Zip.classorg/apache/bcel/util/ByteSequence.classorg/apache/bcel/util/ByteSequence$ByteArrayStream.classorg/apache/bcel/util/ClassVector.classorg/apache/bcel/util/ClassQueue.classorg/apache/bcel/util/AttributeHTML.classorg/apache/bcel/util/ConstantHTML.class];[];
BCEL-4;[BCEL-4] Pass3b Verifier is corrupted;Fixed;Resolved;Apache Commons Developers;1025145450000;1111338372000;Bug;[];[];[The Repostiroty method public static boolean implementationOf(JavaClass clazz, JavaClass inter). Isn't working correctly. Therefore the Cast checks performed in the Pass3b verifier are wrong. With this simple program the verifcation fails. (tested with jdk1.4.0 W32) <code> class A implements B{ static C temp. public static void main(String[] args) { temp = new A(). } } interface B extends C{ } interface C{ } </code> The reason is simple. Interfaces are checked only directly. Interfaces inherited indirectly are forgotten. There is another version of this bug, where even direct implemented interfaces are not recognized, but i wasn't able to reduce it to a simple example.];[This is not a "simple" bug. Interfaces implemented directly are NOT forgotten. import org.apache.bcel.*.import org.apache.bcel.classfile.*.public class Test {    public static void main(String[] args) {        JavaClass a = Repository.lookupClass("A").        JavaClass c = Repository.lookupClass("B").        System.out.println(a.implementationOf(c)).    }} This program prints "true". and JavaClass.implementationOf() is what the static Repository methods are mapped to. The original test program lets the VERIFIER fail, it has a bug in its pass 3b implementation: Pass 3b, method number 0 ['void <init>()']:VERIFIED_REJECTEDConstraint violated in method 'void <init>()':Instruction INVOKESPECIAL constraint violated: The 'objref' item '<UNINITIALIZED OBJECT OF TYPE 'A'>' does not implement 'java.lang.Object' as expected.InstructionHandle:    1: invokespecial[183](3) 1Execution Frame:Local Variables:0: <UNINITIALIZED OBJECT OF TYPE 'A'>OperandStack:Slots used: 1MaxStack: 1.<UNINITIALIZED OBJECT OF TYPE 'A'> (Size: 1)Execution flow:   0: aload_0   [InstructionContext]   1: invokespecial 1   [InstructionContext] Problem is that the JVM spec 4.9.4 mentions UNINITIALIZED objects as a special type, and this type indeed does not implement any interfaces. JavaClass.instanceOf(JavaClass) is broken. This bug has been marked as a duplicate of 10490 *** That's not the complete truth. The reason for this bug can be easily located. Repository#getInterfaces replace: if(clazz.isInterface()) vec.addElement(clazz). else if(!s.equals("java.lang.Object")) queue.enqueue(lookupClass(s)). with: if(clazz.isInterface()) vec.addElement(clazz). if(!s.equals("java.lang.Object")) queue.enqueue(lookupClass(s)). and everything will work fine. The reason is simple if an interface extends another interface this interface is forgotten. As in the given example B extends C so C will not occure in the interface[] simply because B.superClass will not be added. I believe the problem is fixed in the current CVS version (05-Jul-2002) but it has another problem. see bug 10240. Argh, I meant BCEL-5 - NOT 10240. The actual CVS doesn't contain that bug anymore. so it will be fixed after 5.0];
BCEL-5;[BCEL-5] JavaClass.instanceOf(JavaClass) broken;Fixed;Resolved;Apache Commons Developers;1025824192000;1100631939000;Bug;[];[];[Consider: ------- import org.apache.bcel.*. import org.apache.bcel.classfile.*. public class Test{ public static void main(String[] args){ JavaClass a = Repository.lookupClass("Test"). System.out.println(a.instanceOf(Repository.lookupClass("java.lang.Object"))). } } ------- This fine program tells us "false", i.e. "Test" is not derived from "java.lang.Object". sigh];[BCEL-4 has been marked as a duplicate of this bug. *** The bug is in the CVS version of 05-Jul-2002, 13:00 CET. Peter Schneider <schneidp@lathanda.de> reports the Test.java program prints the correct "true" value on BCEL 5.0. Confirm: 5.0 did not have this bug. I located that bug. JavaClass#getSuperClass will never return java.lang.Object therefore getSuperClasses() doesn't contain java.lang.Object To fix it change getSuperclassName to getClassName public JavaClass getSuperClass() { if("java.lang.Object".equals(getSuperclassName())) {//<-------- return null. } This was fixed in r152813 on 2002-07-06 by mdahm];
BCEL-6;[BCEL-6] Repository#lookupClass no longer returns JavaClasses added with Repository#add;Fixed;Resolved;Apache Commons Developers;1025890668000;1100631939000;Bug;[];[];[This call is delegated to SyntheticRepostitory loadClass. This method doesn't check for loaded classes. This prevents memory only JavaClass's to be verified. Repository#add adds such JavaClass's to the loaded classes hash, but the validator only calls lookupClass. one of the two has to check for loaded classes, for two reasons. a) performance b) verifying classes hold in memory];[];
BCEL-7;[BCEL-7] NullPointerException in ClassLoader;Fixed;Resolved;Apache Commons Developers;1028104238000;1100631939000;Bug;[];[];[When trying to load an unknown class, a NullPointerException is thrown, but a ClassNotFoundException should be thrown. A patch for this is: Index: src/java/org/apache/bcel/util/ClassLoaderRepository.java===================================================================RCS file:/home/cvspublic/jakarta-bcel/src/java/org/apache/bcel/util/ClassLoaderRepository.java,vretrieving revision 1.2diff -r1.2 ClassLoaderRepository.java124a125,128>             if (is == null) {>                 throw new ClassNotFoundException( "Class not found." ).>             }>];[This was fixed in r152817 on 2002-07-31 by mdahm];
BCEL-8;[BCEL-8] Web-page link broken;Cannot Reproduce;Resolved;Apache Commons Developers;1028869687000;1100631939000;Bug;[];[];[The link to the API docs is broken. http://jakarta.apache.org/bcel/ contains a link Documentation=> API, which points to http://jakarta.apache.org/bcel/api/index.html but that doesn't exist.];[I cannot see that API link anywhere, and the "javadoc" link works. Maybe someone repaired this.];
BCEL-9;[BCEL-9] Broken link in Javadocs on site;Invalid;Resolved;Apache Commons Developers;1028870106000;1100631939000;Bug;[];[];[http://jakarta.apache.org/bcel/apidocs/org/apache/bcel/classfile/ClassParser.htm l contains a link "JavaClass" to http://jakarta.apache.org/bcel/apidocs/org/apache/bcel/classfile/org.apache.bcel .classfile.JavaClass.html But that file doesn't exist (the package name shouldn't be part of the filename)];[Not even the first link exists (any more?)];
BCEL-10;[BCEL-10] Typo in javadocs;Fixed;Resolved;Apache Commons Developers;1031824814000;1100631939000;Bug;[];[];[The PUTSTATIC instruction does not take an objref as parameter: Index: PUTSTATIC.java===================================================================RCS file:/home/cvspublic/jakarta-bcel/src/java/org/apache/bcel/generic/PUTSTATIC.java,vretrieving revision 1.1.1.1diff -u -r1.1.1.1 PUTSTATIC.java--- PUTSTATIC.java      29 Oct 2001 20:00:25 -0000      1.1.1.1+++ PUTSTATIC.java      12 Sep 2002 09:55:51 -0000@@ -59,9 +59,9 @@ /**  * PUTSTATIC - Put static field in class- * <PRE>Stack: ..., objectref, value -&gt. ...</PRE>+ * <PRE>Stack: ..., value -&gt. ...</PRE>  * OR- * <PRE>Stack: ..., objectref, value.word1, value.word2 -&gt. ...</PRE>+ * <PRE>Stack: ..., value.word1, value.word2 -&gt. ...</PRE>  *  * @version $Id: PUTSTATIC.java,v 1.1.1.1 2001/10/29 20:00:25 jvanzyl Exp $  * @author  <A HREF="mailto:markus.dahm@berlin.de">M. Dahm</A>];[This was fixed some time ago.];
BCEL-11;[BCEL-11] generic.LCMP lacks some interfaces;Fixed;Resolved;Apache Commons Developers;1039035011000;1100631939000;Bug;[lcmp-add-interface.txt];[];[see the attached file];[Attachment lcmp-add-interface.txt has been added with description: a patch which adds some interfaces to LCMP, like in {F,D} CMP {G,L} .java Fixed in r152843 (2002-12-08)];
BCEL-13;[BCEL-13] ConstantPoolGen.lookupClass(String) finds LAST entry rather than first;Fixed;Resolved;Apache Commons Developers;1047778976000;1141967011000;Bug;[];[];[I have discovered a class file that has multiple CONSTANT_Class entries in the ConstantPool that point to the same CONSTANT_Utf8 class name string. The ConstantPoolGen.lookupClass(String) method seems to return the index for the LAST of the two CONSTANT_Class entries instead of the first. Details are available from: http://www.markcrocker.com/~mcrocker/Computer/Purifier/wrongClassrefIssue.shtml This is a problem because I am attempting to create pure Java J2ME preverifier (The Purifier: http://www.markcrocker.com/~mcrocker/Computer/Purifier/). Ideally, it should produce the same StackMaps as SUN's preverifier. However, in the case of this unusual class, it cannot because it uses BCEL and BCEL's lookupClass produces a different index than SUN's preverifier for the particular class that happens to have two possible indecies.];[The fix is quite simple. Basically, the class_table is stored in a HashMap. HashMaps assume that there is only one entry per key, which is not the case in these bizarre obfuscated classes. The solution is to check to see if the key exists already before put'ing another one. This explains why BCEL's ConstantPoolGen.lookupClass(String) was always finding the LAST case, rather than the first. The fix is: original line 118: class_table.put(u8Bytes, new Index). suggested replacement: String u8Bytes = u8.getBytes(). if (!class_table.containsKey(u8Bytes)) { class_table.put(u8Bytes, new Index(i)). } Note that this problem occurs with ALL of the HashMaps that are used to store non-trivial types in the ConstantPoolGen class. This fix should be applied to all of those cases as well. Oops, sorry. Previous comment had a typo. Should have been: original line 118: class_table.put(u8.getBytes(), new Index). Of course, the same could be said for addClass_, but then that would go against the seemingly explicit wishes of the client code. I think I would vote for requiring the client code to filter the passed in array of Constants. public ConstantPoolGen(Constant[] cs) { } So what do we do about this? Mark as WONTFIX? i could go either way. the suggested fix probably won't hurt anything. I've applied that pattern to all maps in that class (or should be do that in other classes as well?). Please cross-check.];
BCEL-14;[BCEL-14] Size of LDC_W's operand can be incorrect;Fixed;Resolved;Apache Commons Developers;1048607004000;1108498240000;Bug;[patch];[];[When MethodGen read LDC_W whose index is less than 256 and dumps it, the size of its operand becomes incorrect. LDC_W's setIndex method can change both the opcode and the length. But after the invocation initFromFile method change the opcode OR the length. And its dump method determines the operand's size by the length. As a result that can make a mismatch b/w an opcode and an operand. LDC_W.java 1.1.1.1 and 1.3 has this problem. A scenario(in case of LDC_W.java 1.3): 1. Suppose a LDC_W whose index is less than 256 2. initFromFile method sets the opcode to LDC_W and the length to 2. 3. dump method writes a LDC_W but it writes a byte as the operand. I think that 1.2 has no problem. Another solution is as follows. — LDC_W.java.1.1.1.1 Sat Dec 15 21:40:41 2001 +++ LDC_W.java Wed Mar 26 00:36:01 2003 @@ -82,6 +82,6 @@ throws IOException { setIndex(bytes.readUnsignedShort()). - length = 3. + //length = 3. } }];[Attachment patch has been added with description: patch against 1.4 to fix the length issue One example is the JDK 1.4 compiled java.math.BigInteger. If you run: `javap -c java.math.BigInteger | grep ldc_w` you will find several examples of LDC_W operands with sub-256 indices: 401: ldc_w #268. //int 2147483647 1835: ldc_w #435. //String 0000000[..] 2691: ldc_w #259. //int 1162261467 2702: ldc_w #260. //int 1220703125 2709: ldc_w #247. //int 362797056 2716: ldc_w #267. //int 1977326743 2729: ldc_w #248. //int 387420489 2736: ldc_w #258. //int 1000000000 ... Without the above patch, a BCEL lifted and regenerated BigInteger will generate the following broken classfile: 434: ldc_w #268. //int 2147483647 1868: ldc_w #435. //String 0000000[..] 2724: ldc_w #259. //int 1162261467 2735: ldc_w #260. //int 1220703125 2742: ldc_w #63311. //BOGUS_TAG:100 <Incorrect CP index:63311> 2748: ldc_w #267. //int 1977326743 2761: ldc_w #63567. //BOGUS_TAG:100 <Incorrect CP index:63567> 2767: ldc_w #258. //int 1000000000 ... Note that 63311 = 247*256 + 79, and the instruction following the ldc_w is an iastore (opcode 79). Related to 29903 and 29275 The patch to BCEL-47 seems to have addressed this issue, in at least one example. Please repost if the problem still exists.];
BCEL-16;[BCEL-16] Justice claims an error when a class is modified by bcel in specific circumstances;Duplicate;Resolved;Apache Commons Developers;1049442442000;1100631940000;Bug;[];[];[With the folowwing class method : public void test (int i) { try { }catch (Exception ex) { } }];[BCEL-17 has been marked as a duplicate of this bug. *** This bug has been marked as a duplicate of 18696 ***];
BCEL-17;[BCEL-17] Justice claims an error when a class is modified by bcel in specific circumstances;Duplicate;Resolved;Apache Commons Developers;1049442442000;1100631940000;Bug;[];[];[With the folowwing class method : public void test (int i) { try { }catch (Exception ex) { } }];[This bug has been marked as a duplicate of 18691 ***];
BCEL-18;[BCEL-18] Justice claims an error when a class is modified by bcel in specific circumstances;Invalid;Resolved;Apache Commons Developers;1049442442000;1100631940000;Bug;[];[];[With the folowwing class method : public void test (int i) { try { }catch (Exception ex) { } }];[];
BCEL-19;[BCEL-19] Justice claims an error when a class is modified by bcel in specific circumstances;Invalid;Resolved;Apache Commons Developers;1049443677000;1331480018000;Bug;[];[];[When modifying a class having the following kind of method : public int test(int i) { try { int z = i + 1. return z. } catch (Exception ex) { System.out.println(ex). } return 0. } Justice fires an error because the end scope of the variable z and the start scope of ex is the same. As they are generated with the same slot , we fall in verification error. The end scope of the z method is wrong. It seems that this is due to the method public LocalVariable getLocalVariable(ConstantPoolGen cp) { ... } in org/apache/bcel/generic/LocalVariableGen.java , look at : if(length > 0) length += end.getInstruction().getLength(). just before executing this, the length is correct. but as we executed it the variable scope became wrong Is it a too much restrictive control from JustIce ot is this a real problem in bcel ?];[BCEL-16 has been marked as a duplicate of this bug. *** Sounds like a justice problem to me No feedback in many years. Re-open with further details if still a problem with current version of Bcel];
BCEL-20;[BCEL-20] InstructionList.copy() fails with Select instruction.;Fixed;Resolved;Apache Commons Developers;1049550486000;1109024498000;Bug;[];[];[The implementation of InstructionList.copy() works on the internal targets fields of the select instructions: (InstructionList.java line 1110) InstructionHandle[] itargets = ((Select)bi).getTargets(). InstructionHandle[] ctargets = ((Select)bc).getTargets(). But because bc is created from bi by cloning bi, both refer to the same target array. Changing ctargets also changes itargets. The reason for this is, that Select does not override clone. The following patch fixes this problem: Index: Select.java =================================================================== RCS file: /home/cvspublic/jakarta-bcel/src/java/org/apache/bcel/generic/Select.java,v retrieving revision 1.2 diff -u -r1.2 Select.java — Select.java 26 Apr 2002 09:30:11 -0000 1.2 +++ Select.java 5 Apr 2003 13:37:54 -0000 @@ -227,6 +227,16 @@ return false. } + protected Object clone() throws CloneNotSupportedException { + Select result = (Select) super.clone(). + + result.match = (int[]) result.match.clone(). + result.indices = (int[]) result.indices.clone(). + result.targets = (InstructionHandle[]) result.targets.clone(). + + return result. + } + /** Inform targets that they're not targeted anymore. */];[Applied to SVN, thanks.];
BCEL-21;[BCEL-21] Annoying print statement in org.apache.bcel.classfile.Signature;Fixed;Resolved;Apache Commons Developers;1050355499000;1106775665000;Bug;[];[];[The implementation of the accept(Visitor) method of org.apache.bcel.classfile.Signature contains an unconditional print statement to System.err saying "Visiting non-standard Signature object". Since a lot of people are using GJ, and it will soon become a standard part of the Java language, this print statement should be removed.];[Fixed in Rev 1.4 of org.apache.bcel.classfile.Signature.java by mdahm.];
BCEL-22;[BCEL-22] JavaClass.getAllInterfaces() can throw NullPointerException when classpath is incomplete;Fixed;Resolved;Apache Commons Developers;1050502321000;1109618467000;Bug;[];[];[This bug affects revision 1.13 of JavaClass.java. The org.apache.bcel.classfile.JavaClass.getAllInterfaces() method calls JavaClass.getInterfaces(), which uses a Repository to look up the class's interfaces. If any of the interfaces are not found, then getInterfaces() returns null. However, getAllInterfaces() tries to dereference this null reference, leading to the exception. A simple fix would be to return a zero-length array from getInterfaces() in the case where a repository lookup fails. A better fix would be to have getInterfaces() throw the ClassNotFoundException out of the method. In general, I think repository lookup failures should be propagated as much as possible, so the program using BCEL can detect them. Right now there is a println() to System.err in getInterfaces(), which is not a very useful way to report the failure.];[This analysis, imo, is completely accurate. getInterfaces() should throw an exception if the repository fails, and by association, getAllInterfaces(), as well. Of course this means changing the public signature and potentially causing incompatibilities with current clients. My vote would be to make that change now anyway, as it is a bad problem, but wonder what others think? This appears to have already been committed.];
BCEL-23;[BCEL-23] Repository ignores classes that have been added to it;Fixed;Resolved;Apache Commons Developers;1050601521000;1121538993000;Bug;[SyntheticRepository.patch, correct-trace.txt, repos-bug.txt];[];[I'm using the org.apache.bcel.Repository class to do class hierarchy tests (finding out if one class is an instance of another, etc.) My program uses Repository.addClass() to add all of the classes in an analyzed application to the repository. Some of the classes in the analyzed application extend or implement types in external jar files: for example, java.io.Serializable in the rt.jar from the JDK. The problem, as far as I can tell, is that org.apache.bcel.classfile.JavaClass.getInterfaces() calls loadClass() on its internal org.apache.bcel.util.Repository object to convert interface references to the JavaClass objects for those interfaces. As implemented in SyntheticRepository, the loadClass() method ignores all currently loaded classes. Because the application classes are not part of the runtime CLASSPATH, they are reported as missing. I will attach a stack trace showing the problem to this bug report. Note that the class reported as missing (edu.umd.cs.pugh.visitclass.Constants2) is in the repository. One thing that seems confusing to me is that the org.apache.bcel.util.Repository class does not have a method which looks in both the internal cache to find a class, and if that fails tries to load the class from an external source.];[Attachment repos-bug.txt has been added with description: stack trace showing a bug in resolution of a class in the Repository Oops, please ignore the first attached file. That shows failure to resolve a class that is neither in the Repository nor the classpath. The second attached file is the correct one. it shows a class that is definitely in the Repository. If you examine that stack trace, you will see that at no point does BCEL try to look for the class in the Repository. Attachment correct-trace.txt has been added with description: this is the CORRECT stack trace showing the problem Attachment SyntheticRepository.patch has been added with description: Here is a simple fix for the problem this patch appears to have been already applied.];
BCEL-24;[BCEL-24] ANEWARRAY does not implement StackConsumer;Fixed;Resolved;Apache Commons Developers;1051393384000;1113802818000;Bug;[];[];[The title says all. ANEWARRAY should implement StackConsumer];[This was reported, like, two years ago... Does anybody take care of this project at all? agreed, fixed. Thanks.];
BCEL-25;[BCEL-25] Repository.instanceOf() can throw NullPointerException;Fixed;Resolved;Apache Commons Developers;1051710451000;1109618288000;Bug;[];[];[org.apache.bcel.Repository.instanceOf(JavaClass clazz, JavaClass super_class) can throw NullPointerException. Here's how: 1. instanceOf(String, String) is called 2. it calls lookupClass(String) using "clazz" as a parameter 3. in lookupClass(String), the inner _repository object throws a ClassNotFoundException, so lookupClass() returns null 4. instanceOf(String, String) calls instanceOf(JavaClass, JavaClass) with the first parameter null 5. instanceOf(JavaClass, JavaClass) invokes instanceOf(JavaClass) on its first parameter, resulting in a NullPointerException];[This appears to have already been committed.];
BCEL-26;[BCEL-26] StackMapType.printIndex fails if index is -1;Fixed;Resolved;Apache Commons Developers;1052436705000;1108063863000;Bug;[];[];[There are circumstances where a StackMapType might have an index of -1. Unfortunately, the printIndex method in StackMapType has problems with this. The fix is simple: Original code: private String printIndex() { if(type == Constants.ITEM_Object) return ", class=" + constant_pool.constantToString(index, Constants.CONSTANT_Class). else if(type == Constants.ITEM_NewObject) return ", offset=" + index. else return "". } Proposed fix: private String printIndex() { if(type == Constants.ITEM_Object) { if(index == -1) { return ", class=<unknown>". } else { return ", class=" + constant_pool.constantToString(index, Constants.CONSTANT_Class) + "(" + index + ")". } } else if(type == Constants.ITEM_NewObject) { if(index == -1) { return ", offset=<unknown>". } else { return ", offset=" + index. } } else { return "". } } One could also argue that the ConstantPool.constantToString methods should be fixed as well, though it could also be argued that such cases should fail. In the case of StackMapType.printIndex, the case is much clearer. P.S. While I'm at this, Bugzilla for BCEL doesn't have an option to select version 5.1 of BCEL. This particular bug is in both 5.0 and 5.1.];[Applied to SVN, thanks! Applied to SVN, thanks!];
BCEL-28;[BCEL-28] Mistake in "Peephole optimizer" example at http://jakarta.apache.org/bcel/manual.html;Fixed;Closed;Apache Commons Developers;1067531307000;1173512488000;Bug;[];[];[The example "Peephole optimizer" (at http://jakarta.apache.org/bcel/manual.html) has the following code: InstructionHandle[] match = (InstructionHandle[])e.next(). This is wrong. The variable "e" should be written as "i". In other words, it should be changed to: InstructionHandle[] match = (InstructionHandle[])i.next().];[Please ignore my previous comment. This class have some other mistakes also. Please fix all the bugs and try to compile it. I know this was literally years ago ...but do you remember what you meant with "This class have some other mistakes also" I meant if we change InstructionHandle[] match = (InstructionHandle[])e.next(). to InstructionHandle[] match = (InstructionHandle[])i.next(). we still have another error "Duplicate Parameter e" at the line } catch(TargetLostException e) { So we should change that variable name to something else (e.g. "it") for (Iterator it = f.search(pat). it.hasNext() { InstructionHandle[] match = (InstructionHandle[]) it.next(). This should be fixed. http://svn.apache.org/viewvc/jakarta/bcel/trunk/src/site/xdoc/manual.xml?sortdir=down&view=log];
BCEL-29;[BCEL-29] ReferenceType.getFirstCommonSuperclass: Does not recognize UninitializedObjectType;Unresolved;Open;Apache Commons Developers;1067561368000;0;Bug;[];[];[Here's a little gem that causes BCEL's verifier to crash: (Compile the following with the bytecode assembler Jasmin) .class public Test47.super java/lang/Object.method public foo(B)V.limit stack 10.limit locals 10iload_1ifne ELSE_0new java/io/BufferedInputStreamgoto ENDIF_0ELSE_0:new java/io/FilterInputStreamENDIF_0:popreturn.end method The error generated is as follows: Exception in thread "main" org.apache.bcel.verifier.exc.AssertionViolatedException: INTERNAL ERROR: Some RuntimeException occured while verify()ing class 'Test47', method 'public void foo(byte arg1)'. Original RuntimeException's stack trace:---java.lang.ClassCastException        at org.apache.bcel.generic.ReferenceType.getFirstCommonSuperclass(ReferenceType.java:256)        at org.apache.bcel.verifier.structurals.OperandStack.merge(OperandStack.java:254)        at org.apache.bcel.verifier.structurals.ControlFlowGraph$InstructionContextImpl.mergeInFrames(ControlFlowGraph.java:246)        at org.apache.bcel.verifier.structurals.ControlFlowGraph$InstructionContextImpl.execute(ControlFlowGraph.java:189)        at org.apache.bcel.verifier.structurals.Pass3bVerifier.circulationPump(Pass3bVerifier.java:228)        at org.apache.bcel.verifier.structurals.Pass3bVerifier.do_verify(Pass3bVerifier.java:342)        at org.apache.bcel.verifier.PassVerifier.verify(PassVerifier.java:108)        at org.apache.bcel.verifier.Verifier.doPass3b(Verifier.java:133)        at ClassVerifier.verify(ClassVerifier.java:33)        at ClassInfo.verify(ClassInfo.java:51)        at Main.main(Main.java:7)---        at org.apache.bcel.verifier.structurals.Pass3bVerifier.do_verify(Pass3bVerifier.java:356)        at org.apache.bcel.verifier.PassVerifier.verify(PassVerifier.java:108)        at org.apache.bcel.verifier.Verifier.doPass3b(Verifier.java:133)        at ClassVerifier.verify(ClassVerifier.java:33)        at ClassInfo.verify(ClassInfo.java:51)        at Main.main(Main.java:7) It appears that ReferenceType.getFirstCommonSuperclass() is not designed to handle the org.apache.bcel.verifier.structurals.UninitializedObjectType ReferenceType that is used by BCEL's verifier.];[Right. The UninitializedObjectType was invented to be used internally in JustIce. The idea was not to go out with it and ask BCEL about its superclass. Oh lord. So why is it exposed is the question then?!];
BCEL-30;[BCEL-30] ReturnaddressType.equals() fails with NullPointerException;Fixed;Resolved;Apache Commons Developers;1067561649000;1108063425000;Bug;[];[];[When a ReturnaddressType is compared with another ReturnaddressType whose returnInstruction is null, a NullPointerException is encountered. Try the following: ReturnaddressType.NO_TARGET.equals(ReturnaddressType.NO_TARGET) Stack Trace: Exception in thread "main" java.lang.NullPointerException at org.apache.bcel.generic.ReturnaddressType.equals(ReturnaddressType.java:93) ...];[This was fixed in r152860 on 2003-07-28];
BCEL-31;[BCEL-31] Verification failure when nested finally blocks;Fixed;Resolved;Apache Commons Developers;1067653174000;1100631941000;Bug;[];[];[The following code will not pass that JustIce verifier. Code was compiled with Sun's standard compiler (v 1.4.1). SOURCE CODE: public class Test55 { public void foo(int arg0, int arg1) { try { try { arg0 /= arg1. } finally { arg0 = arg0. } } finally { arg1 = arg1. } } } OUTPUT: Verifying: Test55 Verification Errors: #0: Constraint violated in method 'public void foo(int arg1, int arg2)': Subroutine instruction ' 16: astore[58](2) 4' is protected by an exception handler, 'CodeExceptionGen( 0: iload_1[27](1), 22: jsr[168](3) -> astore 6, 28: astore[58](2) 5)'. This is forbidden by the JustIce verifier due to its clear definition of subroutines. Verification failed];[This is NOT a bug. It's an intended incompatibility with Sun's verifier that will be present as long as Sun does not correctly specify what exactly the verifier should do in this situation. Remember JustIce is a cleanroom implementation, so I will not look into Sun's code to find out what they do. They should update their "vmspec2" book. Please read my paper on JustIce for details - this incompatibility is sort of a "core" of the 'subroutine' definition I made up on my own since Sun did not. Enver];
BCEL-33;[BCEL-33] PUTFIELD error msg wrong;Duplicate;Resolved;Apache Commons Developers;1067856711000;1141968211000;Bug;[];[];[[reported by Luca Martini] <luca.martini@iet.unipi.it> It seems that I found a minor inaccuracy in an error message. in org.apache.bcel.verifier.structurals.InstConstraintVisitor.java you wrote: public void visitPUTFIELD(PUTFIELD o){ [snip] if (! ( objreftype.equals(curr) || objreftype.subclassOf(curr) ) ) { constraintViolated(o, "The referenced field has the ACC_PROTECTED modifier, and it's a member of the current class or a superclass of the current class. However, the referenced object type '"+stack().peek()+"' is not the current class or a subclass of the current class."). } } } but I think the referenced object type is not at the top of the stack but, next to it. However, even if this check is done only on protected field (as stated in vmspec) the Standard Verifier checks it even for public fields (and it seems reasonable). You can try the stupid enclosed example (in Jasmin syntax): in this case I substituted the putfield object reference of type with a reference of type B. JustIce signals no error while the native verifier reports: Exception in thread "main" java.lang.VerifyError: (class: A, method: m signature: (ILB.)V) Incompatible type for getting or setting field];[So you are saying the refrence is the second on the stack and we should only check on protected fields? This bug has been marked as a duplicate of 24351 ***];
BCEL-34;[BCEL-34] PUTFIELD check erroneous;Unresolved;In Progress;Apache Commons Developers;1067857004000;0;Bug;[LUCA.tar];[];[[reported by Luca Martini] luca.martini@iet.unipi.it However, even if this check is done only on protected field (as stated in vmspec) the Standard Verifier checks it even for public fields (and it seems reasonable). You can try the stupid enclosed example (in Jasmin syntax): in this case I substituted the putfield object reference of type with a reference of type B. JustIce signals no error while the native verifier reports: Exception in thread "main" java.lang.VerifyError: (class: A, method: m signature: (ILB.)V) Incompatible type for getting or setting field I think I was wrong saying: ~~> However, even if this check is done only on protected field (as stated in ~~> vmspec) the Standard Verifier checks it even for public fields (and it seems ~~> reasonable). The example I send to you gives an error while checking that the value stored by the putfield is compatible with the descriptor of the reference field. Is it this check in Justice? It seems not.];[Attachment LUCA.tar has been added with description: Test case by Luca Martini this sounds like a duplicate of http://issues.apache.org/bugzilla/show_bug.cgi?id=24350 BCEL-33 has been marked as a duplicate of this bug. *** Let's continue here];
BCEL-35;[BCEL-35] Suggestion to solve the Problem with generic.Instruction in Turkish locale;Fixed;Resolved;Apache Commons Developers;1069133704000;1147250145000;Bug;[LocaleTest.java, bcel-patch.txt];[];[The method generic.Instruction.readInstruction() calls generic.Instruction.className(short) which uses toUpperCase() in its implementation. This is brittle. in the Turkish locale, for example "I".toLowerCase() != "i" "i".toUpperCase() != "I" This was reported to me at the AspectJ project from an actual user who gets org.apache.bcel.generic.ClassGenException: Illegal opcode detected. at org.apache.bcel.generic.Instruction.readInstruction (Instruction.java:189) at org.apache.bcel.generic.InstructionList.<init> (InstructionList.java:193) when using AspectJ (which uses BCEL) under the Turkish locale. So this is a problem that's appearing in the wild smile. I may get around to patching it myself before our next release, in which case I'll probably just rip out the Class.forName stuff inside Instruction.readInstruction() which is the thing really causing the problem (is that there for expansion, in case users define their own bytecodes? I'm confused as to why there isn't just a 256-wide dispatch).];[Attachment LocaleTest.java has been added with description: A test file throwing an exception when the Locale is changed Attachment bcel-patch.txt has been added with description: replace calls to class.forName with a big switch I had encountered a similar problem with Hsqldb. We resolved the problem very easily: Just replace all occurences of toLowerCase() with toLowerCase(Locale.ENGLISH) and toUpperCase() with toUpperCase(Locale.ENGLISH). This forces the jre to use English character set. So the program works correctly even the client has Turkish character set as default regional settings. Mert Nuhoglu mert.nuhoglu ( @ ) isnet.net.tr Just applied the change Mert proposed. Please verify. Hi Torsten. Just a note that I don't use BCEL anymore in my normal life, so I won't be able to verify your bugfix (in AspectJ we used the "big switch" solution, since it was unclear that you were getting anything from the reflection apart from overhead). But verification should be pretty easy: just write a program that uses the IINC bytecode and compile with Locale.TURKISH.];
BCEL-36;[BCEL-36] Incorrect verification of class files;Fixed;Resolved;Apache Commons Developers;1073871545000;1141241054000;Bug;[InstConstraintVisitor.java.patch];[];[Hi, JustIce indicates that the storing of a newly created object in a local before calling it's constructor as an error. However, this is incorrect as the local is not accessed along any control flow path before the constructor is called. This is also safe in a multithreaded setting. Also, the same class file is well interpreted by java interpreters from SUN, Blackdown, and IBM. Moreover, there is no restriction on handling (not using) of uninitialized objects in the JVM spec. ASM output of the correponding class file and JustIce' output are inlined. public static main ([Ljava/lang/String.)V NEW excpsync ASTORE 1 ALOAD 1 INVOKESPECIAL excpsync <init> ()V ALOAD 1 ASTORE 1 NEW java/lang/Thread ASTORE 2 ALOAD 2 ALOAD 1 INVOKESPECIAL java/lang/Thread <init> (Ljava/lang/Runnable.)V ALOAD 2 INVOKEVIRTUAL java/lang/Thread start ()V NEW java/lang/Thread ASTORE 2 NEW f ASTORE 3 ALOAD 3 INVOKESPECIAL f <init> ()V ALOAD 2 ALOAD 3 INVOKESPECIAL java/lang/Thread <init> (Ljava/lang/Runnable.)V ALOAD 2 INVOKEVIRTUAL java/lang/Thread start ()V LDC "Hi" ASTORE 2 ALOAD 1 ALOAD 2 PUTFIELD excpsync o Ljava/lang/String. ALOAD 2 PUTSTATIC excpsync t Ljava/lang/String. RETURN MAXSTACK = 2 MAXLOCALS = 4 JustIce by Enver Haase, (C) 2001-2002. <http://bcel.sourceforge.net> <http://jakarta.apache.org/bcel> Now verifying: excpsync Pass 1: VERIFIED_OK Passed verification. Pass 2: VERIFIED_OK Passed verification. Pass 3a, method number 0 ['public void <init>()']: VERIFIED_OK Passed verification. Pass 3b, method number 0 ['public void <init>()']: VERIFIED_OK Passed verification. Pass 3a, method number 1 ['public static void main(String[] arg0)']: VERIFIED_OK Passed verification. Pass 3b, method number 1 ['public static void main(String[] arg0)']: VERIFIED_REJECTED Constraint violated in method 'public static void main(String[] arg0)': Instruction ASTORE constraint violated: Working on an uninitialized object '<UNINITIALIZED OBJECT OF TYPE 'excpsync'>'. InstructionHandle: 3: astore_1[76](1) Execution Frame: Local Variables: 0: java.lang.String[] 1: <unknown object> 2: <unknown object> 3: <unknown object> OperandStack: Slots used: 1 MaxStack: 2. <UNINITIALIZED OBJECT OF TYPE 'excpsync'> (Size: 1) Execution flow: 0: new 12 [InstructionContext] 3: astore_1 [InstructionContext] Pass 3a, method number 2 ['public void run()']: VERIFIED_OK Passed verification. Pass 3b, method number 2 ['public void run()']: VERIFIED_OK Passed verification.];[Attachment InstConstraintVisitor.java.patch has been added with description: Patch to InstConstraintVisitor.java to relax certain "assumed" constraint checks I looked at InstConstraintVisitor.java and would suggest that the verifier = not check if the reference is initialized when an object is loaded/stored, but rather check for intialized-ness before using = it in operations such as method invocation or field access expressions. Hence, the solution would be to allow uninitialized obj= ects to exists in the heap if they are only accessible from locals in the method and to check for initialized-ness befo= re exposing them to the rest of the system by assigning them to fields, returning them from the method, or passing them a= s arguments into a method. The following patch enables this form of constraint checking. Please do mail me any questions/comments/suggestions you may have about the= proposed approach. [Attachment 01/16/04 15:31 has the corresponding patch] applied please cross check];
BCEL-37;[BCEL-37] OutOfRange exception in Pass2Verifier.validJavaIdentifier;Fixed;Resolved;Apache Commons Developers;1073993141000;1100631941000;Bug;[];[];[Hi Pass2Verifier.validJavaIdentifier must check the length of the parameter "name" otherwise an OutOfRange exception occurs when name.length() == 0. Here is the patch. Index: Pass2Verifier.java===================================================================RCS file: /cvsroot/bcel/JustIce/de/fub/bytecode/verifier/statics/Pass2Verifier.java,vretrieving revision 1.69diff -u -r1.69 Pass2Verifier.java--- Pass2Verifier.java12 Sep 2001 12:56:15 -00001.69+++ Pass2Verifier.java13 Jan 2004 11:12:40 -0000@@ -1222,6 +1222,7 @@  * represents a valid Java identifier (so-called simple name).  */ private static boolean validJavaIdentifier(String name){+if  (name.length() == 0) return false. // vmspec2 2.7, vmspec2 2.2 if (!Character.isJavaIdentifierStart(name.charAt(0))) return false. Regards FA];[Correct. I just applied the patch. thanks for reporting!];
BCEL-38;[BCEL-38] Code attribute set for native (and abstract?) methods.;Fixed;Resolved;Apache Commons Developers;1074210335000;1100631941000;Bug;[];[];[Hi, I'm trying to generate a native class on the fly, but I just can't get my class generated with BCEL. When I try to run my code I get the following error: ClassFormatError: Code attribute in native or abstract methods. I used BCELifier to regenerate a working class, and I get the same problem (so it's clearly a bug in BCEL). For the ones unfamiliar with JNI, here is what I want to generate: public class Test { public native static void run(Object a, String b, String c, String d, int e). static { System.loadLibrary("Test"). } } Could you please keep me informed by email about the status of this bug. Thanks. Alok Menghrajani alok.menghrajani@epfl.ch];[];
BCEL-39;[BCEL-39] InstructionList.move is broken when target == il.getEnd();Fixed;Resolved;Apache Commons Developers;1075405845000;1121550378000;Bug;[InstructionList--bug26532.patch, Test26532.java];[];[because this.end is never updated. I believe the right fix is: line 684: else this.end = next.];[Could someone please take a look at this? It necessitates at least a couple hackish workarounds in SandMark, and a fix is included. Thanks. Attachment InstructionList--bug26532.patch has been added with description: correctly sets "this.end" Attachment Test26532.java has been added with description: test case demonstrating the bug agreed, applied.];
BCEL-40;[BCEL-40] bad iinc behavior with large local variable index;Fixed;Resolved;Apache Commons Developers;1075406160000;1108164841000;Bug;[diff];[];[IINC isn't wide unless the index is > MAX_SHORT or increment is > Byte.MAX_BYTE. but the jvm spec says that for non-wide iinc, index is an unsigned byte. the attached patch fixes my problem.];[Attachment diff has been added with description: make iinc's wide when index > MAX_BYTE could someone please take a look at this? A fix is included, and i have a SandMark bug that requires this fix. Thanks! Applied to SVN, thanks!];
BCEL-41;[BCEL-41] JustIce - array store type checks stricter than native verifier;Unresolved;In Progress;Apache Commons Developers;1076442974000;0;Bug;[];[];[Consider the class public class Demo{    public static void main(String[] args)    {        Object[] objs = new Integer[1].        objs[0] = o().    }    private static Object o()    {        return null.    }} It compiles fine, and java -verify Demo executes without errors. However, java org.apache.bcel.verifier.Verifier Demo complains: Pass 3b, method number 1 ['public static void main(String[] arg0)']:VERIFIED_REJECTEDConstraint violated in method 'public static void main(String[] arg0)':Instruction AASTORE constraint violated: The type of 'value' ('java.lang.Object') is not assignment compatible to the components of the array 'arrayref' refers to. ('java.lang.Integer') etc. The problem is that while the vmspec2 says "The type of every value stored into an array of type reference by an aastore instruction must be assignment compatible (§2.6.7) with the component type of the array", the class file doesn't contain information on the compile-time component type of the array. I suspect the native verifier does nothing about this requirement, leaving the VM to throw an ArrayStoreException if problems arise. Enver Haase asked me to mention in this report that while the error message says "assignment compatible to" and the vmspec2 says "assignment compatible with", it's not a case of doing the check the wrong way round.];[Here is my understanding of the problem: 1. Verification type of objs is Object[] 2. Run-time type of objs (in this particular case) is Integer[] 3. Verification type of the result of o() is Object Verification should pass, since it is purely concerned about verification type. However a run-time error should be thrown if o() return a non-null value. In this case since o() return null it shouldn't. scheng@innaworks.com Not quite. A run-time error should be thrown if o() return a non-null value which is not an Integer.];
BCEL-42;[BCEL-42] Public modifier for OperandStack.size();Fixed;Resolved;Apache Commons Developers;1079258651000;1108063087000;Bug;[Frame.java.diff, OperandStack.java.diff];[];[I want to use the the Frame(LocalVariables/OperandStack) information outside of the structural verifier. But the method OperandStack.size() is not a public method. So, can you please change this. Thanks, Stephan Michels.];[Attachment OperandStack.java.diff has been added with description: Diff file for OperandStack.java Currently I have no commit privilege - sorry I'll come back to that one later. Enver Can you also change the modifier of Frame._this ? BTW, with best regards from the TU Berlin Attachment Frame.java.diff has been added with description: Patch file for Frame.java];
BCEL-44;[BCEL-44] StructuralVerifier can't find protected fields of super classes;Fixed;Resolved;Apache Commons Developers;1079978688000;1122772078000;Bug;[InstConstraintVisitor.java.diff];[];[The InstConstraintVisitor didn't find a protected field of the super class, like: abstract Town {  protected int size.}class NewYork extends Town {  public int getSize() {    return size.  }}];[Attachment InstConstraintVisitor.java.diff has been added with description: Patch for InstConstraintVisitor.java applied to svn, with a few changes.];
BCEL-45;[BCEL-45] BCEL ClassParser throws ClassFormatException on Chinese locale class file;Won't Fix;Resolved;Apache Commons Developers;1080692153000;1221242988000;Bug;[];[];[I get the following exception when I have the BCEL ClassParser parse a particular class file. org.apache.bcel.classfile.ClassFormatException: Invalid byte tag in constant pool: 60 at org.apache.bcel.classfile.Constant.readConstant(Constant.java:145) at org.apache.bcel.classfile.ConstantPool.<init>(ConstantPool.java:103) at org.apache.bcel.classfile.ClassParser.readConstantPool (ClassParser.java:254) at org.apache.bcel.classfile.ClassParser.parse(ClassParser.java:162) at Test.main(Test.java:13) Here is a little test class that I use to reproduce the error: import org.apache.bcel.classfile.ClassParser. import org.apache.bcel.classfile.JavaClass. public class Test { public static void main(String[] args) { try { ClassParser parser = new ClassParser(args[0]). JavaClass jc = parser.parse(). } catch (Exception e) { e.printStackTrace(). } } } The exception occurs when it attempts to parse the LocaleElements_zh__PINYIN.class, which is a Chinese locale file found inside the icu4j.jar file... a jar that is part of the Jena distribution. If you run the above test program with the argument of LocaleElements_zh__PINYIN.class as the first and only argument, you reproduce the exception. And, as I mentioned above, this class file can be found inside icu4j.jar. Go to the following web site to obtain the Jena distribution, which has the icu4j.jar file inside the lib/ directory: http://prdownloads.sourceforge.net/jena/Jena-2.1.zip?download The odd thing is, all of the other chinese (zh) files do not throw the exception... only the PINYIN file. This bug occurred with BCEL version 5.1 running on Windows XP Professional: Version 2002, Service Pack 1.];[please attache the class file ...the zip file is no longer downloadable without the class file we cannot reproduce it Get the same error here. Jar: http://repo1.maven.org/maven2/com/ibm/icu/icu4j/2.6.1/icu4j-2.6.1.jar Stacktrace: org.apache.bcel.classfile.ClassFormatException: Invalid byte tag in constant pool: 60 at org.apache.bcel.classfile.Constant.readConstant(Constant.java:146) at org.apache.bcel.classfile.ConstantPool.<init>(ConstantPool.java:67) at org.apache.bcel.classfile.ClassParser.readConstantPool(ClassParser.java:222) at org.apache.bcel.classfile.ClassParser.parse(ClassParser.java:136) at org.apache.maven.shared.jar.classes.JarClassesAnalysis.analyze(JarClassesAnalysis.java:92) Running javap on the file, produces the same problems, so i believe this is just a bad class file. C:\>javap -v LocaleElements_zh__PINYIN java.lang.ClassFormatError: invalid constant type: 60 at sun.tools.javap.ClassData.readCP(ClassData.java:180) at sun.tools.javap.ClassData.read(ClassData.java:81) at sun.tools.javap.ClassData.<init>(ClassData.java:52) at sun.tools.javap.JavapPrinter.<init>(JavapPrinter.java:28) at sun.tools.javap.Main.displayResults(Main.java:201) at sun.tools.javap.Main.perform(Main.java:61) at sun.tools.javap.Main.entry(Main.java:49) at sun.tools.javap.Main.main(Main.java:34) ERROR:fatal error Exception in thread "main" java.lang.NullPointerException at sun.tools.javap.JavapPrinter.javaclassname(JavapPrinter.java:791) at sun.tools.javap.JavapPrinter.printclassHeader(JavapPrinter.java:60) at sun.tools.javap.JavapPrinter.print(JavapPrinter.java:36) at sun.tools.javap.Main.displayResults(Main.java:202) at sun.tools.javap.Main.perform(Main.java:61) at sun.tools.javap.Main.entry(Main.java:49) at sun.tools.javap.Main.main(Main.java:34) I'd suggest looking at the tool that generated the class file.];
BCEL-46;[BCEL-46] BCEL does not compile with JDK 1.5.0-beta-b32c;Cannot Reproduce;Resolved;Apache Commons Developers;1081599918000;1108025760000;Bug;[bcel-5.1-ambiguity-fix.diff];[];[Hi there One got 2 compile error when compiling BCEL with the JDK 1.5.0-beta-b32c ---------- 1. ERROR in D:\Eclipse\M8 \eclipse\workspace\com.pac.cdt.core\bcl\org\apache\bcel\classfile\Utility.java (at line 1352) private static class JavaWriter extends FilterWriter { ^^^^^^^^^^ The return type is incompatible with Appendable.append(char), Writer.append (char) ---------- 2. ERROR in D:\Eclipse\M8 \eclipse\workspace\com.pac.cdt.core\bcl\org\apache\bcel\classfile\Utility.java (at line 1352) private static class JavaWriter extends FilterWriter { ^^^^^^^^^^ The return type is incompatible with Appendable.append(CharSequence), Writer.append(CharSequence) ---------- 2 problems (2 errors) C:\java -version java version "1.5.0-beta" Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0-beta-b32c) Java HotSpot(TM) Client VM (build 1.5.0-beta-b32c, mixed mode) Regards];[Attachment bcel-5.1-ambiguity-fix.diff has been added with description: Fix for JDK 1.5 compile problem I'm compiling with 1.5 and it works fine, try upgrading and see if the problem still exists for you. Thanks! java version "1.5.0" Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0-b64) Java HotSpot(TM) Client VM (build 1.5.0-b64, mixed mode, sharing)];
BCEL-47;[BCEL-47] Corrupted instruction list created on valid class file;Fixed;Resolved;Apache Commons Developers;1085745892000;1108498111000;Bug;[];[];[The list created from a classfile can be suddenly meaningless: bcel fails to create a valid instruction list if one of the instruction is an LDC_W with a short (<256) index. In that case the following instruction is taken at an address with an offset error of -1 byte.];[Please, consider using the following patch to bcel/generic/LDC_W.java: — LDC_W.old Fri May 28 13:58:17 2004 +++ LDC_W.java Fri May 28 13:58:13 2004 @@ -84,5 +84,6 @@ setIndex(bytes.readUnsignedShort()). // Override just in case it has been changed opcode = org.apache.bcel.Constants.LDC_W. + length=3. } } Final comment: a compiler should not create on its own a LDC_W instruction if an LDC was enough but the code that triggered the bug was obfuscated to compress it. Then an offset that was "long" becomes "short". Obfuscators prefer not to change the rest of the code so they let the initial LDC_W instruction. This appears to be related to BCEL-48 This has been applied to CVS previously, and appears to have resolved at least one example. Please repost if the problem still exists.];
BCEL-48;[BCEL-48] LDC_W emits output with only one parameter byte;Fixed;Resolved;Apache Commons Developers;1088885181000;1108498162000;Bug;[patch, patch];[];[Fixing this took me half a day See this patch: Index: LDC_W.java =================================================================== RCS file: /home/cvspublic/jakarta-bcel/src/java/org/apache/bcel/generic/LDC_W.java,v retrieving revision 1.4 diff -u -r1.4 LDC_W.java — LDC_W.java 23 May 2003 07:55:17 -0000 1.4 +++ LDC_W.java 3 Jul 2004 20:02:10 -0000 @@ -82,7 +82,12 @@ throws IOException { setIndex(bytes.readUnsignedShort()). + /* + This is wrong!! (and thus commented out) + An LDC_W, which has got opcode LDC because index<256, may not change the opcode to LDC_W back, + because then it would emit an LDC_W opcode with only ONE byte as parameter, leading to class file corruption. + */ // Override just in case it has been changed - opcode = org.apache.bcel.Constants.LDC_W. + // opcode = org.apache.bcel.Constants.LDC_W. } }];[Attachment patch has been added with description: fixes the bug Attachment patch has been added with description: Makes this bug not happen again This is related to BCEL-47 which apparently has been committed. It would seem that this only occurs with poorly obfuscated code. Could the original poster, check the current svn code to see if the problem still exists with the fix of BCEL-47 in? The patch to BCEL-47 seems to have addressed this issue, in at least one example. Please repost if the problem still exists.];
BCEL-49;[BCEL-49] Build problems against jdk1.5;Fixed;Resolved;Apache Commons Developers;1097255004000;1121539164000;Bug;[];[];[There are two apparent problems. The first is that BCEL's "Deprecated" class has a name clash with the new "Deprecated" interface in java.lang, which first appeared in jdk1.5. Two obvious solutions to this are to (1) rename BCEL's class to something like "DeprecatedAttr" (which would break source that used this class) or (2) change all internal references to "Deprecated" to the fully qualified class name "org.apache.bcel.classfile.Deprecated". The second is much more minor. In "build.xml" the "jar" target depends on the "examples" target. Shouldn't it depend on "compile" (or perhaps "test"). In the "jar" target build instructions, there is also a mandatory dependency on the file "manifest.txt" it seems like this should be optional. If not present, let "jar" itself generate a Manifest.];[builds under 1.5 now];
BCEL-50;[BCEL-50] ClassPath.getClassPath() does not handle multiple java.ext.dirs entries properly;Fixed;Resolved;Apache Commons Developers;1097467947000;1107986391000;Bug;[ClassPath.patch];[];[While running Findbugs (which uses bcel) on Mac OS X, I noticed that the class path returned from ClassPath.getClassPath() was incorrect. The problem is that on Mac OS X, java.ext.dirs contains 3 different directories. The code searches all 3 directories for .jar/.zip files to add to path, but then appends each filename to the entire java.ext.dirs string, rather than appending it to the directory the file was found in.];[Attachment ClassPath.patch has been added with description: A patch for ClassPath.java that fixes problem Applied to SVN, Thanks];
BCEL-52;[BCEL-52] A security issue with public mutable static fields in BECL;Won't Fix;Resolved;Apache Commons Developers;1100279628000;1122767146000;Bug;[];[];[There is a security concern with those public mutable static fields in BCEL. According to Sun's security code guidelines (http://java.sun.com/security/seccodeguide.html), those public mutable static fields may cause "some unintended interactions between supposedly independent subsystems". In J2sdk1.5, becl code is distributed within rt.jar, if one application changes those fields, as long as one JVM alive, the second application run in the same JVM will have some unintended behavior.];[I don't consider this to be a significant concern. There are many other examples within rt.jar that do the same so it's not specific to BCEL. Closing.];
BCEL-53;[BCEL-53] Examples with enum breaks Gump (JDK1.5);Fixed;Resolved;Apache Commons Developers;1102952268000;1103068806000;Bug;[];[];[need i say more? (http://brutus.apache.org/gump/jdk15/jakarta-bcel/bcel/gump_work/build_jakarta-bcel_bcel.html) examples: [javac] Compiling 37 source files to /usr/local/gump/jdk15/workspace/jakarta-bcel/bin/classes [javac] /usr/local/gump/jdk15/workspace/jakarta-bcel/examples/Mini/MiniParser.java:895: as of release 1.5, 'enum' is a keyword, and may not be used as an identifier [javac] (try -source 1.4 or lower to use 'enum' as an identifier) [javac] for (java.util.Enumeration enum = jj_expentries.elements(). enum.hasMoreElements() { [javac] ^ [javac] /usr/local/gump/jdk15/workspace/jakarta-bcel/examples/Mini/MiniParser.java:895: as of release 1.5, 'enum' is a keyword, and may not be used as an identifier [javac] (try -source 1.4 or lower to use 'enum' as an identifier) [javac] for (java.util.Enumeration enum = jj_expentries.elements(). enum.hasMoreElements() { [javac] ^ [javac] /usr/local/gump/jdk15/workspace/jakarta-bcel/examples/Mini/MiniParser.java:896: as of release 1.5, 'enum' is a keyword, and may not be used as an identifier [javac] (try -source 1.4 or lower to use 'enum' as an identifier) [javac] int[] oldentry = (int[])(enum.nextElement()). [javac] ^ [javac] 3 errors BUILD FAILED /usr/local/gump/jdk15/workspace/jakarta-bcel/build.xml:78: Compile failed. see the compiler error output for details.];[fixed in CVS];
BCEL-54;[BCEL-54] Truncated "class" string in returned class name;Cannot Reproduce;Resolved;Apache Commons Developers;1104473542000;1109618985000;Bug;[];[];[The string "class" was truncated in the fully qualified class name being returned: e.g.: com.co.classification.MyClass -> com.coification.MyClass];[I am unable to duplicate this, perhaps I am not doing what you are doing. Does anyone have a sample that shows the problem? I am unable to reproduce this, and the OP does not seem to be around anymore. If someone can reproduce please repost.];
BCEL-57;[BCEL-57] Fix hashCode methods;Fixed;Resolved;Apache Commons Developers;1105260231000;1107987512000;Bug;[hashCode.patch];[];[Add missing and miscapitalized hashCode methods.];[Attachment hashCode.patch has been added with description: Patch to fix hashCode methods Applied to SVN, thanks!];
BCEL-58;[BCEL-58] "Illegal Opcode Detected" exception thrown in "new MethodGen( m, classname, cpgen )";Invalid;Closed;Apache Commons Developers;1106658820000;1107477603000;Bug;[];[];[REPRODUCIBLE ERROR: "Illegal Opcode Detected" exception is thrown in "new MethodGen( m, classname, cpgen )." when methods are read using a further (String) constant when a bunch of other fields was previously declared. Example: The following code Method[] methods = JavaClass.getMethods(). for(int j=0. j < methods.length. j++) { try { mg = new MethodGen(methods[j], _ClassName, _CPGen). } catch(Exception ex) { ... } } throws exception "Illegal Opcode Detected" in method 'test' when the class file representing the following code is parsed: class IllOpcode { private String a0 = "a". private String a1 = "a". ... please insert all other 246 declarations 'a2="a".' to 'a247="a".' ... private String a248 = "a". private int i249 = 1. private int i250 = 1. private int i251 = 1. // This one blasts! --> "Illegal Opcode Detected" private void test() { String l252 = "aa". } } //class If e.g. field "i251" is commented out no exception is thrown and the code works fine. I'm using jdk1.4.2 with my jbuilder SE 7.0.];[Not a bug: Caused by using wrong headers from import de.fub.bytecode];
BCEL-60;[BCEL-60] Unnecessary string object allocation in ConstantPoolGen;Won't Fix;Resolved;Apache Commons Developers;1108111171000;1122767386000;Bug;[BCEL-patch.diff.txt];[];[I was writing software that uses the BCEL library. Having performance problems, I found out that generic/ConstantPoolGen.java does unnecessary StringBuffer expansion: in two cases the length of the resulting string is known beforehand, but the created StringBuffer is not given a starting length for the internal buffer. With the attached patch applied, the running time of my application decreased from 1 min 45 seconds to 1 min 30 seconds as the generation of new constant pools was faster. (However, by rewriting my algorithm to do less constant pool instantiations, the running time dropped to 25 seconds).];[Attachment BCEL-patch.diff.txt has been added with description: Precalculates string buffer size to improve efficiency Here's a patch that improves the efficiency of constant pool generation. There would have to be extremely heavy use of this method to see a perceptive difference, i believe. I don't think the change is worth the increase in method size (and complexity).];
BCEL-61;[BCEL-61] LocalVariableTypeTable seems not to be updated like LocalVariableTable;Unresolved;Reopened;Apache Commons Developers;1108350003000;0;Bug;[];[];[Scenario: I insert into a method which has a parameterized argument some instructions and two local variables. The methods signature looks like this: public void doSomething( double d, ArrayList<Integer> list ) The method is situated in the class MyClassFile. Result: Loading the class MyClassFile which contains the new method 'doSomething' results in a ClassFormatError: LVTT entry for 'list' in class file MyClassFile does not match any LVT entry This error is not produced if the method declaration is done without generics: public void doSomething( double d, ArrayList list ) The difference is the LocalVariableTypeTable. It is not present if I do not use generics. Due to the insertion of the new instructions the start_pc and the length of the local variable have to be updated in the LocalVariableTable, which is done. But the corresponding entry in the LocalVariableTypeTable gets not updated its start_pc and length entries. LocalVariableTable ( BEFORE INSERTION ): start_pc, length, index, name 0, 26, 0, this 0, 26, 1, d 0, 26, 3, list LocalVariableTypeTable( BEFORE INSERTION ): 0, 26, 3, list LocalVariableTable ( AFTER INSERTION ): start_pc, length, index, name 44, 33, 0, this 44, 33, 1, d 44, 33, 3, list 1, 85, 4, wrapper_argumentlist 26, 60, 5, wrapper LocalVariableTypeTable( AFTER INSERTION ): 0, 26, 3, list The class works fine before the insertion. I've done bcel CVS checkout, but it did not help. The original instructions of the methods are not modified. I simply install a wrapper around the original body. I add an exception handler, therefore there is also an additional entry in the exceptiontable. I can toggle the error behaviour by using or not using the generic argument. generic -> error no generic -> no error I tried JDK 5.0 build 1.5.0-b64 and eclipse 3.1.0 build 200412162000 as a compiler. I use the JVR of the above mentioned JDK.];[One possible workaround before BCEL supports Local Variable type Tables is to simply remove the table. It is optional and everything seems to work fine if you remove it. Simply loop through the attributes and remove the one named "LocalVariableTypeTable". I think the only downside is that the information won't be available to a debugger. The proposed workaround works even with the Instrumentation.redefineClasses( ClassDefinition[] definitions ) of JDK1.5 So we this should be fixed for proper jdk 1.5 support It looks like a dup of http://issues.apache.org/bugzilla/show_bug.cgi?id=39695 i have loop through the attributes and remove the one named "LocalVariableTypeTabe". The problem still occurs];
BCEL-62;[BCEL-62] Wrong word in manual: use 'factorial', not 'faculty';Fixed;Resolved;Apache Commons Developers;1109806472000;1121540074000;Bug;[];[];[The manual author has consistently used the word 'faculty' to mean 'factorial', but it doesn't. This doesn't break any code, but is kind of distracting (if not downright embarrassing), and might even slow down some new readers, who have to think about it long enough to realize it's a mistake and not some obscure mathematical jargon they haven't caught up with!];[yes this is silly.. Changed.];
BCEL-63;[BCEL-63] JavaClass.dump(OutputStream/DataOutputStream) shouldnt call close;Fixed;Resolved;Apache Commons Developers;1112757321000;1112907704000;Bug;[];[];[I think it would be more helpful if JavaClass.dump(*OutputStream) didnt call close as the caller may not be finished with the stream. Only for JavaClass.dump(File) does BCEL "own" the OutputStream. It also looks like the caller should provide an extra finally {... os.close() } as JavaClass.dump may not close the stream in the event of an error. For a concrete example: When writing a JAR using JarOutputStream the stream shouldnt be closed till multiple classes have been written. So the real stream has to be wrapped with a Filter/Proxy that ignores close. This problem also appears for ClassParser. Many thanks for your excellent code.];[Agreed, The fact that the stream is created in the constructor is a bad idea as well. I'll look into reworking this area. JavaClass and ClassParser now only close streams that they explicitly open. Also move the creating of streams in ClassParser from the constructor to parse, so that the lifetime of the stream can be explicitly controlled thru try/finally.];
BCEL-64;[BCEL-64] ClassCastException on justice;Fixed;Resolved;Apache Commons Developers;1113319824000;1122769686000;Bug;[j00000.class];[];[Run "java -cp ..bcel-5.1.jar org.apache.bcel.verifier.Verifier j00000.class", where j00000.class is a hand-made class file that contains some errors (that I'm trying to identify). JustIce ends with a ClassCastException. The output from the verifier is: JustIce by Enver Haase, (C) 2001-2002. <http://bcel.sourceforge.net> <http://jakarta.apache.org/bcel> Now verifying: j00000 Pass 1: VERIFIED_OK Passed verification. Pass 2: VERIFIED_OK Passed verification. Pass 3a, method number 0 ['public void <init>()']: VERIFIED_OK Passed verification. Visiting non-standard Signature object Visiting non-standard Signature object Visiting non-standard Signature object Visiting non-standard Signature object Visiting non-standard Signature object Visiting non-standard Signature object Visiting non-standard Signature object Visiting non-standard Signature object Pass 3b, method number 0 ['public void <init>()']: VERIFIED_OK Passed verification. Exception in thread "main" java.lang.ClassCastException: org.apache.bcel.classfi le.ConstantUtf8 at org.apache.bcel.generic.FieldOrMethod.getClassName(FieldOrMethod.java :102) at org.apache.bcel.generic.FieldOrMethod.getClassType(FieldOrMethod.java :109) at org.apache.bcel.generic.FieldOrMethod.getLoadClassType(FieldOrMethod. java:115) at org.apache.bcel.verifier.statics.Pass3aVerifier$InstOperandConstraint Visitor.visitLoadClass(Pass3aVerifier.java:430) at org.apache.bcel.generic.GETSTATIC.accept(GETSTATIC.java:107) at org.apache.bcel.generic.InstructionHandle.accept(InstructionHandle.ja va:282) at org.apache.bcel.verifier.statics.Pass3aVerifier.pass3StaticInstructio nOperandsChecks(Pass3aVerifier.java:364) at org.apache.bcel.verifier.statics.Pass3aVerifier.do_verify(Pass3aVerif ier.java:160) at org.apache.bcel.verifier.PassVerifier.verify(PassVerifier.java:108) at org.apache.bcel.verifier.Verifier.doPass3a(Verifier.java:121) at org.apache.bcel.verifier.Verifier.main(Verifier.java:263)];[Attachment j00000.class has been added with description: Buggy class file that makes justice bomb This stack trace appears to be helplessly out of date. Does this problem still occur with current svn? I don't have the "current svn version", and given that I solved my problem with this .class file, I'm not really excited at the idea of getting the latest svn version, compiling it and testing it. I attached the class file that makes justice crash, so it should be trivial to someone with access to the latest svn version to try it out. Cheers,];
BCEL-65;[BCEL-65] InnerClass doesn't implement Serializable;Fixed;Resolved;Apache Commons Developers;1113486602000;1121540442000;Bug;[];[];[org.apache.bcel.classfile.InnerClass doesn't implement Serializable. It prevents me from serializing a graph of object containing a JavaClass.];[agreed, added.];
BCEL-66;[BCEL-66] Branch target offset too large for short;Invalid;Closed;Apache Commons Developers;1119058236000;1121739524000;Bug;[];[];[We are using bcel library for code generation. And for some particualr scenarios our method size is exceeding the method size limit defined by java (65535 bytes) and we get the following error, org.apache.bcel.generic.ClassGenException: Branch target offset too large for short at org.apache.bcel.generic.BranchInstruction.dump(BranchInstruction.java:100) at org.apache.bcel.generic.InstructionList.getByteCode(InstructionList.java:980) at org.apache.bcel.generic.MethodGen.getMethod(MethodGen.java:616) When the method size limit is defined in java as 65535, why does the BCEL gives an error for 32767, in org.apache.bcel.generic.BranchInstruction.dump(DataOutputStream out) the check is for, if(Math.abs(index) >= 32767) // too large for short throw new ClassGenException("Branch target offset too large for short"). why not instead have the if(Math.abs(index) >= 65535) I tried this and then my application works fine, I want to be sure if thats the right approach.];[From Java class specification for if_icmp<cond> If the comparison succeeds, the unsigned branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset, where the offset is calculated to be (branchbyte1 << 8) | branchbyte2];
BCEL-67;[BCEL-67] Source downloads are broken;Cannot Reproduce;Closed;Apache Commons Developers;1120569949000;1138338155000;Bug;[];[];[bcel-5.1-src.tar.gz is a 12 MB tarball containing a backup of the download site, including anything but the source I was looking for. [bero@arklinux SOURCES]$ tar tzf bcel-5.1-src.tar.gz bcel-5.1-src.zip bcel-5.1.tar.gz bcel-5.1.zip home/rdonkin/release.tar.gz bcel-5.1-src.zip is better, but incomplete. running ant in there results in BUILD FAILED /usr/src/ark/SOURCES/bcel-5.1/build.xml:78: srcdir "/usr/src/ark/SOURCES/bcel-5.1/examples" does not exist! because the examples are missing. The exact same thing is true for the bcel-current-src.* archives.];[To make things worse, BCEL_5_1 is not tagged in SVN – there doesn't seem to be a way to get hold of the 5.1 source. trunk seems to work. The src zip is also available from the download site. Maven appears to work fine, using ant fails at first due to the lack of a regexp jar. Adding that jar to the lib/ and 'ant compile' passes, but 'ant jar' (the default target) fails due to the lack of examples. Short term fix: Remove the -src.tar.gz on the mirrors. Recommend Maven for building via the -src.zip. ...but I am wondering why we provide an ant build for the source dist];
BCEL-68;[BCEL-68] Unable to generate method that returns an array of integers;Fixed;Resolved;Apache Commons Developers;1123060094000;1123106265000;Bug;[];[];[I'm trying to generate the following code use BCEL: package bci. public class Test { public int[] getArray() { return new int[1]. } public static void main(String[] args) { } } I use BCELIfier to generate the code that creates Test. The snippet that creates getArray is private void createMethod_2() { InstructionList il = new InstructionList(). MethodGen method = new MethodGen(ACC_PUBLIC, new ArrayType(T_INT, 1), Type.NO_ARGS, new String[] { }, "getArray", "bci.Test", il, _cp). InstructionHandle ih_0 = il.append(new PUSH(_cp, 1)). il.append(_factory.createNewArray(new ArrayType(T_INT, 1), (short) 1)). InstructionHandle ih_3 = il.append(_factory.createReturn(Type.OBJECT)). method.setMaxStack(). method.setMaxLocals(). _cg.addMethod(method.getMethod()). il.dispose(). } I run TestCreator (generated by BCELIfier) and execute Test, which triggers the following error: Exception in thread "main" java.lang.VerifyError: (class: bci/Test, method: getArray signature: ()[I) Wrong return type in function If I return null rather than the array, everything is perfectly allright.];[I figured this is actually a bug in BCELIfier. Rather than il.append(_factory.createNewArray(new ArrayType(Type.INT, 1), (short) 1)). it should say il.append(_factory.createNewArray(Type.INT, (short) 1)). agreed... working on it. fix applied to svn, thanks for the report.];
BCEL-69;[BCEL-69] A bug in LocalVariableGen;Fixed;Resolved;Apache Commons Developers;1123658222000;1141967772000;Bug;[];[];[I'm one of the developers working on the Jakarta commons sandbox javaflow project. This problem is observed in the trunk (as of 2005/08/09), and it's causing some test failures in the gump build of the said javaflow project. Here's what I found while tracing through the code. When LocalVariableGen is created by using the following constructor: >  public LocalVariableGen(int index, String name, Type type,>                          InstructionHandle start, InstructionHandle end) {>    if((index < 0) || (index > Constants.MAX_SHORT))>      throw new ClassGenException("Invalid index index: " + index).>    >    this.name  = name.>    this.type  = type.>    this.index  = index.>    setStart(start).>    setEnd(end).>  } During the setStart method, it registers this newly created LocalVariableGen as a targeter to the InstructionHandle given by the 'start' parameter. InstructionHandle.targeters is a HashSet. So adding a LocalVariableGen as a targter means inserting a LocalVariableGen into a HashSet. This involves in computing the hashCode. So from within the setStart method, LocalVariableGen.hashCode() is invoked, since the end instruction isn't set yet, this returns a hashCode based on just index and start, ignoring the end field. Then immediately after the setStart method returns, the above constructor now sets the end instruction. As a result of this, hash code of the LocalVariableGen changes. This makes it impossible to update the start of LocalVariableGen correctly, because LocalVariableGen can no longer remove itself from the targeter set of the previous 'start' instruction. In other words, the problem is that the LocalVariableGen class computes its hash code based on mutable fields, yet at the same time it is used in a HashSet, where objects are not allowed to change its hash code. To the eyes of a new comer like me, this seems like a rather fundamental design flaw in the current BCEL library. SUGGESTED FIX ============= implement the hashCode method to return a constant value would fix the problem at the expense of the performance:   public int hashCode() {     return 42.  } Alternatively, instead of using HashSet, use a custom implementation of a Set where the identity hash code is used instead of Object.hashCode. Although I haven't tested this approach, I believe this also fixes the problem. There may be other ways to fix the problem.];[agreed.. nice detective work. I've added this, which i believe should be valid, and solve the problem, if icky. public LocalVariableGen(int index, String name, Type type, InstructionHandle start, InstructionHandle end) { if((index < 0) || (index > Constants.MAX_SHORT)) throw new ClassGenException("Invalid index index: " + index). this.name = name. this.type = type. this.index = index. // setStart and setEnd add 'this' to a HashSet, causing the hash to compute. // The hash uses start and end, so set them before calling setStart/setEnd. // Otherwise, the remove will fail because the hash is different than the add. // Icky, but should be ok. See BCEL-69 -- dbrosius this.start = start. this.end = end. setStart(start). setEnd(end). } please let us know if there are still problems. Sorry, that didn't fix the problem. Now it causes an NPE like this: 1. the LocalVariableGen constructor sets start and end to non-null 2. then it calls the setStart method. 3. the setStart method calls the notifyTarget method to remove itself from the old handle, and add itself to the new handle. 4. in this case, since the start field is already set, the old handle is non-null. 5. the notifyTarget method calls the removeTargeter method to remove the LocalVariableGen from the old InstructionHandle. 6. But since this 'old' InsturctionHandle doesn't actually have any targeter yet, the following method causes NPE. > public void removeTargeter(InstructionTargeter t) { > targeters.remove(t). > } Besides, I think we really need a proper fix to this problem. The suggested fix doesn't work if I attempt to move the start/end more than once. rolled back perhaps we can just remove start and end from the hashcode calc, and perhaps instead base it on index, name and type. That would work for the current tests we have for javaflow. So I appreciate if you could make those changes, as GUMP error messages are killing me now But I still hope the BCEL project will address this problem more fundamentally in a near future. In BCEL, I'm allowed to change any of index, name, and type. It will still break if someone tries to rename the local variable, then move its start/end range. this is fixed now, isnt it? (In reply to comment #6) > this is fixed now, isnt it? It is patched.. The exact bug report is fixed. The problem still remains that if the user changes name and/or type (which is less likely) it will still occur. Then let's close it for now ...until someone has the need to fix that case as well.];
BCEL-70;[BCEL-70] NullPointerException in getLineNumber bei "continue" in for each;Fixed;Resolved;Apache Commons Developers;1127928083000;1128691288000;Bug;[TestSOAPAnnotation.class, TestSOAPAnnotation.java];[];[Hi, I got a NullPointerException using the FindBugs GUI I think BCEL has a problem with "continue" in the new for loop. The source code of the problematic file is attached as a simplified test case. Fataler Fehler während der Analyse: java.lang.NullPointerException: While finding bugs in class: de.his.test.soap.TestSOAPAnnotation org.apache.bcel.generic.LineNumberGen.getLineNumber(LineNumberGen.java:72) org.apache.bcel.generic.MethodGen.getLineNumberTable(MethodGen.java:474) edu.umd.cs.findbugs.SourceLineAnnotation.fromVisitedInstruction(SourceLineAnnotation.java:312) edu.umd.cs.findbugs.detect.FindInconsistentSync2$FieldStats.addAccess(FindInconsistentSync2.java:184) edu.umd.cs.findbugs.detect.FindInconsistentSync2.analyzeMethod(FindInconsistentSync2.java:532) edu.umd.cs.findbugs.detect.FindInconsistentSync2.visitClassContext(FindInconsistentSync2.java:259) edu.umd.cs.findbugs.FindBugs.examineClass(FindBugs.java:1598) edu.umd.cs.findbugs.FindBugs.executeAnalysisPass(FindBugs.java:1517) edu.umd.cs.findbugs.FindBugs.execute(FindBugs.java:1171) edu.umd.cs.findbugs.gui.AnalysisRun.execute(AnalysisRun.java:109) edu.umd.cs.findbugs.gui.RunAnalysisDialog$1.run(RunAnalysisDialog.java:138)];[Attachment TestSOAPAnnotation.java has been added with description: TestCase Unfortunately, i am unable to reproduce this in FindBugs 0.9.3, in fact the FieldStats class, from which this error occurs (in findbugs), does not seem to ever be created. Perhaps I am using a different jdk, or FindBugs, than you. To rull out the former, perhaps you could post the .class file of the sample code. This file was compiled using Eclipse 3.1 (Build id: I20050627-1435) on Debian/GNU Linux. hendrik@voyager:/mnt/lsf/test-bcel$ java -version java version "1.5.0" Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0-b64) Java HotSpot(TM) Client VM (build 1.5.0-b64, mixed mode) Attachment TestSOAPAnnotation.class has been added with description: de/his/test/soap/TestSOAPAnnotation.class Ok, with the attached .class file i am able to reproduce your problem. Thanks! Here's the javap output for this method: public void testContentOfWSDDISAnnotated(). Code: Stack=2, Locals=4, Args_size=1 0: new #16. //class java/util/ArrayList 3: dup 4: invokespecial #17. //Method java/util/ArrayList."<init>")V 7: astore_1 8: aload_1 9: invokeinterface #23, 1. //InterfaceMethod java/util/List.iterator) Ljava/util/Iterator. 14: astore_3 15: goto 32 18: aload_3 19: invokeinterface #29, 1. //InterfaceMethod java/util/Iterator.next) Ljava/lang/Object. 24: checkcast #31. //class java/lang/String 27: astore_2 28: aload_2 29: ifnonnull 32 32: aload_3 33: invokeinterface #35, 1. //InterfaceMethod java/util/Iterator.hasNext: ()Z 38: ifne 18 41: return LineNumberTable: line 9: 0 line 13: 8 line 14: 28 line 13: 35 line 18: 41 ------------- Notice the LineNumberTable's 4th entry: line 13:35 this says source line 13 is at byte offset 35. But notice that byte offset 35 is not a valid instruction start. It looks like a bug in the tool that generated this class file, to me. it probably should have been line 13:32 Applied Patch: If the LineNumberTable has a bad byte offset, don't add a LineNumberGen for that line to the MethodGen's list of LineNumbers. Thanks, Dave.];
BCEL-72;[BCEL-72] BCEL depends on AWT;Fixed;Resolved;Apache Commons Developers;1133200293000;1133208012000;Bug;[];[];[BCEL has a dependency on AWT (See http://svn.apache.org/viewcvs.cgi/jakarta/bcel/trunk/src/java/org/apache/bcel/verifier/structurals/Subroutines.java?rev=292117&view=markup ) that forces users on Unix/Linux systems to have the X11 libs installed and to specify -Djava.awt.headless=true if running on a headless system. Since it looks like the above-mentioned class just uses the Color.white, Color.gray and Color.black constants from java.awt.Color, we could probably define and use an own set of constants for this purpose.];[applied to SVN, thanks!.];
BCEL-74;[BCEL-74] BCEL cannot be used as java.system.class.loader;Fixed;Closed;Apache Commons Developers;1138168104000;1159417392000;Bug;[bcel.bug.38377.patch, bcel.diff];[];[The property java.system.class.loader is supposed to allow JVM users to change the default class loader to another class. org.apache.bcel.util.ClassLoader cannot be used with this property. Setting -Djava.system.class.loader=org.apache.bcel.util.ClassLoader provokes this at load time. Error occurred during initialization of VM java.lang.Error: java.lang.IllegalStateException: recursive invocation java version "1.5.0_06" Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_06-b05) Java HotSpot(TM) 64-Bit Server VM (build 1.5.0_06-b05, mixed mode) this bug also applies to SVN-HEAD.];[This link might provide additionnal informations: http://www.mail-archive.com/bcel-dev%40jakarta.apache.org/msg00451.html hmmm. I attempted to do as you suggest, but can't seem to shake the java.lang.Error: java.lang.IllegalStateException: recursive invocation error. could getParent() be returning org.apache.bcel.util.ClassLoader, in this case? Unfortunately the error occurs before debugging begins. Any ideas? To reproduce: public class EmptyMain { public static void main(String[] args) { } } neumann@Silvester:/tmp$ javac EmptyMain.java neumann@Silvester:/tmp$ java -Djava.system.class.loader=org.apache.bcel.util.ClassLoader -cp /home/neumann/Libs/bcel-5.1/bcel-5.1.jar:. EmptyMain Error occurred during initialization of VM java.lang.Error: java.lang.IllegalStateException: recursive invocation neumann@Silvester:/tmp$ java -version java version "1.5.0_06" Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_06-b05) Java HotSpot(TM) 64-Bit Server VM (build 1.5.0_06-b05, mixed mode) A tentative patch will soon follow. This is a tentative patch. It may not well be the solution to the problem, but it does remove the IllegalStateException error. I think the problem is that, once initSystemClassLoader is called (it's in java.lang.ClassLoader), no class should depend load java.lang.ClassLoader or you get a indirectly recursive call of initSystemClassLoader. Attachment bcel.diff has been added with description: Tentative patch. Now that I think of it, my idea of the source of the problem is probably wrong so disregard the explanation after the patch. The patch, though, still solves the problem. tentative this looks ok ...I am not 100% but since it solves the problem I've just committed it I created a subclass of org..ClassLoader (lets call is SLoader) and tried to use it as the system class loader, but it gave me the same error as described in the initial comment. The class looks like this: public class SLoader extends ClassLoader{ [...] public SLoader(java.lang.ClassLoader deferTo) { super(deferTo, new String[] { "java.", "javax.", "com.sun.", "sun."} ). } [...] } The JVM calls the above constructor when the class is passed with the -Djava.system.class.loader VM argument. This constructor then calls the constructor of the org..ClassLoader public class ClassLoader extends java.lang.ClassLoader { [...] public ClassLoader(java.lang.ClassLoader deferTo, String[] ignored_packages) { this(ignored_packages). this.repository = new ClassLoaderRepository(deferTo). } [...] } As you can see, there is no explicit call the any constructor of the java..ClassLoader class. This causes its default constructor to be invoked, which tries to resolv the parent class loader by calling java..ClassLoader.getSystemClassLoader() which causes the loop in the class loader hierarchy. The appended patch fixes this by explicitly invoking the java.lang.ClassLoader.ClassLoader(ClassLoader parent) constructor which does not use the getSystemClassLoader() method. A question about the bug reporting process: Should I REOPEN the bug and then set it RESOLVED/FIXED again? Attachment bcel.bug.38377.patch has been added with description: Patch for ClassLoader constructor];
BCEL-75;[BCEL-75] LineNumberTable toString method uses jdk 1.4 StringBuffer append(StringBuffer) method.;Fixed;Closed;Apache Commons Developers;1138393280000;1666870405000;Bug;[patch.txt];[];[I have noticed that the current BCEL trunk expects to build the BCEL package against jdk 1.3. The LineNumberTable class toString method uses the StringBuffer append(StringBuffer) method that been defined since jdk 1.4. Any builds using jdk 1.4 or greater will use of this method call. I have also noticed that the toString method adds a new line after printing 72 characters but it append the '\n' character instead of what the "line.separator" property is defined as. I have a patch for this issue that I will add to this bug report.];[Here is a patch for this issue: This was generated using the diff command -x and -u options. Index: bcel/src/java/org/apache/bcel/classfile/LineNumberTable.java =================================================================== — bcel/src/java/org/apache/bcel/classfile/LineNumberTable.java (revision 372884) +++ bcel/src/java/org/apache/bcel/classfile/LineNumberTable.java (working copy) @@ -122,6 +122,7 @@ public final String toString() { StringBuffer buf = new StringBuffer(). StringBuffer line = new StringBuffer(). + String newLine = System.getProperty("line.separator", "\n"). for(int i=0. i < line_number_table_length. i++) { line.append(line_number_table[i].toString()). @@ -130,8 +131,8 @@ line.append(", "). if(line.length() > 72) { - line.append('\n'). - buf.append(line). + line.append(newLine). + buf.append(line.toString()). line.setLength(0). } } The priviously pasted diffs format was altered. Added an attachment for consistency of patch file. Attachment patch.txt has been added with description: This is a good patch diff file. applied, thanks!];
BCEL-77;[BCEL-77] XSLT transforms broken in Turkish Locale.;Fixed;Closed;Apache Commons Developers;1140990368000;1263123279000;Bug;[];[];[There is a bug in org.apache.bcel.internal.util.InstructionFinder.compilePattern Please also refer to this bug report for more details about dottless i and Turkish .toLowerCase problem. Second comment of the bug report (Submitted On 08- JAN-2006) is very important. http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6240963 I am trying to use ActiveMQ JMS 1.1 Provider but when I am trying to start it on a Windows 2000 SP4 with Turkish Default Locale I have following exception. java.lang.RuntimeException: Instruction unknown: load²nstruction at com.sun.org.apache.bcel.internal.util.InstructionFinder.mapName (InstructionFinder.java:138) at com.sun.org.apache.bcel.internal.util.InstructionFinder.compilePattern (InstructionFinder.java:170) at com.sun.org.apache.bcel.internal.util.InstructionFinder.search (InstructionFinder.java:218) at com.sun.org.apache.bcel.internal.util.InstructionFinder.search (InstructionFinder.java:264) at com.sun.org.apache.xalan.internal.xsltc.compiler.Mode.peepHoleOptimization (Mode.java:1444) at com.sun.org.apache.xalan.internal.xsltc.compiler.Mode.compileApplyTemplates (Mode.java:1058) at com.sun.org.apache.xalan.internal.xsltc.compiler.Stylesheet.compileModes (Stylesheet.java:615) at com.sun.org.apache.xalan.internal.xsltc.compiler.Stylesheet.translate (Stylesheet.java:730) at com.sun.org.apache.xalan.internal.xsltc.compiler.XSLTC.compile (XSLTC.java:335) at com.sun.org.apache.xalan.internal.xsltc.compiler.XSLTC.compile (XSLTC.java:410) at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl.newTemplates (TransformerFactoryImpl.java:791) at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl.newTransform er(TransformerFactoryImpl.java:619) at org.activemq.spring.ActiveMQBeanDefinitionReader.createTransformer (ActiveMQBeanDefinitionReader.java:63) at org.activemq.spring.ActiveMQBeanDefinitionReader.transformDocument (ActiveMQBeanDefinitionReader.java:94) at org.activemq.spring.ActiveMQBeanDefinitionReader.registerBeanDefinitions (ActiveMQBeanDefinitionReader.java:53) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinition s(XmlBeanDefinitionReader.java:155) at org.activemq.spring.ActiveMQBeanFactory.<init> (ActiveMQBeanFactory.java:86) at org.activemq.spring.ActiveMQBeanFactory.<init> (ActiveMQBeanFactory.java:57) at org.activemq.spring.SpringBrokerContainerFactory.createBrokerContainer (SpringBrokerContainerFactory.java:86) at org.activemq.spring.Main.main(Main.java:71) When I switch to English US defult locale everything works fine. So there are lots of tools and open source projects (like NetBeans) which uses BCEL. This is a big problem for us which working on Turkish Locale. Thanks];[Thanks for the report. changed toLowerCase to toLowerCase(Locale.ENGLISH), as use is to search for java instructions, which are always english anyway. Hi could you tell us in which version this bug is fixed? Latest bcel release, 5.2 still has this bug. Official jre have the bug in com/sun/org/apache/bcel/internal/util/InstructionFinder.compilePattern. It exists even in latest jre6 and jre1.5.0_21. It is not very hard to modify the bcel source code and load it into bootclasspath before rt.jar but to be clean it needs to be fixed. Will Apache or Sun fix this sometime? This is fixed in BCEL trunk (so scheduled for 5.3). When/if BCEL gets updated inside the JDK - no idea.];
BCEL-78;[BCEL-78] NullPointerException in InstructionHandle;Fixed;Resolved;Apache Commons Developers;1141326806000;1141318245000;Bug;[];[];[please add missing checks for null references in InstructionHandle.java to avoid null pointer exceptions: A) in line 161   /**   * Denote this handle isn't referenced anymore by t.   */  public void removeTargeter(InstructionTargeter t) {==ADD==>    if (targeters != null)      targeters.remove(t).  } B) in line 238   /** @return all attributes associated with this handle   */  public Collection getAttributes() {==ADD==>    if(attributes == null)==ADD==>      attributes = new HashMap(3).    return attributes.values().  }];[Thanks for that. If possible please provide a diff next time instead.];
BCEL-79;[BCEL-79] java.lang.ClassFormatError: LVTT entry for 'local' in class file org/shiftone/jrat/test/dummy/CrashTestDummy does not match any LVT entry;Fixed;Closed;Apache Commons Developers;1149108231000;1439591147000;Bug;[bcel-patch-method.txt, bug79.diff];[];[I have tried both the release at http://people.apache.org/~tcurdt/bcel/rc2/ , as well as a build from head (410655). I see the same ClassFormatError with both. I get this error when running a JRat test case. This project and the test case is avalible on sourceforge (http://sourceforge.net/projects/jrat) - or I can provide it directly. The test case uses BCEL to isntrument a class and then tries to execute methods various methods on it. see org.shiftone.jrat.test.InjectorTestCase java.lang.ClassFormatError: LVTT entry for 'local' in class file org/shiftone/jrat/test/dummy/CrashTestDummy does not match any LVT entry at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:620) at java.lang.ClassLoader.defineClass(ClassLoader.java:465) at org.shiftone.jrat.test.TestClassLoader.loadClass(TestClassLoader.java:36) at org.shiftone.jrat.test.InjectorTestCase.setUp(InjectorTestCase.java:52) at com.intellij.rt.execution.junit2.JUnitStarter.main(JUnitStarter.java:32) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:90)];[Compiling with -g:lines,source fixes the problem however this is not an acceptable option for me since a user may want to profile code that they didn't write or have the source for. fair enough ...could you provide a patch? With some luck it could then still make it into 5.2 Changed the severity to "critical" because it renders BCEL useless on Java5 or newer. What's the status here? Did you try with trunk? Would be great if you could attach the testcase. Just tried with HEAD and does not work java.lang.ClassFormatError: LVTT entry for 'employees' in class file The classes I'm using against trunk HEAD. Hope this helps class Department implements java.io.Serializable { private Collection<Employee> employees. public Collection<Employee> getEmployees() { return employees. } public void setEmployees(Collection<Employee> employees) { this.employees = employees. } } class Employee implements java.io.Serializable { private String name. } This patch fixes this issue to me. The fix is with copying the LVTT entries from method to MethodGen. In addition, a cosmetic change in the MethodGen.toString method to output the signature attributes, same as Method.toString does. Attachment bcel-patch-method.txt has been added with description: copying the LVTT entries from method to MethodGen I forgot to say that the patch attached (2007-03-28 11:41), fix the case where a setter having a generic argument is bytecode modified using BCEL. I dont know if there are other cases. The patch works for me, for several classes and several scenarios. public void setEmployees(Collection<Employee> employees) { this.employees = employees. } Thanks! Applied! This bug fix is quite incorrect and I have no idea how it how it solved the original bug. The key point is there is absolutely no requirement for there to be as many LocalVariableTypeTable entries as there are LocalVariables. In fact, there will almost always be fewer. Quoting from the JVM spec, section 4.7.14 "The LocalVariableTypeTable attribute differs from the LocalVariableTable attribute (§4.7.13) in that it provides signature information rather than descriptor information. This difference is only significant for variables whose type uses a type variable or parameterized type. Such variables will appear in both tables, while variables of other types will appear only in LocalVariableTable." Thus deleting all the local variables and then reconstructing them from types is completely incorrect. I have no idea what the bug fix intentions were - Perhaps the test case had the same number of vars and types?? Our fix was to simply comment the entire fix out and we have not run into any problems since. (As an aside, it appears to be quite a flaw in BCEL verification test suite not to have caught this.) Mark, do you have a repro case or a unit test where the original bug fix does not work as intended? You said "you have not run into any problems since", so it'd be interesting to know what problem you ran into. If I comment out the code added in the bug fix then the tests still pass. This will definitely need a test case that doesn't pass both with and without that section of code I have created a test case that demonstrates the failure of the current code. (As noted above, most of the locals are incorrectly discarded. local var count goes from 4 to 1.) In the process, I realized that most of the implementation for LocalVariableTypeTable is just wrong. It assumes that LocalVariables and LocalVariableTypes are equivalent, if you have one you don't need the other. Also, it assumes that descriptors and signatures are equivalent. If you uncomment out the indicated line in the test, you will see BCEL crash due to this fact. In addition, there is no way for a user to inspect the LocalVariableTypeTable. The only getLocalVariableTypeTable() method is in LocalVariableTypeTable - pretty nifty Catch 22. Please attach source for org.apache.bcel.data.PLSETestClass which is used by org.apache.bcel.PLSETestCase. I have updated the PLSE test case to demonstrate this problem: bug79.diff. I tried applying the two patches (bug79 and PLSETestCase) but the test runs without an error. I thought bug79 was supposed to show the error? The PLSETestCase was just added to the trunk yesterday (as part of 208) so for 79 you should ignore the attached java file and just apply bug79.diff to the existing code. (The other attached txt file was already been applied some time ago.) Mark Huh? The file PLSETestCase.java additionally contains the method testB79() which is not in trunk (yet). Also, I thought the bug79 update to the test data class was supposed to demonstrate the issue? If so, I am not seeing any test errors resulting from the testdata update, even when testB79 is added. I have deleted the PLSETestCase.java attached to this bug report. Here are the steps i took: svn info shows Last Changed Rev: 1695799 I then apply bug79.diff which adds a new test method testB79 to the existing PLSETestCase.java and adds a new method meth2 to PLSETestClass.java. i then do mvn verify and here is a slice of the output: Running org.apache.commons.bcel6.PLSETestCase Tests run: 2, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.203 sec <<< FAILURE! - in org.apache.commons.bcel6.PLSETestCase testB79(org.apache.commons.bcel6.PLSETestCase) Time elapsed: 0.199 sec <<< FAILURE! junit.framework.AssertionFailedError: number of locals expected:<5> but was:<1> at junit.framework.Assert.fail(Assert.java:57) at junit.framework.Assert.failNotEquals(Assert.java:329) at junit.framework.Assert.assertEquals(Assert.java:78) at junit.framework.Assert.assertEquals(Assert.java:234) at junit.framework.TestCase.assertEquals(TestCase.java:401) at org.apache.commons.bcel6.PLSETestCase.testB79(PLSETestCase.java:63) The fix is to remove the code added by the attached file bcel-patch-method.txt. URL: http://svn.apache.org/r1695997 Log: BCEL-79 - Add test to show the problem, and re-fix it Modified: commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/MethodGen.java commons/proper/bcel/trunk/src/test/java/org/apache/commons/bcel6/PLSETestCase.java commons/proper/bcel/trunk/src/test/java/org/apache/commons/bcel6/data/PLSETestClass.java Ah - now I see what the problem was. I thought the patches were the same, but the latest patch uses gen.getMethodAt(2) in the testB79() method whereas the original used gen.getMethodAt(1). Using index 2 causes the test failure as expected.];
BCEL-81;[BCEL-81] ClassParser.parse() throws NullPointerException if class does not exist and ClassParser(String) constructor is used;Fixed;Closed;Apache Commons Developers;1149888227000;1173509710000;Bug;[ClassParser.patch];[];[Reproduce: ClassParser cp = new ClassParser("does/not/exist/Classfile.class"). JavaClass jc = cp.parse(). --> throws NullPointerException instead of FileNotFoundException The problem is that when the constructor that accepts a string is used, the fileOwned flag is set and parse() attempts to close the file in the finally block. The guarded region for the finally block includes the attempt to open the input stream, which may fail, but the finally block itself erroneously assumes the input stream object has been created. Previously this situation caused the method to correctly throw a FileNotFoundException.];[Attachment ClassParser.patch has been added with description: Patch to resolve error. Thanks for the patch!];
BCEL-82;[BCEL-82] BCEL 5.2 is not source compatible with 5.1;Won't Fix;Resolved;Apache Commons Developers;1149890170000;1398347660000;Bug;[];[];[At least two methods now declare checked exceptions that did not previously. there may be others: org.apache.bcel.generic.ObjectType.subclassOf(ObjectType) org.apache.bcel.generic.ReferenceType.getFirstCommonSuperclass(ReferenceType) --> Both now declare ClassNotFoundException This of course causes a compile-time error in existing code that does not provide (inadvertent) exception handling around these methods. Suggest revising release notes or remapping these exceptions to some type of RuntimeException.];[well, 5.2 is out as is ...but it would be could to document these changes for the 5.3 release. Care to send a fix for the documentation? Sure, you mean along the lines of a patch for the JavaDocs, or in some other location (changes, readme)? Whereever you would have expected it But changes, readme and javadocs sounds good. BCEL 5.2 is 8 years old, let's focus on the next releases.];
BCEL-84;[BCEL-84] BCEL 5.2 - MethodGen does not initialize max_stack and max_locals properly;Fixed;Resolved;Apache Commons Developers;1151419480000;1155629231000;Bug;[];[];[The constructor for MethodGen: public MethodGen(Method, String, ConstantPoolGen) does not properly initialize the max_stack and max_local variables from the Method object. Thus the following sequence of actions will produce a non-verifying class, even though it clearly shouldn't: ClassGen cg = new ClassGen(javaClass). Method m = cg.getMethodAt(0). MethodGen mg = new MethodGen(m, cg.getClassName(), cg.getConstantPool()). cg.setMethodAt(mg.getMethod(), 0). cg.getJavaClass().dump(...). Bug can be fixed by adding the following the constructor: Code c = m.getCode(). max_stack = c.getMaxStack(). max_locals = c.getMaxLocals().];[Whoops, code confusion with a subclass. Puts on dunce hat and sits in corner for 15 minutes];
BCEL-85;[BCEL-85] ArrayOutOfBoundsException in InstructionFinder;Fixed;Closed;Apache Commons Developers;1152879058000;1173510491000;Bug;[];[];[Using InstructionFinder(String pattern, InstructionHandler handler), if pattern is at the end of instruction list exception occurrs. The bug is in the following method: public final Iterator search( String pattern, InstructionHandle from, CodeConstraint constraint ) int lenExpr = (endExpr - startExpr) + 1. should be int lenExpr = (endExpr - startExpr).];[];
BCEL-86;[BCEL-86] BCEL in revision 426120 doesnt compile due to missing class files;Cannot Reproduce;Resolved;Apache Commons Developers;1154017546000;1173510558000;Bug;[];[];[BCEL in revision 426120 doesnt compile: [javac] Compiling 360 source files to C:\Temp\bcel\build\ant [javac] C:\Temp\bcel\src\main\java\org\apache\bcel\generic\ElementValueGen.java:103: cannot find symbol [javac] symbol : class ClassElementValueGen [javac] location: class org.apache.bcel.generic.ElementValueGen [javac] return new ClassElementValueGen (dis.readUnsignedShort(), cpGen). [javac] ^ [javac] C:\Temp\bcel\src\main\java\org\apache\bcel\generic\ElementValueGen.java:107: cannot find symbol [javac] symbol : class AnnotationElementValueGen [javac] location: class org.apache.bcel.generic.ElementValueGen [javac] return new AnnotationElementValueGen (ANNOTATION, new AnnotationEntryGen(AnnotationEntry.read( [javac] ^ [javac] C:\Temp\bcel\src\main\java\org\apache\bcel\generic\ElementValueGen.java:117: cannot find symbol [javac] symbol : class ArrayElementValueGen [javac] location: class org.apache.bcel.generic.ElementValueGen [javac] return new ArrayElementValueGen(ARRAY, evalues, cpGen). [javac] ^ [javac] Note: Some input files use or override a deprecated API. [javac] Note: Recompile with -Xlint:deprecation for details. [javac] Note: Some input files use unchecked or unsafe operations. [javac] Note: Recompile with -Xlint:unchecked for details. [javac] 3 errors];[try a later version 516724 compiles just fine for me];
BCEL-87;[BCEL-87] Website: Incorrect URL for source version 5.2 is not in the bug page;Fixed;Closed;Apache Commons Developers;1154797622000;1201950531000;Bug;[];[];[1) On the 'download' web page (see URL) source link points to .../bcel/binaries/bcel-5.2-src.zip (note 'binaries'). Thus the link is broken. Source can be found through "browse downloads" 2) Version 5.2 is not in the list on bug submission page Thank you!];[version has been added. will look into the changes file. thanks];
BCEL-88;[BCEL-88] bcelified method doesn't pass verification;Fixed;Closed;Apache Commons Developers;1156936759000;1201950580000;Bug;[BCELifierSampleBean.java];[];[I bclified the following method: public String toString() { return ReflectionToStringBuilder.toString(this). } Which is the standard toString for bean as suggested by the commons-lang project. This code is generated: private void createMethod_7() { InstructionList il = new InstructionList(). MethodGen method = new MethodGen(ACC_PUBLIC, Type.STRING, Type.NO_ARGS, new String[] { }, "toString", "it.imolinfo.iif.webservices.utils.generators.BCELifierSampleBean", il, _cp). InstructionHandle ih_0 = il.append(_factory.createLoad(Type.OBJECT, 0)). il.append(_factory.createInvoke("org.apache.commons.lang.builder.ReflectionToStringBuilder", "toString", Type.STRING, new Type[] { Type.OBJECT } , Constants.INVOKESTATIC)). InstructionHandle ih_4 = il.append(_factory.createReturn(Type.OBJECT)). method.setMaxStack(). method.setMaxLocals(). _cg.addMethod(method.getMethod()). il.dispose(). } I'm reporting only the method that goes in error, in attachement there is the whole class. When I try to run the code and verify the class generated I get the following error: verify failed on step 3b on class: it.imolinfo.iif.webservices.utils.generators.BCELifierSampleBeanon method: toString message: Constraint violated in method 'public String toString()': Instruction INVOKESTATIC constraint violated: Class 'org.apache.commons.lang.builder.ReflectionToStringBuilder' is referenced, but cannot be loaded and resolved: 'VERIFIED_REJECTED Number of LocalVariableTable attributes of Code attribute '<CODE>' (method 'static void <clinit>()') exceeds number of local variable slots '0' ('There may be no more than one LocalVariableTable attribute per local variable in the Code attribute.'). '. InstructionHandle: 1: invokestatic[184](3) 48 Execution Frame: Local Variables: 0: it.imolinfo.iif.webservices.utils.generators.BCELifierSampleBean OperandStack: Slots used: 1 MaxStack: 1. it.imolinfo.iif.webservices.utils.generators.BCELifierSampleBean (Size: 1) Execution flow: 0: aload_0 [InstructionContext] 1: invokestatic 48 [InstructionContext] at it.imolinfo.iif.jbi.BCELClassLoader.verifyClass(BCELClassLoader.java:66) at it.imolinfo.iif.jbi.BCELClassLoader.addClass(BCELClassLoader.java:27) at it.imolinfo.iif.test.webservices.utils.generators.BCELifierSampleBeanCreator.main(BCELifierSampleBeanCreator.java:260) Any idea if this is a bug or how to workaround it? Curiosly the twin method: public boolean equals(Object obj) { return EqualsBuilder.reflectionEquals(this, obj). } is generated passes the verification.];[Attachment BCELifierSampleBean.java has been added with description: the bcelified bean whose toString method gives an error no longer happening with HEAD version thanks for reporting back];
BCEL-89;[BCEL-89] return type not verified by JustIce;Fixed;Closed;Apache Commons Developers;1158918110000;1175856111000;Bug;[Test.class, bcel-verifier-patch.txt];[];[I have found the following very simple class to be accepted by the JustIce verifier (BCEL 5.2) even though it should clearly not. $$$ javap -c Test Compiled from "Test.java" public class Test extends java.lang.Object { public Test(). Code: 0: aload_0 1: invokespecial #9. //Method java/lang/Object."<init>":()V 4: return public java.lang.String foo(java.lang.String, java.lang.Integer). Code: 0: aload_2 1: areturn } In the method "foo", an Integer is returned instead of a String but JustIce does not complain about that. The Sun verifier rejects the class.];[Attachment Test.class has been added with description: the class illustrating the problem care to work out a patch? This class is used to test the happy scenarios public class Test { String ss4. static String ss6. static String ss9. public String getSS() { return getSS1(). } public String getSS1() { return (String)getSS2(). } public Object getSS2() { return getSS3(). } public String getSS3() { return "". } public String getSS4() { return ss4. } public String getSS5() { String ss5 = "". return ss5. } public String getSS6() { return ss6. } public Test getSS7() { return this. } public int getSS8() { return 1. } public String getSS9() { ss9 = "1". return ss6. } public String[] getSS10() { String[] ss10 = new String[1]. ss10[0] = "". return ss10. } } Attachment bcel-verifier-patch.txt has been added with description: basic implementation Thanks! Applied!];
BCEL-90;[BCEL-90] array elements' type not always verified by JustIce;Unresolved;Open;Apache Commons Developers;1164772588000;0;Bug;[Test.class];[];[The following class is accepted by JustIce (BCEL 5.2), whereas Sun verifier (correctly) rejects it: Compiled from "Test.java" public class Test extends java.lang.Object{public Test().  Code:   0:   aload_0   1:   invokespecial   #9. //Method java/lang/Object."<init>":()V   4:   returnpublic static void main(java.lang.String[]).  Code:   0:   aload_0   1:   iconst_0   2:   caload   3:   return} In the "main" method we are trying to read a char from an array of Strings and this is of course type-incorrect. My take on the solution is that in the org.apache.bcel.verifier.structurals.InstConstraintVisitor class, in the visitCALOAD method, there are only two checks being made: whether the index is of int type, and whether there is really an array on the stack. What is missing is the check, whether the array holds element of 'char' type.];[Attachment Test.class has been added with description: the class illustrating the problem];
BCEL-93;[BCEL-93] Broken links in BCEL project changelog;Won't Fix;Resolved;Apache Commons Developers;1170806830000;1331474988000;Bug;[];[];[When I go to the BCEL project changelog, every link I click is broken: http://jakarta.apache.org/bcel/changelog-report.html];[http://svn.apache.org/repos/asf/jakarta/bcel/trunk/jakarta/bcel/branches/BCEL_5_2/KEYS ------------------ should be removed to http://svn.apache.org/repos/asf/jakarta/bcel/branches/BCEL_5_2/KEYS No longer relevant, as far as I can tell, now that BCEL is part of commons];
BCEL-94;[BCEL-94] @since tag incorrect for Annotation classes in BCEL trunk;Fixed;Closed;Apache Commons Developers;1170807045000;1171931675000;Bug;[];[];[The BCEL trunk includes a number of new Annotation classes that were not in the BCEL 5.2 release. For example: http://svn.apache.org/repos/asf/jakarta/bcel/trunk/src/main/java/org/apache/bcel/classfile/ Annotations.java http://svn.apache.org/repos/asf/jakarta/bcel/trunk/src/main/java/org/apache/bcel/classfile/ AnnotationDefault.java http://svn.apache.org/repos/asf/jakarta/bcel/trunk/src/main/java/org/apache/bcel/classfile/ AnnotationElementValue.java etc. etc. Note that the @since JavaDoc for these classes is "5.2". This is incorrect because the classes were not available in version 5.2.];[thanks for the catch. applied to head];
BCEL-95;[BCEL-95] InstructionFactory missing % operator for Float, Double;Fixed;Closed;Apache Commons Developers;1171623180000;1171931382000;Bug;[];[];[The createBinary(Float|Double)Op functions of InstructionFactory are missing the % operator, even though it's valid and has a constant in both cases. Fix is easy: 350a351,352 > case '%': > return FREM. 366a369,370 > case '%': > return DREM.];[Thanks for the fix. Applied to head];
BCEL-96;[BCEL-96] Fields in Annotations and AnnotationEntry are inaccessible to subclasses;Fixed;Closed;Apache Commons Developers;1171932480000;1263122777000;Bug;[protected-fields.patch];[];[I am using the new annotation support in the BCEL trunk to write a utility for processing custom annotations. This required extending the Annotations and AnnotationEntry classes, and the subclasses I created needed to access the fields in the superclasses. Unfortunately, this wasn't possible because these fields have private access. They should instead have protected access.];[Attachment protected-fields.patch has been added with description: Simple patch that makes the private fields protected Just as a general note, protected fields should be used with caution as they have significant implications for binary compatibility. once added they become part of the "public api" of the class and cannot be changed without potentially breaking existing code. Where possible, protected accessor methods are better than allowing direct access to protected fields. Note, however, that I haven't reviewed this patch to determine what the best solution is for this particular case. I think accessor methods might also work in my case, but I would prefer protected members (possibly in addition to accessors) because it offers the most flexibility and control. And yes, field access rights raise compatibility issues, which is why I hope this bug can be resolved before the annotation support in BCEL migrates from the trunk to an official release. In any case, something must be changed, otherwise it will be impossible for users to extend BCEL's annotation support. Could you elaborate why you have to extend them? I need to extend them in order to tell BCEL how to process non-standard annotations. Currently BCEL is hard-coded for the existing annotation names: RuntimeInvisibleAnnotations, RuntimeInvisibleAnnotations, RuntimeInvisibleParameterAnnotations, and RuntimeVisibleParameterAnnotations. However, with the JSR-308 proposal, new annotation names are likely on the way: RuntimeInvisibleTypeAnnotations/RuntimeVisibleTypeAnnotations and (possibly) RuntimeInvisibleStatementAnnotations/RuntimeVisibleStatementAnnotations. Now, I'd like to use BCEL to parse and display these new annotation types. In fact, I've already written such a utility here: http://volta.svn.sourceforge.net/viewvc/volta/util/dump-annotations/ However, the utility can't work with the current BCEL trunk because the Annotations and AnnotationEntry classes have private inaccessible fields. This makes extending those classes in any meaningful way impossible. But if I simply modify BCEL so that those fields are exposed to subclasses, then my utility works perfectly. So, is this patch acceptable for inclusion in the trunk, or does it need more work? Should I rewrite it to use accessor methods instead of protected fields? Can someone please review this patch? It's a very simple fix. If you like, I can submit another one that uses accessor methods instead of protected fields. I found another example of why this bug needs to be fixed: http://forum.java.sun.com/thread.jspa?threadID=775449 Note that Mathias has created two entirely new types of annotations (RuntimeVisibleLocalVariableAnnotations and RuntimeInvisibleLocalVariableAnnotations). Naturally, one might want to use BCEL to read these annotations from a class file, but that's currently impossible. Unless this bug is fixed, BCEL is effectively hard-coded for the standard annotation names. public int getTypeIndex() { return type_index. } public ConstantPool getConstantPool() { return constant_pool. } public boolean isRuntimeVisible() { return isRuntimeVisible. } Expose the variables now. In Annotations they are already available and you can even set the annotation table. Should fix your problems. Please re-open if that's not enough.];
BCEL-97;[BCEL-97] Add support for getResources to ClassPath;Fixed;Closed;Apache Commons Developers;1172580263000;1173511306000;Bug;[getResources.patch];[];[About a year ago we sent a patch that adds getResource and getResourceAsStream to ClassPath. Our custom classloader application now fails when running code that makes use ClassLoader.getResources, so we need corresponding support in BCEL ClassPath. I will attach a patch soon.];[Attachment getResources.patch has been added with description: Add getResources to ClassPath Applied!];
BCEL-98;[BCEL-98] Two source files in repository are empty;Fixed;Closed;Apache Commons Developers;1172885690000;1173511182000;Bug;[];[];[Two source files in the BCEL repository are zero-length: http://svn.apache.org/repos/asf/jakarta/bcel/trunk/src/main/java/org/apache/bcel/generic/ AnnotationGen.java http://svn.apache.org/repos/asf/jakarta/bcel/trunk/src/main/java/org/apache/bcel/generic/ ElementNameValuePairGen.java These files should contain some source code or they should be removed.];[Thanks for the heads up];
BCEL-99;[BCEL-99] Maven POM file calls in apache regex but code does not use it;Fixed;Closed;Apache Commons Developers;1173365746000;1173509297000;Bug;[];[];[Seems the code was modernized to use java.util.regex but the Maven POM file was not updated at the time. A simple SVN patch is here: Index: /home/ian/workspace/bcel/pom.xml =================================================================== — /home/ian/workspace/bcel/pom.xml (revision 516101) +++ /home/ian/workspace/bcel/pom.xml (working copy) @@ -170,11 +170,6 @@ <dependencies> <dependency> <groupId>jakarta-regexp</groupId> <artifactId>jakarta-regexp</artifactId> <version>1.4</version> </dependency> <dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>3.8.1</version> Given that the only external dependency is now junit3.8 which everybody has a copy of, one could switch from Maven to Ant and avoid the dependency on Maven, but that's rather a different story];[Err, whomever commits that should also commit this repair of the relevant comment in o.a.b.util.InstructionFinder: Index: /home/ian/workspace/bcel/src/main/java/org/apache/bcel/util/InstructionFinder.java =================================================================== — /home/ian/workspace/bcel/src/main/java/org/apache/bcel/util/InstructionFinder.java (revision 516101) +++ /home/ian/workspace/bcel/src/main/java/org/apache/bcel/util/InstructionFinder.java (working copy) @@ -1,7 +1,7 @@ /* Copyright 2000-2004 The Apache Software Foundation * * Licensed under the Apache License, Version 2.0 (the "License"). + * Licensed under the Apache License, Version 2.0 (the "License"). you may not use this file except in compliance with the License. You may obtain a copy of the License at * @@ -11,7 +11,7 @@ distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and * limitations under the License. + * limitations under the License. * */ package org.apache.bcel.util. @@ -36,19 +36,19 @@ expressions. This can be used, e.g., in order to implement a peep hole optimizer that looks for code patterns and replaces them with faster equivalents. * + * <p> * This class internally uses the <a href="http://jakarta.apache.org/regexp/"> * Regexp</a> package to search for regular expressions. * + * This class internally uses the java.util.regex + * package to search for regular expressions. + * A typical application would look like this: * + * <pre> * * + * + * InstructionFinder f = new InstructionFinder(il). String pat = "IfInstruction ICONST_0 GOTO ICONST_1 NOP (IFEQ|IFNE)". * + * for(Iterator i = f.search(pat, constraint). i.hasNext(). ) { InstructionHandle[] match = (InstructionHandle[])i.next(). ... Thanks, applied. Please next time attach the patches.];
BCEL-100;[BCEL-100] ClassParser throws unintelligible Exception;Fixed;Closed;Apache Commons Developers;1173366396000;1173509515000;Bug;[];[];[o.a.b.classfile.ClassParser throws two exceptions. One has the file_name variable included but the one that only comes up when you have a corrupted class file does not. When you have thousands and thousands of classes (counting all the classes in dependent jars) in a large project, this can make it very difficult to find the problem! One could in theory argue that the application using BCEL should report this, but the canonical example of a file-related problem is FileNotFoundException which does include the filename, for the same reason as I suggest the exception thrown by ClassParser does. E.g., create new FileReader("/nosuchfile") and you get: Exception in thread "main" java.io.FileNotFoundException: /nosuchfile (No such file or directory) A simple SVN patch against r516101 follows (bigger than it needs to be due to Eclipse's auto-remove-excess-whitespace mode): Index: /home/ian/workspace/bcel/src/main/java/org/apache/bcel/classfile/ClassParser.java =================================================================== — /home/ian/workspace/bcel/src/main/java/org/apache/bcel/classfile/ClassParser.java (revision 516101) +++ /home/ian/workspace/bcel/src/main/java/org/apache/bcel/classfile/ClassParser.java (working copy) @@ -38,7 +38,7 @@ further details about the structure of a bytecode file. * @version $Id$ * @author <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A> + * @author <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A> */ public final class ClassParser { @@ -206,7 +206,8 @@ } if (((access_flags & Constants.ACC_ABSTRACT) != 0) && ((access_flags & Constants.ACC_FINAL) != 0)) { - throw new ClassFormatException("Class can't be both final and abstract"). + throw new ClassFormatException( + "Class " + file_name + " can't be both final and abstract"). } class_name_index = file.readUnsignedShort(). superclass_name_index = file.readUnsignedShort().];[Thanks, applied. Please attach the diff next time.];
BCEL-101;[BCEL-101] verifier raises ....AssertionViolatedException when done against Java5 files with generics/annotations;Fixed;Closed;Apache Commons Developers;1175082491000;1175414141000;Bug;[bcel-patch-verifier.txt];[];[Running the verifier against the class: package org.jpox.samples.jpa.company. import java.util.Collection. import java.util.HashSet. import javax.persistence.Entity. import javax.persistence.Id. @Entity public class GenericsPerson { public String id. Collection<Person> persons = new HashSet<Person>(). @Id public String getId() { return id. } public void setId(String id) { this.id = id. } public void setPersons(Collection<Person> perss) { this.persons = perss. } public Collection<Person> getPersons() { return persons. } } Gives this error output: JustIce by Enver Haase, (C) 2001-2002. <http://bcel.sourceforge.net> <http://jakarta.apache.org/bcel> Now verifying: org.jpox.samples.jpa.company.GenericsPerson Pass 1: VERIFIED_OK Passed verification. Exception in thread "main" org.apache.bcel.verifier.exc.AssertionViolatedException: INTERNAL ERROR: Please adapt 'class org.apache.bcel.verifier.statics.StringRepresentation' to deal with objects of class 'class org.apache.bcel.classfile.RuntimeVisibleAnnotations'. at org.apache.bcel.verifier.statics.StringRepresentation.toString(StringRepresentation.java:98) at org.apache.bcel.verifier.statics.Pass2Verifier.tostring(Pass2Verifier.java:1442) at org.apache.bcel.verifier.statics.Pass2Verifier.access$0(Pass2Verifier.java:1441) at org.apache.bcel.verifier.statics.Pass2Verifier$CPESSC_Visitor.visitJavaClass(Pass2Verifier.java:387) at org.apache.bcel.classfile.JavaClass.accept(JavaClass.java:213) at org.apache.bcel.classfile.DescendingVisitor.visitJavaClass(DescendingVisitor.java:94) at org.apache.bcel.classfile.JavaClass.accept(JavaClass.java:213) at org.apache.bcel.classfile.DescendingVisitor.visit(DescendingVisitor.java:88) at org.apache.bcel.verifier.statics.Pass2Verifier$CPESSC_Visitor.<init>(Pass2Verifier.java:357) at org.apache.bcel.verifier.statics.Pass2Verifier$CPESSC_Visitor.<init>(Pass2Verifier.java:337) at org.apache.bcel.verifier.statics.Pass2Verifier.constant_pool_entries_satisfy_static_constraints(Pass2Verifier.java:298) at org.apache.bcel.verifier.statics.Pass2Verifier.do_verify(Pass2Verifier.java:159) at org.apache.bcel.verifier.PassVerifier.verify(PassVerifier.java:71) at org.apache.bcel.verifier.Verifier.doPass2(Verifier.java:75) at org.apache.bcel.verifier.Verifier.main(Verifier.java:217)];[Attachment bcel-patch-verifier.txt has been added with description: add visitAnnotation and visitLocalVariableTypeTable to StringRepresentation Thanks! Applied!];
BCEL-102;[BCEL-102] Verifier fails in pass 2 with "Number of LocalVariableTable attributes of Code attribute" on static methods.;Fixed;Closed;Apache Commons Developers;1175440290000;1175856280000;Bug;[bcel-verifier-patch.txt];[];[Result Pass 2: Number of LocalVariableTable attributes of Code attribute '<CODE>' (method 'public static String getSS9()') exceeds number of local variable slots '0' ('There may be no more than one LocalVariableTable attribute per local variable in the Code attribute.'). Test code: public class Test { String ss4. static String ss6. static String ss9. public String getSS() { return getSS1(). } public String getSS1() { return (String)getSS2(). } public Object getSS2() { return getSS3(). } public String getSS3() { return "". } public String getSS4() { return ss4. } public String getSS5() { String ss5 = "". return ss5. } public String getSS6() { return ss6. } public Test getSS7() { return this. } public int getSS8() { return 1. } public static String getSS9() { if( true ) { return ss6. } return ss9. } public String[] getSS10() { String[] ss10 = new String[1]. ss10[0] = "". return ss10. } }];[Attachment bcel-verifier-patch.txt has been added with description: patch that ignores "There may be no more than one LocalVariableTable attribute per local variable in the Code attribute" on static methods Thanks! Applied!];
BCEL-103;[BCEL-103] RPM package spec incorrect - won't install properly under anaconda;Invalid;Resolved;Apache Commons Developers;1176919755000;1176920626000;Bug;[];[];[The package spec for bcel does not properly specify an installation prerequisite, which is necessary for its %pre script to run. The package's %pre script requires the "rm" utility which is part of coreutils. The pacakge should have: Requires(pre): coreutils (the Prereq: directive is deprecated and does not function as it used to)];[];
BCEL-105;[BCEL-105] Thread safety + unbuffered writes;Won't Fix;Resolved;Apache Commons Developers;1180547758000;1439504007000;Bug;[bcel.patch.txt];[];[Here's a patch for 5.2 to fix all apparent remaining thread safety issues in BCEL plus a case where unbuffered writes were being done. The thread safety changes use thread locals in the spirit of an earlier partial patch. These changes have been used to eliminate the need to synchronize around BCEL while testing real-world applications using Xalan XSLTC on our platform. Ken McNeil Software Engineer Azul Systems, Inc.];[Attachment bcel.patch.txt has been added with description: Patch Unfortunately the patch does not apply successfully on BCEL trunk. Just got back to this patch. BCEL is never meant to be theadsafe. What am I missing? BCEL is not intended to be thread-safe];
BCEL-107;[BCEL-107] ParameterAnnotationEntries are read not dumped;Fixed;Closed;Apache Commons Developers;1181785336000;1263128809000;Bug;[];[];[Bytecode for methods which contain an Attribute of type RuntimeInvisibleParameterAnnotations or RuntimeVisibleParameterAnnotations is not valid when dumped by BCEL. The Attribute itself seems to be written, but the AnnotationEntries contained in there are not. A test case for this issue would be this class: public class Foo() { public int bar(@javax.jws.WebParam int input) { return input. } Our current solution is to override the dump-Method in org.apache.bcel.classfile.ParameterAnnotations public final void dump(DataOutputStream dos) throws IOException { super.dump(dos). writeAnnotations(dos). } and org.apache.bcel.classfile.ParameterAnnotationEntry public final void dump(DataOutputStream dos) throws IOException { dos.writeShort(annotation_table_length). for (int i = 0. i < annotation_table_length. i++) { annotation_table[i].dump(dos). } }];[would you mind providing a patch against trunk? Fixed.];
BCEL-108;[BCEL-108] RuntimeVisible Annotations duplicated;Fixed;Closed;Apache Commons Developers;1183342447000;1201954538000;Bug;[];[];[Classes containing runtime visible annotations are invalid when processed by BCEL. Example use case: The class to be processed: @javax.persistence.Entity public class Item { } Here the code snippets we are using to process the class: ClassGen classGen = new ClassGen(javaClass). ... // perform changes ... JavaClass result = classGen.getJavaClass(). The result contains now two attributes "RuntimeVisibleAnnotation" which is invalid. Fix for the problem: org.apache.bcel.generic.ClassGen: On line 145 the list of attributes should not be filled with the annoation attributes, as they are appended later anyways. Original code: for (int i = 0. i < attributes.length. i++) { addAttribute(attributes[i]). } Correct code: for (int i = 0. i < attributes.length. i++) { if (!(attributes[i] instanceof Annotations)) { addAttribute(attributes[i]). } }];[];
BCEL-109;[BCEL-109] seregino11@gmail.com;Invalid;Closed;Apache Commons Developers;1186195915000;1186396136000;Bug;[];[];[];[];
BCEL-110;[BCEL-110] Problem with JAXB if the bcel classloader is used;Fixed;Closed;Apache Commons Developers;1186980993000;1666870405000;Bug;[];[];[When I try to run program with a JAXB code I got an exception if the bcel classloader is used. Exception in thread "main" java.lang.LinkageError: Class org/xml/sax/InputSource violates loader constraints at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(Unknown Source) at java.lang.ClassLoader.defineClass(Unknown Source) at org.apache.bcel.util.ClassLoader.loadClass(ClassLoader.java:127) at java.lang.ClassLoader.loadClass(Unknown Source) at java.lang.ClassLoader.loadClassInternal(Unknown Source) at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(Unknown Source) at advdebug.config.parser.impl.runtime.UnmarshallerImpl.unmarshal(UnmarshallerImpl.java:140) at javax.xml.bind.helpers.AbstractUnmarshallerImpl.unmarshal(AbstractUnmarshallerImpl.java:131) at javax.xml.bind.helpers.AbstractUnmarshallerImpl.unmarshal(AbstractUnmarshallerImpl.java:136) at javax.xml.bind.helpers.AbstractUnmarshallerImpl.unmarshal(AbstractUnmarshallerImpl.java:145) at javax.xml.bind.helpers.AbstractUnmarshallerImpl.unmarshal(AbstractUnmarshallerImpl.java:163) at test.Test.main(Test.java:47)];[Can you please provide some testcase or code snippet? The most likely cause for this is because the bcel Classloader does not follow the Java 2 classloader delegation pattern. Depending on the setup, it might use a SyntheticRepository to load the class from the classpath (which also includes the system classes, and org.xml.sax.InputSource is part of them) instead of using the bootstrap classloader to load system classes. Furthermore the bcel ClassLoader does not correctly call definePackage, so clazz.getPackage() might be null and cause problems in some cases. Given that this ClassLoader does not meet current standards, and that there are alternatives, I suggest we remove this class in 6.0 sebb@apache.org, what do you think? I would be happy with that. it will also allow removal of the deprecated method ConstantUtf8.setBytes(String bytes). Furthermore, it's very confusing that ClassLoader extends java.lang.ClassLoader! Fixed by removing the problematic class URL: http://svn.apache.org/r1695788 Log: BCEL-110 Problem with JAXB if the bcel classloader is used Remove the problematic class Removed: commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/util/ClassLoader.java Modified: commons/proper/bcel/trunk/src/changes/changes.xml URL: http://svn.apache.org/r1696127 Log: BCEL-110 Problem with JAXB if the bcel classloader is used. remove the broken ClassLoader class Modified: commons/proper/bcel/trunk/src/examples/ProxyCreator.java URL: http://svn.apache.org/r1696114 Log: BCEL-110 Problem with JAXB if the bcel classloader is used. remove the broken ClassLoader class Modified: commons/proper/bcel/trunk/src/changes/changes.xml commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/util/JavaWrapper.java];
BCEL-111;[BCEL-111] MethodGen.setMaxLocals() calculates too small max locals, which results in a ClassFormatError when loading the modified class;Unresolved;Open;Apache Commons Developers;1189585266000;0;Bug;[Reproducer.java];[];[Revision 574984 (trunk) When a local variable is added to a method, the max_locals are incremented in addLocalVariable (set to slot + size of type). However, when no other transformations are made, and setMaxLocals() is called, the bytecode is searched for the max variable index, and max_locals set to that index + size of that entry. The old max_locals which was set by adding the field is overwritten by this number. If the LocalVariableTable for that method exists, the Java VM won't load the class, because the max_locals determined by bcel is smaller than the max locals determined from the localvariabletable => ClassFormatException.];[Start the Reproducer with java -cp bcel.jar:. Reproducer - the example instrument the constructor of it's own class, adds a field, and tries to load the modified class. Attachment Reproducer.java has been added with description: Example how to reproduce the issue. It's a bug certainly, but because local variable is added to method without actually adding an statements in the method that use the variable, and the setMaxLocals only looks at opcodes. It should probably also look at the localvariable table if it exists, and use that. Actually javac doesn't add entries to the local variable table that you don't use, so perhaps the real fix is to strip unused local variables from the local variable table.];
BCEL-112;[BCEL-112] ARRAYLENGTH incorrectly not StackConsumer;Fixed;Closed;Apache Commons Developers;1189699386000;1201957803000;Bug;[];[];[According to the JVM Instruction Set, ARRAYLENGTH pops a value from the stack and pushes a value to the stack. In BCEL, it only implements StackProducer, so it creates an incorrectly high stack height. The Constants class already has the correct value for it, but since the instruction does not implement StackConsumer it is never used. The easiest solution is to change src\java\src\java\org\apache\bcel\generic\ARRAYLENGTH.java to implement StackConsumer. This will fix the bug. I didn't attach a patch for this because the change is so tiny.];[Thanks! Applied ...please cross check];
BCEL-113;[BCEL-113] AnnotationDefault needs a dump method;Fixed;Closed;Apache Commons Developers;1190992984000;1666870406000;Bug;[];[];[While using bcel to read in and then write out an annotation that has a default value without making any changes to it, I discovered that the resulting class did not contain the annotation default. The annotation looks something like this: @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface Foo { String name() default "". } The missing bytes caused a (very misleading) NoClassDefFoundError when I tried to load the new class. When I tried to decompile the new class, I got this error: ItemCollectionInvalidIndex: constants: requested 1280, limit 27 After comparing the original class with the new class in a hex editor, I determined that the bytes for the AnnotationDefault were missing. The problem is that the AnnotationDefault class does not have a dump method. I added a dump method and this fixed the problem. Here's a diff of the new method: $ svn diff Index: src/main/java/org/apache/bcel/classfile/AnnotationDefault.java =================================================================== — src/main/java/org/apache/bcel/classfile/AnnotationDefault.java (revision 573325) +++ src/main/java/org/apache/bcel/classfile/AnnotationDefault.java (working copy) @@ -18,6 +18,7 @@ import java.io.DataInputStream. import java.io.IOException. +import java.io.DataOutputStream. import org.apache.bcel.Constants. /** @@ -105,4 +106,10 @@ { throw new RuntimeException("Not implemented yet!"). } + + public final void dump(DataOutputStream dos) throws IOException + { + super.dump(dos). + default_value.dump(dos). + } }];[Thanks, applied to trunk];
BCEL-114;[BCEL-114] Error in method search() defined in org.apache.bcel.util.InstructionFinder;Fixed;Closed;Apache Commons Developers;1193704857000;1201954984000;Bug;[ErrorUseCase.rar];[];[While Peephole.java is a small program in the manual to remove “NOP” instructions in any class file, it uses the method search() defined in org.apache.bcel.util.InstructionFinder with string pattern ‘NOP+’ to locate the “NOP” instructions in the instructionList. After several tests, I found the search() method will always find one more instruction after the expected instructions, what’s more, it will raise a java.lang.ArrayIndexOutOfBoundsException if the expected instruction is at the end of the method. After reading the source-code of org.apache.bcel.util.InstructionFinder, I found there is something wrong when we calculate the length of the match[] array. In the codes of how to get the match[] array. The startExpr is the first index of the ”NOP” instruction, and the endExpr is the first index of the non-NOP instruction. So the real length of the match[] should be endExpr-startExpr. But we use endExpr-startExpr+1 as the length of the array. So instead of getting the expected match[] array, we’ll get an one-instruction-longer match[] in the instructionList incorrectly. As a result, I guess if the statement “int lenExpr = (endExpr - startExpr) + 1.” should be replaced by “int lenExpr =endExpr - startExpr.”.];[Attachment ErrorUseCase.rar has been added with description: Desribe of the Bug, and two example to show the bug Please verify];
BCEL-115;[BCEL-115] Deleting all instructions of a list shows wrong behaviour;Fixed;Closed;Apache Commons Developers;1194248240000;1194433011000;Bug;[];[];[Deleting all instructions (i.e. everything from start to end) in a list shows the following behaviour: The length of the list is not 0 afterwards. Only the handle of the first instruction is disposed. To fix the problem, apply the following patch: Index: InstructionList.java =================================================================== — InstructionList.java (revision 592025) +++ InstructionList.java (working copy) @@ -677,8 +677,9 @@ private void remove( InstructionHandle prev, InstructionHandle next ) throws TargetLostException { InstructionHandle first, last. // First and last deleted instruction if ((prev == null) && (next == null)) { // singleton list first = last = start. + if ((prev == null) && (next == null)) { + first = start. + last = end. start = end = null. } else { if (prev == null) { // At start of list];[Thanks, applied to trunk.];
BCEL-117;[BCEL-117] Problems with LVTT;Unresolved;Open;Apache Commons Developers;1197723586000;0;Bug;[];[];[The fix of 39695 was wrong . Local Variable Type Table does not appears in generated method . Additionally , Local Variable Table now contains only entries with generic types Even though the .class file is now in correct format and does not cause ClassFormatError , information is missing , meaning that it will be imposible to debug in some cases .];[Do you think you could provide a patch for it? Just committed a fix in that area. Would be great if you could re-test.];
BCEL-118;[BCEL-118] Type of 'this' on instantiation of MethodGen from existing Method;Unresolved;In Progress;Apache Commons Developers;1200043643000;0;Bug;[];[];[I have an issue when instantiating a MethodGen from an existing (non-static) method instance. I'm trying to copy a (non-static) method from one class to another class using BCEL. Specifically, I do: MethodGen newMethodGen = new MethodGen(originalMethod.getBCELMethod(), newClassGen.getClassName(), newClassGen.getConstantPool()). This works nicely except for one issue. the 'this' variable in the local variable table points to the entry in the CP representing the type of the originating class, and not the type of the class in which it is inserted in. I traced a bit in the BCEL code, and found that to start with during the instantiation process of the MethodGen class (in the constructor), the 'this' variable in the local variable table indeed points to the correct entry in the CP representing the type of the new class .. However, it appears that after the initial instantiation, the attributes of the provided originating method overrides the local variable table. Specifically, in the constructor (the lines 213-229) the local variable table is deleted, and instead the local variable table of the provided original method is copied over. From the documentation I cannot tell if this is by design, but it does appear to be a bit confusing. specifically, one can put a method into one class, but the 'this' variable points to another class. If this is by design, I would propose some exception throwing if the provided name of the class differs from class used in the local variable table. Now we're at it .. invoking setClassName() on a MethodGen instance does also not make any changes to the local variable table – again making it possible to have this inconsistency.];[];
BCEL-120;[BCEL-120] Make BCEL JAR OSGi compatible;Fixed;Closed;Apache Commons Developers;1202213905000;1202222642000;Bug;[bcelosgi.patch];[];[Adding some entries to the MANIFEST.MF file will allow BCEL to be refered transparently in OSGi environment];[Attachment bcelosgi.patch has been added with description: pom.xml and manifest.mf file I assume the plugin should have been listed in the build section - not the reporting section. Added. Thanks!];
BCEL-121;[BCEL-121] Calculation in LocalVariableTable.getLocalVariable is incorrect;Fixed;Closed;Apache Commons Developers;1206714630000;1666870405000;Bug;[patch.txt];[];[The calculation in LocalVariableTable.getLocalVariable is incorrect: public final LocalVariable getLocalVariable( int index, int pc ) { for (int i = 0. i < local_variable_table_length. i++) { if (local_variable_table[i].getIndex() == index) { int start_pc = local_variable_table[i].getStartPC(). int end_pc = start_pc + local_variable_table[i].getLength(). if ((pc >= start_pc) && (pc < end_pc)) { return local_variable_table[i]. } } } return null. } From the VM spec: "The given local variable must have a value at indices into the code array in the interval [start_pc, start_pc+length], that is, between start_pc and start_pc+length inclusive. The value of start_pc must be a valid index into the code array of this Code attribute and must be the index of the opcode of an instruction. Either the value of start_pc+length must be a valid index into the code array of this Code attribute and be the index of the opcode of an instruction, or it must be the first index beyond the end of that code array." The check should be pc <= end_pc, not pc < end_pc. This problem exists both in HEAD and in older versions. I've attached a patch.];[Attachment patch.txt has been added with description: Patch to fix bug Patch applied. Thanks!];
BCEL-122;[BCEL-122] ArrayIndexOutOfBoundsException thrown from TABLESWITCH.initFromFile;Fixed;Closed;Apache Commons Developers;1209128434000;1263130071000;Bug;[patch];[];[BCEL throws the ArrayIndexOutOfBoundsException when trying to construct a new org.apache.bcel.generic.MethodGen on a method containing the bytes compiled from the following code: switch { case Integer.MAX_VALUE: break. default: b = true. } The method that does not handle this corner case correctly is org.apache.bcel.generic.TABLESWITCH.initFromFile(ByteSequence, boolean).];[Attachment patch has been added with description: Proposed patch Could you please provide the exception or describe the corner case. It's not exactly obvious why your patch fixes this problem. Sorry about that, I was in a bit of a rush. The corner case is if the low and high values (signed ints) are the same and their value is 0x7fffffff (Integer.MAX_VALUE). This occurs only if there is one case (aside from the default) in the switch and it happens to be MAX_VALUE. Here's the code in BCEL that causes the problem: for (int i = low. i <= high. i++) { match[i - low] = i. //ArrayIndexOutOfBoundsException thrown here } The loop boundaries are the problem. 'i' is initialized to MAX_VALUE, then match[0] is set correctly to MAX_VALUE, i is incremented causing overflow, since i is still <= MAX_VALUE the loop continues. Then on the next time through the loop (i - low) == (0x80000000 - 0x7fffffff) == 1, but match[1] is invalid because it was initialized to have only 1 element by "match_length = high - low + 1" and "match = new int[match_length]". As you can see, my patch resolves this corner case and has the added benefit of eliminating an extra for loop. By the way, the actual exception that finally bubbles up isn't too helpful because the ArrayIndexOutOfBoundsException gets converted into a ClassGenException without having the whole ArrayIndexOutOfBoundsException wrapped. Anyway, for the sake of being complete, it looks like this: org.apache.bcel.generic.ClassGenException: java.lang.ArrayIndexOutOfBoundsException: 1 at org.apache.bcel.generic.Instruction.readInstruction(Instruction.java:177) at org.apache.bcel.generic.InstructionList.<init>(InstructionList.java:167) at org.apache.bcel.generic.MethodGen.<init>(MethodGen.java:164) at ... Fixed. Thx.];
BCEL-123;[BCEL-123] MethodGen: LocalVariableTableGen issues;Unresolved;Open;Apache Commons Developers;1213622040000;0;Bug;[];[];[];[MethodGen mistakenly fills in LocalVariableTableGen from both LocalVariableTable and LocalVariableTypeTable. In parsing LocalVariableTypeTable, it incorrectly reads the signatures with generics. As a result, the LocalVariableTable is corrupted. Here is an example: public class VariableTableBug{   public String getFirstItem( final List< String > list )   {      int index = 0.      String result = list.get( index ).      return result.   }   public static void main( final String[] args ) throws Exception   {      // find the resource that is our class      Class< VariableTableBug > clazz = VariableTableBug.class.      String resource = clazz.getName().replace( '.', '/' ) + ".class".            // load it using BCEL      JavaClass javaClass = new ClassParser( clazz.getClassLoader().getResourceAsStream( resource ),                                             resource ).parse().            // convert everything to a ClassGen      ClassGen classGen = new ClassGen( javaClass ).            // find them getFirstItem method      Method getFirstItemMethod = null.      for ( Method method : classGen.getMethods() )      {         if ( method.getName().equals( "getFirstItem" ) )         {            getFirstItemMethod = method.            break.         }      }            // dump the LocalVariableTable attribute      System.out.println( "LocalVariableTable of original" ).      System.out.println( "------------------------------" ).      for ( LocalVariable localVariable : getFirstItemMethod.getLocalVariableTable().getLocalVariableTable() )      {         System.out.println( localVariable.getName() + "\t" + localVariable.getIndex() + "\t" + localVariable.getSignature() ).      }      System.out.println().      // dump the LocalVariableTypeTable attribute      for ( Attribute attribute : getFirstItemMethod.getCode().getAttributes() )      {         if ( attribute instanceof LocalVariableTypeTable )         {            System.out.println( "LocalVariableTypeTable of original" ).            System.out.println( "----------------------------------" ).            for ( LocalVariable localVariable : ( (LocalVariableTypeTable) attribute ).getLocalVariableTypeTable() )            {               System.out.println( localVariable.getName() + "\t" + localVariable.getIndex() + "\t" + localVariable.getSignature() ).            }         }      }      System.out.println().            // now convert to a MethodGen      MethodGen methodGen = new MethodGen( getFirstItemMethod,                                           classGen.getClassName(),                                           classGen.getConstantPool() ).            // dump the LocalVariableTable      System.out.println( "LocalVariableTable of MethodGen" ).      System.out.println( "-------------------------------" ).      for ( LocalVariableGen localVariableGen : methodGen.getLocalVariables() )      {         System.out.println( localVariableGen.getName() + "\t" + localVariableGen.getIndex() + "\t" + localVariableGen.getType() ).      }   }   } The issue is here, AFAICT, in the constructor of MethodGen: ... } else if (a instanceof LocalVariableTable) { LocalVariable[] lv = ((LocalVariableTable) a).getLocalVariableTable(). removeLocalVariables(). // [snip] } else if (a instanceof LocalVariableTypeTable) { LocalVariable[] lv = ((LocalVariableTypeTable) a).getLocalVariableTypeTable(). removeLocalVariables(). ... It fills in the local variables from the LocalVariableTypeTable as well, but removes the variables declared in LocalVariableTable. Since the LocalVariableTypeTable only includes variables with generics (or so it seems that Eclipse's compiler does that), the other variables are removed. It should be fairly safe to remove that 'removeLocalVariables()' call. The other part of the issue is Type.getType(String) not parsing the generic types correctly. I'm not sure what the best thing to do is there, though.];
BCEL-124;[BCEL-124] tableswitch/lookupswitch invalid alignment of 4-byte operands;Fixed;Closed;Apache Commons Developers;1213802611000;1263129750000;Bug;[SetPositionsBug.java, bug45230.patch];[];[It is possible, with BCEL, to generate invalid alignment of the 4-byte operands of the Select instructions. The problem is caused by the interaction of InstructionList.setPositions, the updatePosition methods of GOTO and JSR, and Select.updatePosition. In particular, the updatePosition methods of GOTO and JSR will always return the difference between the wide instruction length and the normal instruction length. Since this value ends up being added into the additional_bytes variable in InstructionList.setPositions and then eventually contributes to the value passed into Select.updatePosition as the offset, its incorrect value causes the padding field to be set incorrectly. It appears that in order to behave properly, the updatePosition method should return only the number of bytes of length that the instruction changed during this call to updatePosition. I am attaching a small example application that displays the bug. I will also be attaching a patch.];[Attachment SetPositionsBug.java has been added with description: Testcase: sample application that reproduces the bug Attachment bug45230.patch has been added with description: patch for GOTO and JSR Thx. Applied.];
BCEL-125;[BCEL-125] Incorrect size calculation in InstructionFinder;Fixed;Closed;Apache Commons Developers;1216543731000;1263129256000;Bug;[];[];[In InstructionFinder class, line 229 size of the matched pattern is calculated as int lenExpr = (endExpr - startExpr) + 1. this is incorrect as endExpr is always given as one past the last index and this function causes the iterator being returned to always have one more instruction then requested. Also this can cause a crash if the pattern requested is at the end of a search list as index goes out of bounds. suggested fix (I have it working locally with no problems): int lenExpr = (endExpr - startExpr).];[Already fixed.];
BCEL-126;[BCEL-126] org.apache.bcel.classfile.ClassFormatException;Won't Fix;Resolved;Apache Commons Developers;1222405789000;1270300763000;Bug;[];[];[During Deploying of our application in the application server (OC4J of Oracle) we are getting some exception, while the application is getting deployed without any issue. Below is the stack trace for the same. At the first instance I feel like some concurrent issue in bcel happening for the applications on application server. It could be that current version of bcel (5.1) I am using is not thread safe. I am not sure whether this is already an identified bug, if so please let me know in which version of bcel, is this fixed? java.lang.InstantiationException: org.apache.bcel.classfile.ClassFormatException: Invalid method signature: (ILoracle/sql/STR UCT.)V at oracle.j2ee.connector.proxy.BCELProxyFactory.createProxy(BCELProxyFactory.java:382) at oracle.j2ee.connector.proxy.BCELProxyFactory.getProxy(BCELProxyFactory.java:141) at oracle.oc4j.sql.proxy.SQLBCELProxyFactory.getProxy(SQLBCELProxyFactory.java:47) at oracle.j2ee.connector.proxy.AbstractProxy.oc4j_getProxyForReturnedObject(AbstractProxy.java:105) at oracle_jdbc_driver_T4CConnection_Proxy.prepareCall() at com.hubinterface.helper.DbHelper.isSwitchOn(DbHelper.java:440) at com.hubinterface.helper.DbHelper.sendToDatabaseEoi(DbHelper.java:486) at com.hubinterface.helper.SubmitOrderAction.processRequest_EOI(SubmitOrderAction.java:478) at com.hubinterface.mq.MQMessageListener.run(MQMessageListener.java:29) at java.lang.Thread.run(Unknown Source) Caused by: org.apache.bcel.classfile.ClassFormatException: Invalid method signature: (ILoracle/sql/STRUCT.)V at org.apache.bcel.generic.Type.getArgumentTypes(Type.java:224) at oracle.oc4j.sql.proxy.SQLBCELProxyBuilder.buildMethod(SQLBCELProxyBuilder.java:171) at oracle.j2ee.connector.proxy.BCELProxyFactory.addInterfaceMethods(BCELProxyFactory.java:550) at oracle.j2ee.connector.proxy.BCELProxyFactory.addMethods(BCELProxyFactory.java:522) at oracle.j2ee.connector.proxy.BCELProxyFactory.createProxy(BCELProxyFactory.java:370) ... 9 more Also sometimes when some concurrent requests are coming into our application which is deployed on OC4J Application server, at some point in the code the following exception is happening 2008-09-24 05:00:45,386|ERROR|sendToDatabaseSuspendResumeEoi Database error when placing order: org.apache.bcel.classfile.ClassFormatException: Invalid method signature: ava/lang/String.Ljava/lang/String.)V 2008-09-24 05:00:45,402|ERROR|processRequest_EOI Problem accessing R1OSS: Database error when placing order (java.sql.SQLExce ption: org.apache.bcel.classfile.ClassFormatException: Invalid method signature: ava/lang/String.Ljava/lang/String.)V) 2008-09-24 05:00:45,402|ERROR|processRequest_EOI Problem accessing R1OSS calling dbvalidateexceptions api: Database error whe n placing order (java.sql.SQLException: org.apache.bcel.classfile.ClassFormatException: Invalid method signature: ava/lang/St ring.Ljava/lang/String.)V)];[BCEL is not perported to be thread safe, it's up to you to enforce that. Could you please suggest how to make BCEL to be thread safe, directly in our application, we are not using anywhere the BCEL related stuff. Internally I suppose these classes would be called. Could you please suggest where exactly we can fix this issue. I would think you would need to add synchronization in the method com.hubinterface.helper.DbHelper.sendToDatabaseEoi and other methods/classes that also use oracle.j2ee.connector.proxy.AbstractProxy Or you could file a bug with oracle if you believe oracle should be providing this synchronization. I'm not familiar with OC4J to be of help in this regard. Having said all that, i'm going on your assertion that it is a synchronization issue. I'm not convinced that is the case. It seems odd to me that it says the signature in question is (ILoracle/sql/STR UCT.)V Perhaps this is just a forum post issue, but that signature should not be split over two lines, and must be (ILoracle/sql/STRUCT.)V If you are seeing the two lines as well in your logs, i'd think that is more likely your problem. Yes, as you said it's copy paste error in the forum post. Actually the error came as you pointed out (ILoracle/sql/STRUCT.)V I will try having the Synchronized method and I will post same issue to Oracle OC4J community as well. Thanks for the help. Workaround for oc4j is to use a native-data-source which is documented at http://www.oracle.com/technology/tech/java/oc4j/1013/how_to/how-to-datasource/doc/how-to-datasource.html I used factory-class="oracle.jdbc.pool.OracleDataSource"];
BCEL-127;[BCEL-127] Document that Instruction Factory returns singleton instances;Fixed;Closed;Apache Commons Developers;1227237279000;1666870405000;Bug;[];[];[The implementation of the creation of some instructions e.g. DUPs / NOPs is really misleading. If you create an invokeinstruction or an constant like ldc a new instruction object is created. Pretty straight forward! But if you create a DUP instruction you always will get the same object back. This is of course is great for saving memory, but in the following example it leads to lots of problems. Imagine you instrument a code sequence and add your own instructions one after the other. You add invokestatic instructionsbut also the dups. At the end you iterate again over the whole list to add some missing instructions ( doing it in the first iteration is not possible or too much work, due to the semantics of the algorithm). If you add new instructions again it will not work properly if your insertion point is a DUP! The new instruction will be inserted at the first match of the list. e.g. i1,... are instructions other than dup, dup_ are DUP instructions created with InstructionFactory.createDUP(). you iterate from i1 to i6. init: i1, i2, i3, dup_1, i4, i5, dup_2, i6 1.) insert(i3, new_i) result: i1, i2, new_i, i3, dup_1, i4, i5, dup_2, i6 2.) insert(dup_1, new_i2) result: i1, i2, new_i, i3, new_i2, dup_1, i4, i5, dup_2, i6 3.) insert(dup_2, new_i3) result: i1, i2, new_i, i3, new_i2, new_i3, dup_1, i4, i5, dup_2, i6 The reason for this is that dup_1 dup_2 point to the same static DUP instance (there is always one). Your call to insert() calls a method findInstruction() and this method only compares references (==) and returns the first match. Even if you use copy() you get the same reference! To omit this problem you have to create an instance without the factory by using a constructor. My point is, you can implement it this way BUT you have to mention this in the API doc that this createDUP method does not behave like a createInvoke method and always returns the same reference. I know usually the code is the documentation but I think a lot of pain could be spared with a tiny little sentence in the doc. My suggestions for the doc of those methods: "Returns always a static reference. Note: may cause issues when used as insertion points" or something like that];[URL: http://svn.apache.org/r1696765 Log: BCEL-127 Document that Instruction Factory returns singleton instances Modified: commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/InstructionFactory.java URL: http://svn.apache.org/r1696766 Log: BCEL-127 Document that Instruction Factory returns singleton instances Modified: commons/proper/bcel/trunk/src/changes/changes.xml];
BCEL-129;[BCEL-129] ClassFormatException when instrumenting a Java 5 class;Fixed;Resolved;Apache Commons Developers;1234862569000;1425757432000;Bug;[];[];[Hi , I am using BCEL to instrument Java classes of web applications in JDK1.6 ,1.5 .We encountered a ClassFormat exception for classes using Generics which prevented application from loading.From https://issues.apache.org/bugzilla/show_bug.cgi?id=33549 I saw a workaround to delete "LocalVariableTypeTable". I followed that suggestion and loop through the attributes and deleted attribute named "LocalVariableTypeTable". Still while loading the application I get a ClassFormatException. Example code in which I delete attribute "LocalvariableTypeTable" jc is JavaClass Object         Method[] ma = jc.getMethods().        for(int i = 0, x = ma.length. i < x. i++) {            try {                MethodGen mg = new MethodGen(ma[i],cg.getClassName(),cg.getConstantPool()).                Attribute[] atts = mg.getCodeAttributes().                                for (int j = 0. j < atts.length. j++) {                    if (atts[j].getNameIndex() == mg.getConstantPool().lookupUtf8("LocalVariableTypeTable")) {                        mg.removeCodeAttribute(atts[j]).                    }                }            } catch(Exception o1) {                output.write("exception " + o1).               }        } Also I get other error Caused by: java.lang.ClassFormatError: LVTT entry for 'patterns' in class file org/springframework/classname does not match any LVT entry and the application fails to load];[Any update on this .We require this problem Solved ASAP Please re-test against trunk. No resposnse to request to re-test against trunk and no test case provided to enable someone else to test it. I am therefore going to assume that this was fixed long ago. If that isn.t the case and you still see this issue on trunk, please feel free to re-open and provide a test case.];
BCEL-130;[BCEL-130] Class files containing "ParameterAnnotations" are dumped incorrectly;Fixed;Closed;Apache Commons Developers;1240365098000;1263127689000;Bug;[svn-diff];[];[A JavaClass containing methods with annotated parameters is dumped incorrectly. The content of such annotation attributes is not dumped, ParameterAnnotationEntry.dump(DataOutputStream dos) ParameterAnnotations.dump(DataOutputStream dos) were not implemented. I propose the implementation in the attached diff. It works for my examples. Regards, Mattias];[Attachment svn-diff has been added with description: proposed patch to fix this issue Thx. Applied.];
BCEL-131;[BCEL-131] Class files containing "StackMapTable" attributes (on method code) are dumped incorrectly;Fixed;Closed;Apache Commons Developers;1240381487000;1263127314000;Bug;[patch, svn-diff, svn-diff];[];[When dumping an (untouched) class file containing a StackMap table, the result is not faithful and cannot be be reloaded afterwards. The problem, I reckon, is within the method StackMapTableEntry.dump. One case raises an exception though it should not and other cases write byte values though short values should be written instead. The attached diff fixed the problem for my purposes, but I do not know whether it is correct. Regards, Mattias];[Attachment svn-diff has been added with description: proposed patch to possibly fix this issue I think I'm hitting this same problem (processing jdk1.6-generated class files). I applied your patch, but it does not make any changes to StackMapTableEntry.dump() where the exception is being raised. I assume there should be an if (frame_type >= Constants.SAME_FRAME && frame_type <= Constants.SAME_FRAME_MAX) { ... } else .... after the initial write of frame_type, but what should be inside the if? Actually, it looks like you incorrectly attached the same patch as for BCEL-130 – can you please attach the patch relevant to this bug? Ooops. You are right. I attached the wrong file. I hope that this patch is the right one. Regards, Mattias Attachment svn-diff has been added with description: proposed patch to possibly fix this issue (2nd try) > I assume there should be an > > if (frame_type >= Constants.SAME_FRAME && frame_type <= > Constants.SAME_FRAME_MAX) { > ... > } else .... > after the initial write of frame_type, but what should be inside the if? I reckon that the "if" branch can remain empty since there is no additional information to be stored in this case. Finally had a chance to get back to this. This patch and your other patch are now allowing me to process annotations in my project. Thanks! Damn, so close. It works with some classes, but BCEL-svn seems to die processing other classes with e.g.: Exception in thread "main" java.lang.ClassFormatError: Illegal constant pool index 29440 for method name in class file MyTestClass Probably unrelated to this bug though, as I have not yet got to putting annotations on that class. (In reply to comment #6) > Damn, so close. It works with some classes, but BCEL-svn seems to die > processing other classes with e.g.: > > Exception in thread "main" java.lang.ClassFormatError: Illegal constant pool > index 29440 for method name in class file MyTestClass > > Probably unrelated to this bug though, as I have not yet got to putting > annotations on that class. Hello, the same applies for me. I encountered the problem in this bug report, applied the patch (with some handwork, because the HEAD (826342) revision is a bit different) but I had to stop again in the same exception as yours. Only the index changes, mine is 64764. Best regards, Enrico There was write() instead writeShort() that I had missed in the last patch. Attachment patch has been added with description: Proposed patch Hello! In addition to the here report bugs, I assume very much that all those "readShort" method calls should actually read "readUnsignedShort" since negative values would not make sense there ... 5.2 does not allow to modify classes that have stack maps and save them, since the dumping is very likely to crash. (Hope the patch NOW solves the issue) (In reply to comment #8) > Created an attachment (id=24557) [details] > Proposed patch > > There was write() instead writeShort() that I had missed in the last patch. Dear Mattias, I tried to apply the patch, but it expects a different hunk. Even if I try to patch manually, I still get "Attribute name has bad constant pool index" errors. BTW, the patch refers to revision 881793, but in SVN the most recent revision for this file is currently 826333. Is this patch coming from the future? Best regards, Enrico Hi! Do you have changed anything in the classes that fail to be read? If you - for instance - add instructions to the code block and modify the constant pool with that, the stack map table is not updated like the line number table is. The dumping might then export invalid constants (perhaps). Could you possibly post an example of a corrupted file (pre- and post-processing)? Regards, Mattia Forgive me for the false alarm: I did some mistakes while applying the patch and therefore I got those errors again. I've retried now, and it works like a charm. THANK YOU!! BTW, the difficulties I had in applying the patch were only due to differences in the whitespace. Best regards Applied. Thx!];
BCEL-132;[BCEL-132] org.apache.bcel.classfile.ClassParser: NullPointerException caused by fileopen failed;Fixed;Closed;Apache Commons Developers;1242992162000;1242995445000;Bug;[];[];[If line 119 - 127 of ClassParser.java fails (throws an Exception), the finally is executed. However, fileOwned is true and file is null. It causes NullPointerException. FIX: line 165: file.close(). replace by: if(file != null) { file.close(). }];[it appears that this fix already exists on trunk.];
BCEL-133;[BCEL-133] org.apache.bcel.classfile.ClassParser: NullPointerException caused by invalid filename;Fixed;Closed;Apache Commons Developers;1242992482000;1263125505000;Bug;[];[];[121: ZipEntry entry = zip.getEntry(file_name). Problem: if file_name is invalid, zip.getEntry(file_name) returns null. It causes NullPointerException: 122: file = new DataInputStream(new BufferedInputStream(zip.getInputStream(entry), BUFSIZE)). // zip.getInputStream(entry) throws NullPointerException because entry is null! Note that you will probably see another NullPointerException if #47248 is not corrected.];[Try to insert after 121 code like this: if(entry == null) { throw new IOException("File "+file_name+" not found"). } Thx!];
BCEL-134;[BCEL-134] ExecutionVisitor doesn't support Class constant type for LDC and LDC_W;Fixed;Closed;Apache Commons Developers;1253847165000;1263125896000;Bug;[ExecutionVisitor-2.diff, ExecutionVisitor.diff];[];[Methods visitLDC() and visitLDC_W() push no values in the stack frame when the constant type is a class literal, as can happen with Java 1.5 bytecode. This leads to a false stack underflow exception happening to a subsequent instruction: java.lang.ArrayIndexOutOfBoundsException: -1 at java.util.ArrayList.remove(ArrayList.java:390) at org.apache.bcel.verifier.structurals.OperandStack.pop(OperandStack.java:135) at org.apache.bcel.verifier.structurals.ExecutionVisitor.visitPUTFIELD(ExecutionVisitor.java:1059) at org.apache.bcel.generic.PUTFIELD.accept(PUTFIELD.java:78) Moreover, it would be desired to throw an exception when an unknown constant type is encountered, rather than doing nothing at all. This bug arises while running JiST/SWANS, a network simulator that relies on rewriting Java bytecode to implement simulation time. To be more specific, it arises when running the example UDP test application, launching jist.runtime.Main with arguments "jist.swans.Main driver.udp". I've attached a possible patch against its HEAD revision (411573). Enrico];[Attachment ExecutionVisitor.diff has been added with description: ExecutionVisitor patch (In reply to comment #0) > Moreover, it would be desired to throw an exception when an unknown constant > type is encountered, rather than doing nothing at all. I've just read the Javadoc of ExecutionVisitor, that states that it doesn't check for correct types on the OperandStack. Therefore I remove the checks and just add the class literal constant. Sorry for the inconvenience. Enrico Attachment ExecutionVisitor-2.diff has been added with description: ExecutionVisitor patch (updated) Thx! Applied.];
BCEL-135;[BCEL-135] BCELifier issue: BCELFactory fails to handle float and long constants;Fixed;Closed;Apache Commons Developers;1258341980000;1258352322000;Bug;[TestIncorrectLiterals.java, TestOutOfRangeLiterals.java];[];[BCELifier calls BCELFactory. The BCELFactory.createConstant method does not handle floats and longs correctly: private void createConstant( Object value ) { String embed = value.toString(). if (value instanceof String) { embed = '"' + Utility.convertString(embed) + '"'. } else if (value instanceof Character) { embed = "(char)0x" + Integer.toHexString(((Character) value).charValue()). } _out.println("il.append(new PUSH(_cp, " + embed + "))."). } Note that the types String and char are handled separately. As for the other types, it's relying on there being an overloaded constructor of PUSH that takes the constant in its correct form once it is converted to a String. Let's examine all the other types: - boolean: Boolean.toString() produces the values "true" and "false", which javac picks up as booleans, e.g. "new PUSH(_cp, false)". - byte, short, int: Integer.toString() produces valid values. In the bytecode, there is no (significant) distinction between these types (except for method signatures, fields, etc.). - double: Double.toString() produces valid values, e.g. "new PUSH(_cp, 0.0)". - float: Float.toString() produces values that look like doubles, e.g. "new PUSH(_cp, 0.0)". These are mishandled. - long: Long.toString() produces values that look like ints, e.g. "new PUSH(_cp, 0)", or, even worse, "new PUSH(_cp, 4000000000)" (which doesn't compile). I've attached two simple test cases that illustrate the issues. Do the following with BCEL-5.2.jar on your classpath: % javac TestIncorrectLiterals.java % java TestIncorrectLiterals % java org.apache.bcel.util.BCELifier TestIncorrectLiterals >TestIncorrectLiteralsCreator.java % javac TestIncorrectLiteralsCreator.java % java TestIncorrectLiteralsCreator % java TestIncorrectLiterals Exception in thread "main" java.lang.VerifyError: (class: TestIncorrectLiterals, method: main signature: ([Ljava/lang/String.)V) Expecting to find float on stack % javac TestOutOfRangeLiterals.java % java TestOutOfRangeLiterals % java org.apache.bcel.util.BCELifier TestOutOfRangeLiterals >TestOutOfRangeLiteralsCreator.java % javac TestOutOfRangeLiteralsCreator.java TestOutOfRangeLiteralsCreator.java:41: integer number too large: 4000000000 InstructionHandle ih_0 = il.append(new PUSH(_cp, 4000000000)). ^ 1 error Here's my suggested fix: private void createConstant( Object value ) { String embed = value.toString(). if (value instanceof String) { embed = '"' + Utility.convertString(embed) + '"'. } else if (value instanceof Character) { embed = "(char)0x" + Integer.toHexString(((Character) value).charValue()). } else if (value instanceof Float) { embed += "f". } else if (value instanceof Long) { embed += "L". } _out.println("il.append(new PUSH(_cp, " + embed + "))."). } I shall test out this fix, and report back. This issue seems to exist in the SVN trunk code too.];[Attachment TestIncorrectLiterals.java has been added with description: Test to demonstrate issues with float and long literals Attachment TestOutOfRangeLiterals.java has been added with description: Test to demonstrate issue with big long values. applied patch - thanks.];
BCEL-136;[BCEL-136] Invalid stack map table tag & bad constant pool index with Java 1.6 bytecode;Duplicate;Resolved;Apache Commons Developers;1259034201000;1259143899000;Bug;[];[];[The following code defines a class, lets BCEL parse and rewrite it without any modification, then it tries to load it into the JVM. ================================================================ import org.apache.bcel.Repository. import org.apache.bcel.classfile.JavaClass. class TestClass { public void foo() { int a = 0. /* FIRST CONDITIONAL BLOCK */ if (a == 1) { a = 0. } /* SECOND CONDITIONAL BLOCK */ if (a == 1) { a = 0. } }. } class MyClassLoader extends ClassLoader { public Class getTestClass() throws ClassNotFoundException { JavaClass jcl. jcl = Repository.lookupClass(TestClass.class). byte[] data = jcl.getBytes(). return defineClass(TestClass.class.getName(), data, 0, data.length). } } public class Main { public static void main(String[] args) { try { MyClassLoader mcl = new MyClassLoader(). mcl.getTestClass(). } catch (Exception e) { e.printStackTrace(). } } } ================================================================ If both conditional blocks are present (i.e. not commented), the following exception appears instead: org.apache.bcel.classfile.ClassFormatException: Invalid Stack map table tag: 6 at org.apache.bcel.classfile.StackMapTableEntry.dump(StackMapTableEntry.java:143) at org.apache.bcel.classfile.StackMapTable.dump(StackMapTable.java:86) at org.apache.bcel.classfile.Code.dump(Code.java:154) at org.apache.bcel.classfile.FieldOrMethod.dump(FieldOrMethod.java:111) at org.apache.bcel.classfile.JavaClass.dump(JavaClass.java:317) at org.apache.bcel.classfile.JavaClass.getBytes(JavaClass.java:268) at MyClassLoader.getTestClass(Main.java:23) at Main.main(Main.java:32) If only the second one is commented, the following exception is thrown: Exception in thread "main" java.lang.ClassFormatError: Attribute name has bad constant pool index 4608 in class file TestClass at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:621) at java.lang.ClassLoader.defineClass(ClassLoader.java:466) at MyClassLoader.getTestClass(Main.java:24) at Main.main(Main.java:32) If both conditional blocks are commented, or if the code is compiled with Java 1.5 compiler instead of 1.6, everything is OK. This happens with BCEL revision 883394.];[];
BCEL-137;[BCEL-137] "Invalid method signature: TT" when using MethodGen for a method having a generic parameter;Fixed;Closed;Apache Commons Developers;1259108175000;1263126119000;Bug;[patch.txt];[];[The following code throws a "ClassFormatException: Invalid method signature: TT." when executed: =========================================================== import org.apache.bcel.Repository. import org.apache.bcel.classfile.JavaClass. import org.apache.bcel.classfile.Method. import org.apache.bcel.generic.ConstantPoolGen. import org.apache.bcel.generic.MethodGen. class MyClassLoader extends ClassLoader { @Override public Class<?> loadClass(String name) throws ClassNotFoundException { if (name.startsWith("java.lang")) return super.loadClass(name). JavaClass jcl. jcl = Repository.lookupClass(name). scanMethods(jcl). byte[] data = jcl.getBytes(). return defineClass(name, data, 0, data.length). } private void scanMethods(JavaClass jcl) { ConstantPoolGen cpg = new ConstantPoolGen(jcl.getConstantPool()). Method[] methods = jcl.getMethods(). for (int i = 0. i < methods.length. i++) { MethodGen mg = new MethodGen(methods[i], jcl.getClassName(), cpg). } } } class Foo<T> { public void bar(T x) { } } public class MethSignTest { public MethSignTest() { Foo<Integer> foo = new Foo<Integer>(). } @SuppressWarnings("unchecked") public static void main(String[] args) { try { MyClassLoader mcl = new MyClassLoader(). Class<MethSignTest> c = (Class<MethSignTest>) mcl .loadClass(MethSignTest.class.getName()). c.newInstance(). } catch (Exception e) { e.printStackTrace(). } } } =========================================================== Here's the full stack trace: org.apache.bcel.classfile.ClassFormatException: Invalid method signature: TT. at org.apache.bcel.classfile.Utility.typeOfSignature(Utility.java:986) at org.apache.bcel.generic.Type.getType(Type.java:169) at org.apache.bcel.generic.MethodGen.<init>(MethodGen.java:255) at methodsignature.MyClassLoader.scanMethods(MethSignTest.java:26) at methodsignature.MyClassLoader.loadClass(MethSignTest.java:17) at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319) at methodsignature.MethSignTest.<init>(MethSignTest.java:38) at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27) at java.lang.reflect.Constructor.newInstance(Constructor.java:501) at java.lang.Class.newInstance0(Class.java:350) at java.lang.Class.newInstance(Class.java:303) at methodsignature.MethSignTest.main(MethSignTest.java:47) This misbehaviour occurs at least since revision 617860.];[It looks like this is due to an unsupported (and undocumented in the JLS) "T" signature character, representing a generic type. The problem disappears with the attached patch. Attachment patch.txt has been added with description: a patch for this bug Thx! Applied.];
BCEL-138;[BCEL-138] FieldInstruction.getFieldSize() doesn't decode Type.getTypeSize() output;Fixed;Closed;Apache Commons Developers;1259119550000;1263126780000;Bug;[patch.txt];[];[The method getTypeSize(String) in the Type class returns two outputs encoded in one integer: the lowest two bits contain the field size (0, 1 or 2), the remaining ones the no. of consumed characters in the signature. Type provides two private static methods, size() and consumed(), to split these values apart. The method getFieldSize(ConstantPoolGen) in the FieldInstrucion class uses Type.getTypeSize, unaware that the output is encoded. Therefore, the returned size is different than expected. This causes, among other things, a bigger or smaller max stack depth value for generated methods that leads to unused stack memory or a "java.lang.VerifyError: stack size too large" exception, respectively. A fix can be made by making the above-mentioned static methods package-visible and modifying getFieldSize() to use them.];[Attachment patch.txt has been added with description: a patch for this bug Thx! Applied.];
BCEL-139;[BCEL-139] org.apache.bcel.classfile.JavaClass.getSuperclassName() is broken for java.lang.Object;Won't Fix;Resolved;Apache Commons Developers;1259654861000;1303547243000;Bug;[];[];[I think that following expression should return a special value (e.g. null) or throw an Exception: org.apache.bcel.util.SyntheticRepository.getInstance().loadClass("java.lang.Object").getSuperclassName() However, it simply returns "java.lang.Object". I think that this behaviour should be corrected or documented. The http://jakarta.apache.org/bcel/apidocs/ doesn't contain any information about it.];[I agree with the sentiment of this report, however throwing an exception seems wrong. Returning null is probably valid, altho I'm concerned that some client code will start breaking with this fix. I agree with the backward compatibility reason. However, I think that it should be documented in such case. Note that getSuperClass()'s behavior can be also broken, but I haven't tested it. Embellished JavaDoc to explain odd behaviour with calling getSuperclassName on java.lang.Object. Committed revision 1096137.];
BCEL-140;[BCEL-140] org.apache.bcel.generic.Instruction.equals(Object) does not follow Object.equals(Object) rules;Fixed;Closed;Apache Commons Developers;1259655513000;1300027553000;Bug;[];[];[org.apache.bcel.generic.Instruction contains two strange methods: equals and setComparator. The equals and hashCode methods are by definition (see http://java.sun.com/javase/6/docs/api/java/lang/Object.html#hashCode%28%29 ) broken: If two Instruction objects have another InstructionComparator, they can be asymmetrically equal. If instructions aren't compared by identity (==), the inherited hashCode method is by definition broken. I suggest: deprecate setComparator method.];[Agreed. deprecated Committed revision 1081191];
BCEL-141;[BCEL-141] Select instructions should implement StackConsumer instead of StackProducer;Fixed;Closed;Apache Commons Developers;1268571144000;1300027306000;Bug;[];[];[Select instruction (class org.apache.bcel.generic.Select) is currently implementing interface StackProducer. It should instead, implement interface StackConsumer, since both instructions LOOKUPSWITCH and TABLESWITCH do consume (pop) the operand stack. In addition calls to produceStack() and consumeStack() do return the correct value.];[Thanks for the report, Committed revision 1081190.];
BCEL-142;[BCEL-142] Cannot build BCEL on Windows;Duplicate;Closed;Apache Commons Developers;1269144906000;1274729742000;Bug;[];[];[Attempted to build trunk at r925722 on Windows, but couldn't, due to test failures. Windows version: Vista (64 bit) Maven Version: 2.2.1 Java Version: 1.6.0_16 (64 bit) Tests failed when asserting that file.delete() returned true. i.e. file cleanup during tests failed to delete files. The build worked on: Solaris: Maven Version: 2.2.1 Java Version: 1.4.2_11 Mac OSX: Maven Version: 2.2.1 Java Version: 1.6.0_16];[(In reply to comment #0) Minor correction to above: Solaris build used Java version 1.6.0_06 No details of which tests failed, but I suspect it was GeneratingAnnotatedClassesTestCase which is solved by the patch in BCEL-146];
BCEL-143;[BCEL-143] Fix CPL License issues with EnclosingMethod.java and LocalVariableTypeTable.java;Fixed;Closed;Apache Commons Developers;1273144586000;1273149954000;Bug;[EnclosingMethod.java, LocalVariableTypeTable.java, license-fix.patch];[];[The following BCEL source files are CPL licensed: src/main/java/org/apache/bcel/classfile/EnclosingMethod.java src/main/java/org/apache/bcel/classfile/LocalVariableTypeTable.java This is a problem since CPL is classified as a category B license by the ASF. These files are originally from the Eclipse AspectJ project. http://dev.eclipse.org/viewcvs/index.cgi/org.aspectj/modules/bcel-builder/src/org/aspectj/apache/bcel/classfile/EnclosingMethod.java?revision=1.1&root=Tools_Project&view=markup http://dev.eclipse.org/viewcvs/index.cgi/org.aspectj/modules/bcel-builder/src/org/aspectj/apache/bcel/classfile/LocalVariableTypeTable.java?revision=1.1&root=Tools_Project&view=markup IBM holds the Copyright of the 1.1 version of these files. As an employee of IBM, I am relicensing these files under AL2. I've updated the files with the Apache source license header and updated the package names for the BCEL project. I have not made any other changes to the source. I'm able to build BCEL with these updated files, but have not performed any further testing.];[Attachment license-fix.patch has been added with description: Patch to fix licensing issues Attachment EnclosingMethod.java has been added with description: For clarity, attaching the entire source file Attachment LocalVariableTypeTable.java has been added with description: For clarity, attaching the entire source file patch applied, thanks];
BCEL-144;[BCEL-144] Branch target offset too large for short;Unresolved;Open;Apache Commons Developers;1273660743000;0;Bug;[large_branch_target_fix.patch];[];[When BCEL encounters a BranchInstruction offset that is >= 32767, it throws the following exception: com.sitraka.pas.sandbox.org.apache.bcel.generic.ClassGenException: Branch target offset too large for shortat com.sitraka.pas.sandbox.org.apache.bcel.generic.BranchInstruction.dump(BranchInstruction.java:99)at com.sitraka.pas.sandbox.org.apache.bcel.generic.InstructionList.getByteCode(InstructionList.java:993)at com.sitraka.pas.sandbox.org.apache.bcel.generic.MethodGen.getMethod(MethodGen.java:616) BCEL-66 was previously filed about this exception and closed because the class that was causing the error and the suggested solution were both violating the rules of the language. My situation is a little different, so I am filing a new bug. I am inserting bytecodes into a method that is large, but within the limits defined by the language. Due to the size of the method, a number of the branch targets are large, but still small enough to fit in a short. After I insert bytecodes, the method size is still smaller than the method size limit but the large branch targets increase enough so that they no longer fit in a short and the exception occurs. I have solved the problem and am including a patch. My solution is to check the InstructionList for any branch targets that are too large to fit in a short and append a goto and a goto_w after every such instruction. I set the goto's target to the instruction that followed the branch instruction before I did my append so that the default behaviour is to maintain the original path of execution and jump over the goto_w. I set the goto_w's target to the branch instruction's target, then I set the branch instruction's target to the goto_w. I am doing this only for IfInstructions because JSRs, GOTOs and Selects seem to handle large branch targets in their implementations of updatePosition. This works and is within the rules defined by the language as far as I can tell.];[Attachment large_branch_target_fix.patch has been added with description: Fix to avoid "Branch target offset too large for short" exception. Looks OK, but needs unit tests. On second thoughts, I'm not sure that the patch should be applied as is. This is because it changes the Instruction List from the one created by the user, and it changes the original branch instructions I think it would be better if the original list and instructions were left untouched, in case the user wants to use it further. We also would need some unit tests.];
BCEL-145;[BCEL-145] Type.getReturnTypeSize() doesn't decode Type.getTypeSize() output;Fixed;Closed;Apache Commons Developers;1274699340000;1274738813000;Bug;[fixForReturnTypeSize.txt];[];[The Type.getReturnTypeSize() method doesn't decode Type.getTypeSize() output. The same bug was present in FieldInstruction.getFieldSize(), filed and fixed as BCEL-138 https://issues.apache.org/bugzilla/show_bug.cgi?id=48280 As a result of this bug, the BCEL calculates the wrong size of the return type for methods, leading to FindBugs going off the rails. The fix is the same as to fix FieldInstruction.getFieldSize(): use Type.size() to decode the coded value. I've attached a patch with the fix, and I've also looked at the other uses of getTypeSize(), and all the other invocations seem OK.];[Attachment fixForReturnTypeSize.txt has been added with description: Fix for this bug Applied to head, thanks!];
BCEL-146;[BCEL-146] SyntheticRepository.loadClass() fails to close the inputStream;Fixed;Closed;Apache Commons Developers;1274707558000;1274730075000;Bug;[SyntheticRepository.patch];[];[SyntheticRepository.loadClass() fails to close the inputStream. This causes test problems (on Windows at least) because the class files are locked against deletion. And of course it may lead to resource exhaustion.];[Attachment SyntheticRepository.patch has been added with description: Close input stream URL: http://svn.apache.org/viewvc?rev=947862&view=rev Log: BCEL-146 - SyntheticRepository.loadClass() fails to close the inputStream Modified: jakarta/bcel/trunk/src/main/java/org/apache/bcel/util/SyntheticRepository.java];
BCEL-147;[BCEL-147] BCEL's provided Maven POM file is incorrect;Won't Fix;Resolved;Apache Commons Developers;1274905282000;1331479855000;Bug;[];[];[The pom.xml file provided for versions 5.0 and 5.1 is incorrect. It specifies the GAV parameters for the regexp library directly within the <dependencies></dependencies> tags, but the GAV tags should be one layer deeper nexted within the <dependency></dependency> tags. The Bugzilla system correctly guessed my OS and platform, but this will produce at least a warning for Maven2 builds on any platform.];[Code no longer uses regexp library];
BCEL-148;[BCEL-148] BCELifier produces incorrect code for methods containing loads of class literals from constant pool;Fixed;Closed;Apache Commons Developers;1279531361000;1279571385000;Bug;[bcel-1.patch];[];[When a class literal is loaded from the constant pool, the BCELifier produces not compilable code. The attached patch fixes this issue with 3 modifications: LDC#getValue(): when a class constant is referenced, return a correct ObjectType instance. PUSH: new constructor that takes an ObjectType instance and does the right thing (I hope) BCELFactory#createConstant(): if the constant is an ObjectType, produce the correct embedding string.];[Attachment bcel-1.patch has been added with description: Proposed fix, please review. Here is a sample input class showing the problem: public class Foo { public String getFooName() { return Foo.class.getName(). } } Patch fixes the issue. Seems good to me. Applied, thanks alot for your help.];
BCEL-150;[BCEL-150] LVTT entry for 'ht' does not match any LVT entry;Unresolved;Open;Apache Commons Developers;1291895840000;0;Bug;[];[];[I used the BCEL v5.2 to do experiments on my test cases, and met the following problem: D:\java test._Test10Exception in thread "main" java.lang.ClassFormatError: LVTT entry for 'ht' in class file test/_Test10 does not match any LVT entry        at java.lang.ClassLoader.defineClass1(Native Method)        at java.lang.ClassLoader.defineClassCond(ClassLoader.java:632)        at java.lang.ClassLoader.defineClass(ClassLoader.java:616)        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:141)        at java.net.URLClassLoader.defineClass(URLClassLoader.java:283)        at java.net.URLClassLoader.access$000(URLClassLoader.java:58)        at java.net.URLClassLoader$1.run(URLClassLoader.java:197)        at java.security.AccessController.doPrivileged(Native Method)        at java.net.URLClassLoader.findClass(URLClassLoader.java:190)        at java.lang.ClassLoader.loadClass(ClassLoader.java:307)        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)        at java.lang.ClassLoader.loadClass(ClassLoader.java:248)Could not find the main class: test._Test10.  Program will exit. My test case is as follows: public class _Test10 {    public static void main (String [] args) {        HashMap <Double,Integer> ht = new HashMap<Double,Integer>().    }} Using BCEL, I didn't make any change of the original Method. Using it, I generated a new Method and replaced it with the new one. ClassGen _cg = new ClassGen(_claz).for (Method oldMethod : _inMethods) {    MethodGen mg = new MethodGen(oldMethod, _inClass.getClassName(), _cpg).    Method newMethod = mg.getMethod().    _cg.replaceMethod(oldMethod, newMethod).}];[];
BCEL-151;[BCEL-151] Code attribute size not updated;Fixed;Closed;Apache Commons Developers;1300019712000;1300025313000;Bug;[];[];[The code attribute length when dumped is not updated, and as such will write the old size of the attribute should the size of the actual byte code change. A possible fix is adding: "setLength(calculateLength())." to the first line of: org.apache.bcel.classfile.Code.dump(DataOutputStream) throws IOException When trying to execute code that has this error, it throws a ClassFormatException, Wrong code segment length (Should there be no other formatting errors with the code).];[Thanks for the report, updated length on setCode( byte[] code ) and on setExceptionTable( CodeException[] exception_table ) Committed revision 1081178.];
BCEL-152;[BCEL-152] Incorrect link for Jasmin assembler language;Fixed;Closed;Apache Commons Developers;1301679112000;1666870405000;Bug;[];[];[The correct link for Jasmin seems to be http://jasmin.sourceforge.net/, not http://mrl.nyu.edu/~meyer/jasmin/ as used on some pages.];[];
BCEL-153;[BCEL-153] Examples not present in source or binary downloads;Fixed;Closed;Apache Commons Developers;1301680916000;1331479404000;Bug;[];[];[The BCEL docs mention various utilities - e.g Jasmin visitor - but these don't seem to be available from any of the downloads, only from SVN. It would be useful to include the examples in both source and binary downloads];[URL: http://svn.apache.org/viewvc?rev=1299378&view=rev Log: BCEL-153 - Examples not present in source or binary downloads Added: commons/proper/bcel/trunk/src/main/assembly/ commons/proper/bcel/trunk/src/main/assembly/bin.xml (with props) commons/proper/bcel/trunk/src/main/assembly/src.xml (with props) Modified: commons/proper/bcel/trunk/src/changes/changes.xml];
BCEL-154;[BCEL-154] ClassParser.parse() generates NPE if it cannot open the file;Fixed;Closed;Apache Commons Developers;1301689633000;1301689729000;Bug;[];[];[The finally block does not check for file == null, so file oper failure generates an NPE rather than propagating the IOError.];[Oops - I see the issue has been fixed in SVN already.];
BCEL-155;[BCEL-155] InstConstraintVisitor does not handle class constants;Fixed;Closed;Apache Commons Developers;1311769291000;1311823299000;Bug;[ldc-constraintverifier.patch];[];[InstConstraintVisitor gives an error if ldc/ldc_w is used to load a class constant (svn r1151433). This is allowed since the JVM 1.5 specifications (and I've seen this has been fixed in several other places in BCEL already). The attached patch fixes this problem.];[Attachment ldc-constraintverifier.patch has been added with description: Patch to add class constant support to ldc/ldc_w Thanks for the patch Committed revision 1151709.];
BCEL-156;[BCEL-156] Pass3bVerifier crashes on empty methods;Fixed;Closed;Apache Commons Developers;1311776285000;1311823037000;Bug;[Pass3bVerifier-emptymethods-crash.patch.txt];[];[];[Pass3bVerifier crashes at Pass3bVerifier.java:255 when running on empty methods, because ih.getPrev() is null in that case. The attached patch fixes that. Attachment Pass3bVerifier-emptymethods-crash.patch.txt has been added with description: Patch to fix crash in Pass3bVerifier when going over empty methods Thanks for the patch, Committed revision 1151706.];
BCEL-157;[BCEL-157] Add support for INVOKEDYNAMIC and MethodHandles, et. al.;Fixed;Closed;Apache Commons Developers;1313449634000;1666870406000;Bug;[];[];[The INVOKEDYNAMIC instruction needs to have added support in BCEL. This issue documents this requirement.];[I have added some initial plumbing in r1377530. I am unlikely to provide a full implementation as my goal is to provide Java 7 support in Tomcat's severely cut-down fork of BCEL. AFAICT support has been added independently];
BCEL-158;[BCEL-158] Eclipse debugger fails on BCEL-instrumented methods having generic local variables.;Unresolved;Open;Apache Commons Developers;1315801052000;0;Bug;[];[];[When any method is instrumented with BCEL to include additional constants, and the method was originally compiled with local variables that have generic arguments, the method is no longer viewable in the Eclipse debugger. For these methods, it complains "com.sun.jdi.InternalException: Got error code in reply:35 occurred retrieving 'this' from stack frame." It sounds like the local variable table is somehow not compatible with the debugger, even if the instrumentation activity did not touch the generic local variables. I'm currently using the 6.0-20110805.040858-2 snapshot. Please let me know if there is any workaround. Thanks!];[Here is an icky workaround: Method method = <initialize>. MethodGen methodGenerator = new MethodGen(method, ...). InstructionList instructions = methodGenerator.getInstructionList(). Map<Integer, InstructionHandle> handlesByPosition = new HashMap<Integer, InstructionHandle>(). for (InstructionHandle handle : instructions.getInstructionHandles()) { handlesByPosition.put(handle.getPosition(), handle). } if (method.getLocalVariableTable() != null) { methodGenerator.removeLocalVariables(). for (LocalVariable local : method.getLocalVariableTable().getLocalVariableTable()) { methodGenerator.addLocalVariable(local.getName(), Type.getType(local.getSignature()), local.getIndex(), handlesByPosition.get(local.getStartPC()), handlesByPosition.get(local.getStartPC() + local.getLength())). } } I've added a fix in Type.getType(String signature) method to remove all generics information. int index = signature.indexOf('<'). // Look for generics and ignore it. if (index < 0) { index = signature.indexOf('.'). // Look for closing '.' if (index < 0) { throw new ClassFormatException("Invalid signature: " + signature). } } else if (index == 0) { throw new ClassFormatException("Invalid signature: " + signature). } Could this be a bug fix? Note that there is same code in "org.apache.bcel.classfile.Utility.signatureToString( String signature, boolean chopit )"];
BCEL-159;[BCEL-159] LocalVariableGen.getLocalVariable() computes incorrect length;Fixed;Closed;Apache Commons Developers;1325721476000;1326595823000;Bug;[patch.diff];[];[It seems that getLocalVariable computes incorrect length for the returning LocalVariable if its range is not the whole method. This is the original code: public LocalVariable getLocalVariable( ConstantPoolGen cp ) { int start_pc = start.getPosition(). int length = end.getPosition() - start_pc. if (length > 0) { length += end.getInstruction().getLength(). } int name_index = cp.addUtf8(name). int signature_index = cp.addUtf8(type.getSignature()). return new LocalVariable(start_pc, length, name_index, signature_index, index, cp.getConstantPool()). } I think that the check "if (length > 0)" is a "workaround" for local variables whose end targets the last instruction. In this case, we must add the instruction length to recover the actual range for the local variable. However, we should not add the instruction's length if it is not the last instruction of the list because variable ranges are exclusive in the end_pc (note that the JVM spec used to say that the range is inclusive, but this was corrected in JVM5 - see http://java.sun.com/docs/books/jvms/second_edition/jvms-clarify.html or more specifically page 143 of http://java.sun.com/docs/books/jvms/second_edition/ClassFileFormat-Java5.pdf ). This error can be verified by parsing a method that has local variables whose range is not the whole method (like variables for exceptions in an exception handler), creating a MethodGen and then comparing the local variable tables. Something like this: ClassParser parser = new ClassParser(...). JavaClass clazz = parser.parse(). Method m = clazz.getMethods()[...]. ConstantPoolGen cpg = new ConstantPoolGen(clazz.getConstantPool()). MethodGen mg = new MethodGen(m, clazz.getClassName(), cpg). System.out.println(mg.getLocalVariableTable(cpg)). System.out.println("=="). System.out.println(m.getLocalVariableTable()). would produce some output which includes: LocalVariable(start_pc = 17, length = 7, index = 2:Exception e1) ... == ... LocalVariable(start_pc = 17, length = 6, index = 2:Exception e1) Note that the length is greater than the original. If this is really a bug, I believe a fix is to use if (end.getNext() == null) instead (see the patch in attachment). I ran the whole test suite with this fix and it passes, but I am not sure what else it affects. Cheers, Thiago];[Attachment patch.diff has been added with description: Changes the check to add the end instruction length to the local variable length Agreed, thanks for the patch, Committed revision 1231616.];
BCEL-161;[BCEL-161] InstructionTargeters not being properly cleaned up.;Duplicate;Closed;Apache Commons Developers;1326126623000;1424476517000;Bug;[patch.diff];[];[It seems that InstructionTargeters are not being properly cleaned up when they are not used anymore. That is, when a targeter is replaced or removed (e.g., a LocalVariableGen is removed from a method), the targeter remains in the targeters list of its targets. For example, MethodGen's constructor which receives a Method uses its other constructor to initialize the object: public MethodGen(Method m, String class_name, ConstantPoolGen cp) {   this(       m.getAccessFlags(),        Type.getReturnType(m.getSignature()),       Type.getArgumentTypes(m.getSignature()),       null /* may be overridden anyway */,       m.getName(),        class_name,       ((m.getAccessFlags() & (Constants.ACC_ABSTRACT | Constants.ACC_NATIVE)) == 0) ? new InstructionList(m.getCode().getCode()) : null, cp)....} Because this call passes null as its 4th argument, the constructor will create placeholder LocalVariableGen for the arguments (like arg0, arg1, etc). Later in this constructor the arguments will be overridden (as indicated by the comment). However, the LocalVariableGens of the placeholder arguments (as well as the LocalVariableGen for the "this" variable) will remain in the targeter lists of the first and last instructions of the instruction list. To avoid this problem I am submitting a patch in attachment. It adds a new method to InstructionTargeter:     /**     * Removes all targets of this targeter.     */    void removeTargets(). and implements it to remove the targeter from the target's lists. The patch also calls removeTargets() when discarding targeters in MethodGen.];[Attachment patch.diff has been added with description: New method to InstructionTargeter for target cleanup. Thank you very much for the report Thiago. I didn't notice this issue before fixing BCEL-207 with a very similar approach. I added a package private dispose() method to LocalVariableGen which is called from MethodGen.removeLocalVariable. You suggested adding a call to this.removeLocalVariables() in the MethodGen constructor, but if I'm not mistaken this is not necessary since the method is already called bellow when the attributes are parsed and the LocalVariableTable is encountered. It seems the removeTargets() method in CodeExceptionGen, Select and BranchInstruction aren't used so I'll pass on them for now, but I like the idea. I applied your documentation improvements to InstructionTargeter.];
BCEL-162;[BCEL-162] Invalid LocalVariableTable and LineNumberTable after modifying instruction list;Unresolved;Open;Apache Commons Developers;1326563918000;0;Bug;[patch.diff];[];[LocalVariableGen objects point to the start and end InstructionHandles which indicate the variable range. However, when changing the instruction list with MethodGen.setInstructionList, the LocalVariableGen objects point to instruction handles that do not belong to the new list. When MethodGen.getMethod is called, LocalVariable objects will be created using the bytecode offsets of handles that do not belong to the current instruction list. Because bytecode instructions can have different lengths, the offsets may be invalid (i.e., do not point to an instruction, which is invalid according to the java bytecode spec). A similar problem occurs with LineNumberGens. One proposed solution is to check at getLocalVariables() (and getLineNumberTable) whether the target handle belongs to the current instruction list. If not, we first search for the "best candidate" in the current list, i.e., the instruction with the position of the original targeted instruction, or the next one if there is no perfect match. Then we use this instruction's offset in the LocalVariable. Sketch of the code: public LocalVariableGen[] getLocalVariables() { int size = variable_vec.size(). LocalVariableGen[] lg = new LocalVariableGen[size]. variable_vec.toArray(lg). for (int i = 0. i < size. i++) { if (lg[i].getStart() == null) { lg[i].setStart(il.getStart()). } else { lg[i].setStart(il.findHandle(lg[i].getStart().i_position)). } ... } The patch in attachment fixes this problem plus the last 2 bugs I reported ( https://issues.apache.org/bugzilla/show_bug.cgi?id=52441 and https://issues.apache.org/bugzilla/show_bug.cgi?id=52422 ).];[Attachment patch.diff has been added with description: Fixes bugs 52441, 52422 and invalid offsets in local variable and line number tables Would be great to have a test case for this. Sounds about right though.];
BCEL-164;[BCEL-164] Method does not have a method to access parameter annotations;Fixed;Closed;Apache Commons Developers;1332527978000;1334093953000;Bug;[accessParameterAnnotations.diff];[];[The org.apache.bcel.classfile.Method class does have a simple method to access the parameter annotations. The attached diff provides this method and unit tests to prove the method.];[Attachment accessParameterAnnotations.diff has been added with description: getParameterEntries implementation Applied - with a few little changes. Mostly style and whitespace. Method is final so I kept visibility of the added class var to private.];
BCEL-165;[BCEL-165] getAnnotationEntries methods in JavaClass and FieldOrMethod duplicate code;Fixed;Closed;Apache Commons Developers;1332528425000;1666870405000;Bug;[refactorGetAnnotations.diff];[];[JavaClass.getAnnotationEntries() and FieldOrMethod.getAnnotationEntries() are overly complex. FieldOrMethod.addAnnotationEntry() appears to be in the wrong place - FieldGenOrMethodGen.addAnnotationEntry() is the proper method to use.];[Attachment refactorGetAnnotations.diff has been added with description: refactoring of JavaClass, FieldOrMethod, and AnnotationEntry The patch has been applied, thank you very much Charles.];
BCEL-167;[BCEL-167] ClassPath.getResource does not correctly perform URL escaping;Fixed;Closed;Apache Commons Developers;1338156079000;1338208357000;Bug;[toURI.patch];[];[When asking for resources with a space in the name, these should be URL escaped but are not. The patch replaces the deprecated File.toURL() with File.toURI().toURL() which fixes the issue.];[Attachment toURI.patch has been added with description: Convert use of File.toURL() to File.toURI().toURL() Committed revision 1343226.];
BCEL-168;[BCEL-168] Stack map table problem with in JDK7 (java.lang.VerifyError: Expecting a stack map frame in method);Unresolved;Open;Apache Commons Developers;1349943803000;0;Bug;[];[];[I want add local variable for a method. (using javaagent option) But when I try this with in JDK 7, I did face with java.lang.VerifyError (stack map offset problem) As I know, this problem is related with added new feature stack map table in JDK 7. So I've been search how to fix it, but almost of solution were change JDK version or use -XX option. But I don't want use it because I heard that if use SplitVerifier I will lose benefits of JDK7 default Verifier. Can I fix this problem use only BCEL or BCEL team have a plan to accommodate it?];[It looks like we have to rebuild StackMapTable from scratch during method generation. I've tried BCEL code and it looks like it already have implementation we need but I don't see ways to reuse it for now... By the way I recommend to increase this issue priority to high or blocker.];
BCEL-170;[BCEL-170] Type.getArgumentTypes() throws ClassFormatException: Invalid method signature: >);Unresolved;Open;Unassigned;1358636229000;0;Bug;[BCEL-170_Type_getArgumentTypes()_throws_ClassFormatException.patch];[];[for (Attribute attribute : method.getAttributes()) {    if (attribute instanceof Signature) {        Signature sig = (Signature) attribute.        System.out.println("Sig: " + sig.getSignature()).        System.out.println("Ret: " + Type.getReturnType(sig.getSignature())).        System.out.println("Prm: " + Type.getArgumentTypes(sig.getSignature())).    }} Input:     public SampleReturn<SampleMethodReturnType>            method             (SampleMethodParameter<SampleMethodParameterType> param1) {              ...           } Output: Sig: (Lnet/sf/sample/SampleMethodParameter<Lnet/sf/sample/SampleMethodParameterType.>.)Lnet/sf/sample/SampleReturn<Lnet/sf/plugfy/sample/SampleMethodReturnType.>.Ret: net.sf.sample.SampleReturn<Lnet.sf.sample.SampleMethodReturnTypeorg.apache.bcel.classfile.ClassFormatException: Invalid method signature: >.)Lnet/sf/sample/SampleReturn<Lnet/sf/sample/SampleMethodReturnType.>.at org.apache.bcel.classfile.Utility.typeOfSignature(Utility.java:978)at org.apache.bcel.generic.Type.getType(Type.java:169)at org.apache.bcel.generic.Type.getArgumentTypes(Type.java:230)];[What do you expect to get? As far as I understand result should be: Ret: net.sf.sample.SampleReturnPrm: net.sf.sample.SampleMethodParameter If yes then why don't you just use method.getArgumentTypes() ? I recommend the following patch to fix ClassFormatException. The main idea is that we have to consider generics in the signature during parsing. To get generics work with Type it should be discussed later.];
BCEL-172;[BCEL-172] Searching bug;Duplicate;Closed;Unassigned;1382096338000;1398349126000;Bug;[];[];[It turned out that finder.search methods generates incorrect output. For example: finder.search("invokespecial") Will find not only some INVOKESPECIAL opcodes but will return InstructionHandle arrays in form: [   invokespecial,    nextOpCode] So instead of returning x matching opcode(s) it returns x+1 matching opcodes in one IntructionHandle array. This generates problem when invoking finder.search("invokespecial return") which will throw Exception in thread "main" java.lang.ArrayIndexOutOfBoundsExceptionat java.lang.System.arraycopy(Native Method)at org.apache.bcel.util.InstructionFinder.getMatch(InstructionFinder.java:171)at org.apache.bcel.util.InstructionFinder.search(InstructionFinder.java:231)at org.apache.bcel.util.InstructionFinder.search(InstructionFinder.java:250)at Transform.transformMethod(Transform.java:66)at Transform.main(Transform.java:25) because of situation, that after return there is no more instruction (so InstructionHandler too) to get. It occurs especially for default constructors as they bytecode is like: invokespecialreturn. Error exists because of erroneous instruction(line 230 in InstructionFinder.java, method search()): int lenExpr = (endExpr - startExpr) + 1. There should be no "+1" part because: int endExpr = matcher.end(). (which is one line above) returns index AFTER match. So bug generally (I didn't tested properly) could be repaired with replacing erroneous line with: int lenExpr = (endExpr - startExpr).];[];
BCEL-173;[BCEL-173] ClassParser fails to parse JDK classes in Java 8: ClassFormatException: Invalid byte tag in constant pool;Fixed;Closed;Michael Osipov;1397482072000;1397942985000;Bug;[bcel-bug.tgz, bceltestcase.zip];[];[See attached sample project that reproduces the failure. On Java 7, it prints info about the ConcurrentMap class. On Java 8, it encounters the following exception: Exception in thread "main" org.apache.bcel.classfile.ClassFormatException: Invalid byte tag in constant pool: 18at org.apache.bcel.classfile.Constant.readConstant(Constant.java:146)at org.apache.bcel.classfile.ConstantPool.<init>(ConstantPool.java:67)at org.apache.bcel.classfile.ClassParser.readConstantPool(ClassParser.java:222)at org.apache.bcel.classfile.ClassParser.parse(ClassParser.java:136)at TestMain.main(TestMain.java:11) To use the sample project, extract it and then run "./gradlew clean run".];[This may be related to a similar issue in bnd: https://github.com/bndtools/bnd/issues/502 this appears to be fixed in trunk, can you retest? I confirm it works on the trunk since invokedynamic support has been implemented. Confirmed, looks fixed to me. Is there an ETA for a release of version 6.0? This is depended upon by https://github.com/jibx/jibx/issues/3. There are currently no unresolved issues assigned to BCEL 6.0. A release would allow for downstream projects like JiBX to update for Java 8 without depending on a snapshot version. The version 6.0 is being reviewed and should be released soon. I tried the latest version 6.0 snapshot downloaded from https://repository.apache.org/content/repositories/snapshots/org/apache/bcel/bcel/6.0-SNAPSHOT/ , but still got the same error. Does the snapshot include the fix? Yes it does. I parsed the entire rt.jar from Java 8 and got no error. Maybe an earlier version of BCEL was also on your classpath? Any update on when version 6.0 might be released? Quite eager as this is blocking my company's upgrade to Java 8. Thanks! Looks like there was a vote to release RC3. There were more +1s than -1s, but no update as to whether it was considered passed, failed, etc. Not sure what the status is, but I'm very appreciative of your work to try to push it out Emmanuel! http://apache-commons.680414.n4.nabble.com/VOTE-Release-BCEL-6-0-based-on-RC3-td4667129.html Hi Ben, I postponed the release to address the issues reported during the vote. You can still build and use the RC3 in your company, the API will not change much. Thanks for the response Emmanuel. It's probably easier for us to just help fix any issue than try to use the RC3. What is it that needs to be fixed? I saw a suggestion that there could be a static setter for the "bcel.dontCache" flag and that there could be a method to clear the cache. Those both seem like pretty easy changes. I could make them if that's all that's blocking a release Hey Emmanuel, thought I'd check in on this. What is it that needs to be fixed? Could we help? Thanks! Hey Emmanuel, can you confirm for me that this issue is still a problem. I got this: java.lang.RuntimeException: Unknown constant type 18 at org.apache.bcel.classfile.ConstantPool.constantToString(ConstantPool.java:147) From examining the source, it appears the ContantPool class has a switch statement that does not have a case for the CONSTANT_InvokeDynamic (18) value. Thanks! @adambender the best is to look at the open issues and the latest discussions on the mailing list. @dldiehl What is your test case and what version of BCEL did you use? Emmanuel, I used the latest 6.0 SNAPSHOT from this afternoon. The MANIFEST.MF file has this in it: Bundle-Version: 6.0.0.SNAPSHOT Implementation-Build: trunk@r1646254. 2014-12-17 15:20:04+0000 I'm trying to run VerifyDesign (ant task) that uses BCEL on my project that uses Java 8. It'll take me some time to determine which file is causing the error and prepare a test case. I'll do that if you need that. Emmanuel. I just updated a file bceltestcase.zip that contains a test case to reproduce a RuntimeException at org.apache.bcel.classfile.ConstantPool.constantToString(ConstantPool.java:147) Let me know if you need anything else. Thanks. Dave Thank you for the testcase, I can see the issue now. This is an omission in a method printing the code. This is now fixed on the trunk. I'm still curious if there's anything we can do to help with getting this ready for a release? Thanks Emmanuel! I pulled down the latest SNAPSHOT build and everything works fine! Thanks, again. What is it that's blocking a release? Bringing this up again. Any progress on the release? The release is still being worked on, you can get more details on the mailing list. Java 7 is now in end-of-life & no-longer recommended for production use. If there is no 6.0 relesae forthcoming I see no alternative but to find replacements for any libraries dependent on BCEL. I don't know how up to date your "Used by" link is but if it's not possible to get a build out within the next month or so I don't see much future for the project. Sorry for your frustation, in the interim, if you choose you can use this jar which should fix things till a release is out http://search.maven.org/#artifactdetails|com.google.code.findbugs|bcel-findbugs|6.0|jar Any ETA when 6.0 will be released? I do not have one... ebourg? ebourg Do you have an ETA when 6.0 will be released? Also waiting on this It would be very helpful if BCEL 6.0 could be released with this patch. This is blocking JiBX from supporting Java 8. Would also appreciate a release, to get clirr working with java8. Releasing 6.0 would also solve Java 8 related problems on some Maven plugins, like https://issues.apache.org/jira/browse/MSHARED-409 and https://issues.apache.org/jira/browse/MPIR-308. Please release! We're waiting for this to get clirr working with java 8 in kryo (without being forced to depend on snapshot maven plugins): https://github.com/EsotericSoftware/kryo/issues/315 Looks like there are a lot of people waiting on this, and its been fixed for well over a year now (if the timestamps on the entries are correct, but i expect that they are). If there are other things holding up an release, can this be a 5.x patch or a 6.0-beta release?? Just as long as its in a maven repo that is stable and reachable (I really don't want to bundle a home-rolled version in our production code) We are waiting for this to be released too. Please release 6.0 Workaround: Use "bcel-findbugs" instead. See https://github.com/RichardWarburton/lambda-behave/issues/31#issuecomment-86052095 I'm getting this problem using AspectJ with RxJava. There's a long time since 5.2 was released (Jun 2006)... Any chance of releasing 6.0? any release soon? Is all you need in trunk ATM? If not, can you help? yup releasing the trunk would be perfect and make everybody happy. Helping I'm not sure. I don't want to have to waste too much time discussing about a missing comma in a NOTICE file or a file containing a 2015 instead of 2016, or a checkstyle minor issue somewhere. I would be very happy to help but sorry releasing is too complicated here. I was thinking about the code itself and JIRAs... works fine with java 8 so that's what a lot of people need.... Some people expressed concern that we were breaking compatibility with JDK support, and so the thought was that a bunch of code would need to be rolled back. I'm not sure why that matters, we've already changed the package structure so there is no conflict. But that is where we are. There hasn't been a large amount of testing on it. Findbugs is the primary tester of it, and they have been running with a forked version (who's changes are now in bcel trunk), so there's that proof of correctness at least. I'd release it myself, otherwise, there's no point, if it goes any further. --dave Good to know, thanks Dave. The more detail you can provide the better. Especially since BCEL is rather thin on unit tests.];
BCEL-174;[BCEL-174] Verification of interfaces with default methods fails with Java 8;Fixed;Closed;Unassigned;1397980019000;1398261984000;Bug;[];[];[With Java 8 the verifier fails to validate interfaces containing default methods. For example with the Collection interface it returns this error: Interface method 'public boolean removeIf(java.util.function.Predicate arg1) [Signature((Ljava/util/function/Predicate<-TE.>.)Z)]' must have the ACC_STATIC modifier set but hasn't!];[There are two issues here: The error message is wrong, the missing modifier on the default methods is ACC_ABSTRACT and not ACC_STATIC default methods in Java 8 are obviously not abstract, so this rule doesn't apply to the class format 52 and above. Here is the relevant part of the specification: http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.6 Methods of interfaces may have any of the flags in Table 4.6-A set except ACC_PROTECTED, ACC_FINAL, ACC_SYNCHRONIZED, and ACC_NATIVE (JLS §9.4). In a class file whose version number is less than 52.0, each method of an interface must have its ACC_PUBLIC and ACC_ABSTRACT flags set. in a class file whose version number is 52.0 or above, each method of an interface must have exactly one of its ACC_PUBLIC and ACC_PRIVATE flags set.];
BCEL-176;[BCEL-176] util.ClassPath.getClassFile(String name, String suffix) - unused loop variable;Fixed;Closed;Unassigned;1401490690000;1424419165000;Bug;[];[];[The method util.ClassPath.getClassFile(String name, String suffix) uses a for loop, but does not use the variable in the loop. for (PathEntry path : paths) {...} It looks like the loop is redundant and should be removed.];[This is a left over of http://svn.apache.org/r897695, it can be safely removed.];
BCEL-177;[BCEL-177] MethodParameters should read 1 byte not two for parameter count;Fixed;Closed;Unassigned;1406579408000;1406579646000;Bug;[];[];[Originally reported against Apache Tomcat's cut-down version of BCEL as https://github.com/apache/tomcat/pull/12];[];
BCEL-178;[BCEL-178] ClassFormatException: [Invalid signature: `TT'] when using Utility.signatureToString;Duplicate;Closed;Unassigned;1407259632000;1424396049000;Bug;[BCEL-178-Utility.java.patch];[];[Utility.signatureToString(...) can fail with this exception: Caused by: org.apache.bcel.classfile.ClassFormatException: Invalid signature: `TT.'at org.apache.bcel.classfile.Utility.signatureToString(Utility.java:855)at org.apache.bcel.classfile.Utility.signatureToString(Utility.java:765)at org.apache.bcel.classfile.LocalVariable.toString(LocalVariable.java:236)at org.apache.bcel.classfile.LocalVariableTypeTable.toString(LocalVariableTypeTable.java:122)...  I'm using the current HEAD version (built from r1614210). It's a very similar issue to Bug 48279 (fixed in Jan 2010). This is failing for my code which has a variable typed as T like this: <T> Envelope buildRequest(Class<T> contentClass) {    Envelope result = buildEnvelope(). // some holder type    T body = Utils.newInstance(contentClass). // generic method returning an instance of contentClass    // ... more work ...    return result.} I've fixed this locally following the pattern used in Bug 48279's fix (see r897699), essentially adding the 'T' option next to 'L' in the Switch statement (see attached patch)];[Thank you for the report Will, this was also reported in BCEL-197 and is now fixed on the trunk.];
BCEL-181;[BCEL-181] org.apache.bcel.util.ClassLoaderRepository.loadClass(String) leaks input streams;Fixed;Closed;Gary D. Gregory;1412078049000;1412083998000;Bug;[];[];[The method org.apache.bcel.util.ClassLoaderRepository.loadClass(String) leaks input streams. It gets a stream for a file resource and never closes it.];[If I'm not mistaken it's closed in the ClassParser.parse() method, at line 174. In SVN. [For completeness] If I'm not mistaken it's closed in the ClassParser.parse() method, at line 174. As noted on the dev list, the file is only closed by parse() if fileOwned is true.];
BCEL-184;[BCEL-184] JustIce verifier does not check correctly the returned value of a method;Fixed;Closed;Unassigned;1418808728000;1425687865000;Bug;[BCEL-184.patch, BCEL-184.zip];[];[Defining a areturn opcode (return object) in a void method is accepted by the bytecode verifier. This must not be allowed. Here is an example of a non-valid bytecode for a void method:        BB 0003      // 0   : new java/lang/Object       59           // 3   : dup        B7 0008      // 4   : invokespecial java/lang/Object.<init>()V       00           // 7   : nop        B0           // 8   : areturn (Not allowed in a void method)];[Attach patch: Fix for BCEL-184 Test for BCEL-184 Attach zip: Classfile test case for BCEL-184 Jérôme, out of curiosity, how did you craft the class file? Did you compile a Java file and then inserted an opcode in the class file? Or did you use a bytecode assembler like Jasmin? I'm tempted to add a step in the Maven build that compiles jasmin source files into bytecode, that would make the content of the test classes less opaque. For the reference, here is the output of the java verifier on the test class (using java -verify): Exception in thread "main" java.lang.VerifyError: Method expects a return valueException Details:  Location:    org/apache/bcel/verifier/tests/TestReturn01.foo()V @8: areturn  Reason:    Type 'java/lang/Object' (current frame, stack[0]) is not assignable to top (from method signature)  Current Frame:    bci: @8    flags: { }    locals: { }    stack: { 'java/lang/Object' }  Bytecode:    0x0000000: bb00 0359 b700 0800 b0 This is now fixed on the trunk, thank you Jérôme. Hi Emmanuel. To produce these invalid classfiles, I compile Java files and then edit the bytecode. It is the fatest way I found to produce these classfiles. Using Jasmin to generate them may be a good solution. Another way to generate the invalid class files might be to read/write the class file using Java. Just a thought.];
BCEL-186;[BCEL-186] Performance degradation with the UTF8 cache;Fixed;Closed;Unassigned;1419951570000;1423075089000;Bug;[patch2.diff, revert-ConstantUtf8-cache.diff];[];[I'd love to see 6.0 released. Here was the last vote: http://apache-commons.680414.n4.nabble.com/VOTE-Release-BCEL-6-0-based-on-RC3-td4667129.html Konstantin Kolinko reported some issues with caching that blocked the release: I noted new methods that introduced caching into classfile.ConstantUtf8 class. BCEL_DONT_CACHE should at least have static setter, or a static setter for a cache instance / a factory class. RELEASE-NOTES.txt describes this change as BCEL-163 Incorporate patch file from Findbugs which does not say much about this change. Actually this change introduced caching for ConstantUtf8 and ObjectType instances. Emmanuel Bourg did some investigation and testing and reported back: If nobody object I'll remove this cache, the impact on the performance is too important to enable it by default, and the static state smells like a quick and dirty implementation. This feature could return as a pluggable cache if someone wants to provide a patch. garydgregory suggested adding a flush method to clear the cache in ObjectType];[Thank you for offering your help but JIRA is not the right place to discuss releases. Please join us on the dev list instead. This patch removes the cache in ConstantUtf8. Konstantin Kolinko and Emmanuel Bourg investigated and found it had a negative impact on performance. Also the feature isn't well implemented due to the static state it introduces. Hi Emmanuel. I opened the bug as a place to attach patches for release blockers. I'm afraid you saw the bug before I had a chance to attach the patch so that wasn't clear. Perhaps we can reopen and possibly rename this issue? In any case, I hope you'll take a look at the attached patch which resolves the issue brought up in the last RC vote. Thanks again for your help. Ok, let's retitle the ticket and focus on a single issue then. Thanks Emmanuel. Is this something we could check in yet? I'm not sure what the process is for reviewing and merging. Thanks! Could we merge this? I believe this was wanted from the discussion on the mailing list It might be better to keep the getInstance() method, and change it so that it creates a new instance instead of returning a cache entry. This would make it easier to provide caching later if a more performant way of doing it is found. i.e. keep the Constant class as it is, and just update the ConstantUtf8.getInstance method. sebb@apache.org Sure, that works for me. I think either way would be fine. I attached patch2.diff that does that. Thanks so much for taking a look Would you guys be able to take a look at the patch? Thanks! Could we get this change in? Thanks I added a different fix, merely changing getInstance to public static ConstantUtf8 getInstance(String s) {    return new ConstantUtf8(s).} This leaves the cache implementation in place. I can see some simple changes that might improve the performance. Keeping the alternate implementation allows this to be tested. URL: http://svn.apache.org/r1652541 Log: BCEL-186 Performance degradation with the UTF8 cache getInstance no longer uses the cache Have tried using IODH to create the HashMap. Still about 4 times slower. Great, thank you sebb@apache.org! I'd love to see a new release of BCEL now that this issue is fixed. Should we mark this bug as resolved? Fixed here: https://github.com/apache/commons-bcel/commit/fbcd823d35677e12d3bc37db531f3f18cdb17535];
BCEL-187;[BCEL-187] Verification error when an invoke references a method defined in superclass;Fixed;Closed;Charles Honton;1420465839000;1437195427000;Bug;[BCEL-187-tests-src.zip, BCEL-187.patch, BCEL-187.zip];[];[Assuming a class A with a method foo() and a class B subclass of A. If an invoke opcode references the method B.foo() then the bytecode verifier raises an error with the following error message: Referenced method 'foo' with expected signature '()void' not found in class 'B'. The native verifier does allow the method to be declared in some superinterface, which the Java Virtual Machine Specification, Second Edition does not. I can't find where in the Java Virtual Machine Specification, Second Edition this restriction is defined. The verification of the bytecode generated by the following code fails: public class TestLegalInvokeInterface01{    public static void test1(Interface01 t){        t.run().    }}interface Interface01 extends Runnable {    }];[Attach patch with: Fix for BCEL-187 Test for BCEL-187 Attach zip with: Classfile for test for BCEL-187 jejecool, Mark Thomas said on the mailing list that the following would help him commit this patch: After looking at BCEL-187 for a minute or two I can see a whole pile of work that needs to be done before I'd even think about committing anything. Just from that quick look: 1. Review the svn history to see if there are any pointers to which part of the JVM spec defines the restriction. 2. Review the JVM spec to see if I can see the restriction 3. Look at the byte code for the provided example to see which class the invoke opcode references. Better yet, write a disabled BCEL unit test to show this. 4. The structure of the test case looks odd. I suspect it aligns with other patches for other issues but nowhere is that explained. 5. The class files provided do not have any attached source. Without the source code, we have no idea (OK I could fire up a decompiler but that is another task) what is actually in those classes. To put it another way, the current code asserts one behaviour. The bug report asserts another. No evidence is provided to support either position. Given that most (all?) the current committers likely to work on BCEL don't have a deep knowledge of the JVM specs some research is required to figure out which is correct. I've set out above how I'd do the research. I'm sure there are other, better approaches. Attach zip with: Java sources for test for BCEL-187 Here the sources used to generate the classfile test cases. Here is some element of the Java Virtual Machine specification about this issue http://docs.oracle.com/javase/specs/jvms/se6/html/ConstantPool.doc.html#86899 Method resolution attempts to look up the referenced method in C and its superclasses: If C declares a method with the name and descriptor specified by the method reference, method lookup succeeds. Otherwise, if C has a superclass, step 2 of method lookup is recursively invoked on the direct superclass of C. Otherwise, method lookup attempts to locate the referenced method in any of the superinterfaces of the specified class C. If any superinterface of C declares a method with the name and descriptor specified by the method reference, method lookup succeeds. Otherwise, method lookup fails. Since the old revision of the Java Virtual Machine specification, some precisions have been added to this chapter. You can find the last revision here: https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf Committed revision 1691680.];
BCEL-188;[BCEL-188] Invalid verification of the returned value of a method;Fixed;Closed;Unassigned;1420544493000;1425757171000;Bug;[BCEL-188-2.patch, BCEL-188-3.patch, BCEL-188-3.zip, BCEL-188.patch];[];[The bytecode generated from the following code produces a verification error:     public static Object test(){        return new Object().    } Here is the error message: Pass 3b, method number 2 ['public static Object test()']: VERIFIED_REJECTED Constraint violated in method 'public static Object test()': Returned type void does not match Method's return type java.lang.Object The problem also occurs for all kind of returned value: primitive types (byte, int, etc.), array , null, object, …];[Attach patch with: Fix for BCEL-188 Test for BCEL-188 Thank you for the patch Jérôme. Do you have the TestReturn01.class file you crafted with the invalid return? I didn't split correctly the test. The TestReturn01.class file is available in the zip attached to BCEL-184 (https://issues.apache.org/jira/secure/attachment/12687705/BCEL-184.zip) Attach new patch with (supersedes the previous one BCEL-188.patch): Fix for BCEL-188 Test for BCEL-188 Previous patch does not manage byte type in Type.normalizeForStackOrLocal(). New patch handles them correctly and also adds a new test. Attach patch with: Fix for BCEL-188 Test for BCEL-188 Attach zip with: Classfile for test for BCEL-188 This patch supersedes previous patches. Fix error when returning arrays and error when returning null. jejecool can you add the source for the classfile as well? Patch applied. Mnay thanks. It still would be nice to get some form of source for the class file. The invalid classfiles defined in these tests cannot be generated from Java source. Currently, to produce them I modify a valid classfile with a disassembler. This method is not the best to obtain something documented well ebourg suggests in BCEL-184 to use Jasmin to generate these classfiles.];
BCEL-189;[BCEL-189] Wrong field resolution in the verifier may lead to verification error;Unresolved;Open;Unassigned;1420707834000;0;Bug;[BCEL-189-2.patch, BCEL-189-2.zip, BCEL-189.patch, BCEL-189.zip];[];[The field reference resolution is not implemented correctly in the verifier. This may lead to an unresolved field reference that fails the verification of a correct classfile. Here is a Java example that fails: public class B extends A{    public void test(){        int i = this.field.    }}class A {    int field.} See chapter 5.4.3.2 Field Resolution of the The Java Virtual Machine Specification Second Edition for more information (http://docs.oracle.com/javase/specs/jvms/se5.0/html/ConstantPool.doc.html#71685)];[Attach patch with: Fix for BCEL-189 Test for BCEL-189 Attach zip with: Classfile for test for BCEL-189 Attach patch with: Fix for BCEL-189 Test for BCEL-189 Attach zip with: Classfile for test for BCEL-189 This patch supersedes previous patches. Manage access of fields defined in super interfaces. Is it necessary to keep the Resolver class public? Are alternative implementations likely to be written? I'd suggest giving all new classes / fields / methods the minimum visibility necessary for things to work properly. We can always increase the visibilty later if a use case emerges that requires it. Decreasing the visibilty is a lot harder. +1 And ideally don't have any protected or public mutable fields. instead use getter/setter methods. Actually it has to be public since it's used in different packages.];
BCEL-190;[BCEL-190] Type inference computing not correct in bytecode verifier;Unresolved;Open;Unassigned;1420733538000;0;Bug;[BCEL-190.patch];[];[As described in the verifier documentation, there are some known issues in the variable type inference computing. JustIce uses object generalization during pass 3b, as supposed by Sun. However, there are better methods such as the idea proposed by Staerk et al.: using sets of object types. JustIce may reject code that is not rejected by traditional JVM-internal verifiers for this reason. The corresponding checks all have some "TODO" tag with an explanation. they're all in the 'Pass3bVerifier' files. Users encountering problems should simply comment them out (or uncomment them) as they like. Here is a simple example that reproduces this issue. It is rejected by the verifier:     public void test1(boolean b) throws IOException {        Appendable s.        if(b) {            s = System.out.        }        else {            s = new StringBuilder().        }        test2(s).    }        public void test2(Appendable s){} To avoid this example to be rejected by the verifier, it should be more tolerant. This may lead to accept some invalid bytecode but IMHO it is preferable. Actually there are already some bugs that accept invalid bytecode, especially in invokeinterface analyze.];[Attach patch with: Partial Fix for BCEL-190 Test for BCEL-190 The fix consists in ignoring the assignement compatibility checks when the expected type is an interface. The verifier may not reject some invalid classfiles with this fix. This kind of workaround is comparable to the implementation done in the Oracle JVM but it is not complete. The Oracle JVM does some additional tests at runtime when executing the opcode when interfaces are involved. See §16.1.2 of Robert F. Stärk, Joachim Schmid, and Egon Börger. Java and the Java Virtual Machine – Definition, Verification, Validation. Springer–Verlag, 2001 Sun’s JDK 1.2 verifier does not reject the bytecode. Instead it inserts an additional run-time check for methods with arguments of interface type. Hence, the compatibility of method arguments has to be checked at run- time in contradiction to the JVM specification. A complete fix may use the sets of reference types as described by Stärk in the same chapter.];
BCEL-191;[BCEL-191] Verifier assumes the classes of the verifier are in the classpath of the verified class;Unresolved;Open;Unassigned;1421136008000;0;Bug;[BCEL-191.patch];[];[When verifying a class, the verifier looks for this class and its dependencies in a classpath configured for this verification. If the classes of the verifier itself are not in this classpath, then an error can occur. The causes is the use of the internal class org.apache.bcel.verifier.structurals.GenericArray to mock the array class when a method invokation is done on an array. If the class GenericArray is not available in the classpath of the verifier class, we get the following error: Exception in thread "main" org.apache.bcel.verifier.exc.AssertionViolatedException: INTERNAL ERROR: Some RuntimeException occured while verify()ing class 'org.apache.bcel.verifier.tests.TestArray01', method 'public static void test1()'. Original RuntimeException's stack trace: — org.apache.bcel.verifier.exc.AssertionViolatedException: INTERNAL ERROR: Missing class: java.lang.ClassNotFoundException: Exception while looking for class org.apache.bcel.verifier.structurals.GenericArray: java.io.IOException: Couldn't find: org/apache/bcel/verifier/structurals/GenericArray.class at org.apache.bcel.verifier.structurals.InstConstraintVisitor.visitINVOKEVIRTUAL(InstConstraintVisitor.java:2059) … Here is a simple example of code that raises this exception:     public static void test1(){        String[] a = new String[4].        a.equals(null).    }];[Attach patch with: Fix for BCEL-191 As I understand the patch removes GenericArray completely, what do we lose by not mocking the array? Currently, the GenericArray is used when the verifier detects that the receiver of a method invokation is an array. In this case, the type of the receiver (ArrayType) is replaced by the type ObjectType that references the class GenericArray. To verify that the receiver of the called method is compatible with the method, the verifier uses the method Repository.instanceOf(String, String). In our case, the instanceOf method checks that GenericArray is compatible with the type that defines the method (Object in my example). Instead of mocking an ArrayType with an ObjectType, I kept the ArrayType and use the method ReferenceType.isCastableTo(Type). This method already manages the ArrayType so there is no need to mock it with GenericArray class.];
BCEL-192;[BCEL-192] Verification error when defining an inner class;Unresolved;Open;Unassigned;1421137206000;0;Bug;[BCEL-192.patch, BCEL-192.zip];[];[The verification of the following code fails:     public void test(){        new Runnable() {                        @Override            public void run() {            }        }.    } The cause is a wrong verification of field modification on uninitialized object. The modification of an uninitialized object is allowed in a constructor if this object is the receiver of the constructor. Here is the explanation from the §4.9.4 of The Java Virtual Machine Specification, Second Edition: The instance initialization method (§3.9) for class myClass sees the new uninitialized object as its this argument in local variable 0. Before that method invokes another instance initialization method of myClass or its direct superclass on this, the only operation the method can perform on this is assigning fields declared within myClass.];[Attach patch with: Fix for BCEL-192 Test for BCEL-192 Attach zip with: Classfile for test for BCEL-192 I get a test failure: testInvalidUninitializedObjectAccess(org.apache.bcel.verifier.VerifierUninitializedTestCase)  Time elapsed: 0.127 sec  <<< ERROR!org.apache.bcel.verifier.exc.AssertionViolatedException: INTERNAL ERROR: Some RuntimeException occured while verify()ing class 'org.apache.bcel.verifier.tests.TestUninitialized04', method 'public void <init>()'. Original RuntimeException's stack trace:---org.apache.bcel.verifier.exc.AssertionViolatedException: INTERNAL ERROR: Field 'o' not found in org.apache.bcel.verifier.tests.TestUninitialized04        at org.apache.bcel.verifier.structurals.InstConstraintVisitor.visitPUTFIELD(InstConstraintVisitor.java:2647)        at org.apache.bcel.generic.PUTFIELD.accept(PUTFIELD.java:85)        at org.apache.bcel.generic.InstructionHandle.accept(InstructionHandle.java:291)        at org.apache.bcel.verifier.structurals.ControlFlowGraph$InstructionContextImpl.execute(ControlFlowGraph.java:196)        at org.apache.bcel.verifier.structurals.Pass3bVerifier.circulationPump(Pass3bVerifier.java:206)        at org.apache.bcel.verifier.structurals.Pass3bVerifier.do_verify(Pass3bVerifier.java:360) I suspect BCEL-189 has to be fixed first. Yes, BCEL-189 has to be fixed first :-/];
BCEL-193;[BCEL-193] aastore instruction should not raise a verify error if an assignment compatiblity error is detected;Fixed;Closed;Unassigned;1421148764000;1425755564000;Bug;[BCEL-193.patch, BCEL-193.zip];[];[The following valid code raises a verify error: public class TestArrayAccess01 extends XTestArray01{    public static void test(){        XTestArray01[] array = new TestArrayAccess01[1].        array[0] = new XTestArray01().    }   }class XTestArray01 {} The code above will throw an ArrayStoreException at runtime but the generated bytecode is valid. The Java Virtual Machine Specification Second Edition is ambigous about this kind of issue. It states in §4.8.2 Structural Constraints (http://docs.oracle.com/javase/specs/jvms/se5.0/html/ClassFile.doc.html#9308): The type of every value stored into an array of type reference by an aastore instruction must be assignment compatible (§2.6.7) with the component type of the array. But in the aastore opcode description, there is no reference to any kind of linking or verification error. The assignment compatiblity error is a runtime exception. In the Java SE 7 Edition of _The Java Virtual Machine Specification, the §4 has been modified (http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.9.2): The type of every value stored into an array by an aastore instruction must be a reference type. The component type of the array being stored into by the aastore instruction must also be a reference type. The assignment compatibility check must not be done during the verification of the bytecode but during its execution.];[Attach patch with: Fix for BCEL-193 Test for BCEL-193 Attach zip with: Classfile for test for BCEL-193 Interesting, but isn't it a good thing that the verifier is able to catch more errors than strict spec compliance issues? I don't think so. If the classfile is compliant with the specification, the verifier must not reject it. The ArrayStoreException is not an error (java.lang.Error) and is a normal exception that can be caught by the application such as a NullPointerException or a ClassCastException. In §4.9 of The Java Virtual Machine Specification Second Edition states: It (the bytecode verifier) should certify all code generated by Sun's compiler for the Java programming language Here is the example defined in the ArrayStoreException javadoc: Object x[] = new String[3].x[0] = new Integer(0). If this code should be rejected by the verifier, then the following code defined in ClassCastException should also: Object x = new Integer(0).System.out.println((String)x). This kind of checks does not concern the verifier, they may be made by code analyzer such as PMD. I agree with Jérôme. Being too strict is just as much of a bug as not being strict enough. I'll review the patch over the weekend with a view to getting it applied. It would be better if some sort of source code - worst case a description of what they contain - was provided for the class files in the zip. Patch applied with only trivial whitespace changes. Many thanks. My comment re source information for the class files still stands but I'm happy to resolve this issue without it. (Worst case if we ever need to we can reverse engineer the class files).];
BCEL-194;[BCEL-194] LocalVariableGen hashCode() function is incorrrect.;Fixed;Closed;Unassigned;1423084100000;1423086865000;Bug;[LocalVariableGen.diff];[];[The BCEL API allows a user to change the location of a local variable. Thus, using 'index' as part of the hash function is incorrect.];[Fixed, thank you Mark.];
BCEL-195;[BCEL-195] addition of hashCode() to generic/Instruction.java breaks Targeters;Fixed;Closed;Unassigned;1423085698000;1465922576000;Bug;[compare.diff, select-init.diff];[];[Revision 1532198 added a hashCode() function to the Instruction class. Unfortunately, this breaks the Instruction targeting mechanism. I understand the goal of trying to reuse instructions - an 'iadd' is the same as any other 'iadd'. However, one 'goto 50' is not the same as another 'goto 50' due to the way Targeters are implemented. If branch instructions are reused, then only one entry gets put on the Targeter list. So when some api is used to modify the instruction list and location 50 becomes location 52 ONLY ONE of the branches gets updated. A very bad thing. So unless you modify the hash to special case branch instructions (and there might be other instructions needing special treatment as well) its broken. We fixed it by simply commenting the hash out to make things like they used to be and all works great.];[Do you think it would be possible to build a test case to secure this fix? I know, I know... Unfortunately, the simplest way for me would require you (or somebody on the team) to install Daikon. Otherwise, I not sure how to proceed. In any case, I would prefer to get all my issues on board first so you can see which make the 6.0 cut. Thank you your all your help. Mark Ok let me recap: InstructionHandler contains a Set of InstructionTarget. If the same targeter is added twice it's referenced only once The BranchInstruction hierarchy implements InstructionTarget and inherit the equals/hashCode methods from the base abstract Instruction class Before r1532198 the Instruction class defined the equals() method but not hashCode(). Thus two instructions that were equal didn't have the same hashcode. This was a violation of the equals/hashCode contract (equal objects must have the same hashcode). This flaw allowed two distinct but equal instances of a BranchInstruction to be listed as targeters of the same InstructionHandler, because the HashSet holding the targeters checks the hashcode before calling equals() to detect if it already contains the element. The addition of Instruction.hashCode() in r1532198 fixed this flaw but had the side effect of "merging" equal but different BranchInstructions in the set of targeters. The issue here is not Instruction.hashCode() which is correct, but the equals() implementation that is wrong. I agree with you that two GOTO 50 shouldn't be considered equal, it doesn't make sense for flow instructions. The question is, do we even need this equals() method? What is it really used for? I removed it and no test complained (but we have a poor coverage). I'm pondering if I should either remove it (instruction equality can still be checked with InstructionComparator) or just remove the code related to BranchInstruction from InstructionComparator. so you're suggesting I try turning Instruction.hashCode() back on and removing Instruction.equals() instead? I can try that with our test set. Does InstructionComparator.equals get used by the HashSet<InstructionTargeter>.add() method? If so, maybe the soulution is to change the (applicable part of) the code to                 } else if (i1 instanceof BranchInstruction) {                    return false.                } else if ............ Okay - thanks for the pointer to InstructionComparator. I have tested and prepared a new patch for this problem. Instruction.hash and Instruction.equal are left untouched. InstructionComparator is modified to always say two branch instructions are not equal. This fix exposed another problem in the order of initialization for Select instructions. A fix for that is included as well. Thank you Mark. Could you explain the issue with the Select initialization? Does it occur when Instruction.equals() is removed? I'd like to cover that with a test. I think it would not occur if there was no Instruction.equals as then InstructionComparator would no longer be called. The initialization order issue is hidden in the super call to BranchInstruction init which calls setTarget which calls notifyTarget which calls addTargeter which calls targeters.add which calls the java runtime for HashSet which leads back to Instruction.equals which calls InstructionComparator.equals which sees it has a Select and calls getTargets which returns null as the rest of the select instruction fields have not been set and t1.length goes boom I believe I never saw it before as we had the hash function commented out. You probably never saw it due to lack of code coverage. Given that (I believe) InstructionComparator is fixed, I think you want to leave in Instruction.equals so that the simple instructions do get cached. And after thinking about this some more to write this email - I'm wondering if InstructionComparator should always return false for Select as well? The odds of two identical switches located at different locations in the code is probably close to zero. Certainly never happens in our exhaustive test suite. What do you think? Mark Well, about 6 months later and we still haven't run into any problems with Select. So I'll answer my own question and say we should just go ahead with the change as proposed. Thanks. I have updated the diff file to be relative to the current trunk. It seems to me that having to delay setting the default target until the rest of the superclass has been built is a workround for a design issue. Constructors should not allow "this" to escape. There's another design problem which is that the setTarget() method is called from the ctor but is overrideable. This can lead to problems with subclasses. [Easy enough to fix this by extracting the code into a private method shared by ctor and setTarget() - or just duplicating the code in the ctor] I think the fact that all branch instructions have the same hash is a red herring. So long as one GOTO 50 compares equal with another GOTO 50, and does not compare equal with a GOTO 51, then it's possible to ensure that one, and only one, instance is added to the list. So I don't understand the comment However, one 'goto 50' is not the same as another 'goto 50' due to the way Targeters are implemented. As I see it, the problem here is that when two Instructions have the same hashcode, then the code needs to use the equals method to distinguish them, and the equals method needs data that has not yet been set up. Removing the definition of the hashCode does not solve this problem, it just makes it very unlikely to occur (because Object hashCode collisions are deliberately rare). An alternative solution would be to ensure that the hashCode for branches took account of the target somehow. Or at least allow non-variable instructions to be shared by keeping the existing hashcode method and overriding it with a call to System.identityHashCode() for variable instructions such as branches. This should be easy to test. I need to think about this some more. Maybe there is a problem with Targeters being confused about Instructions vs Instruction handles. After I get Daikon running again with the latest 'trunk' version of BCEL, I will look at this. Okay, I think I grok this now. In a sense, we were both correct. I think you are correct that you can share branches with the same target. but it didn't work properly due to problems in other code. My change to InstructionComparator (inadvertently) worked around these problems. There were two issues if you are going to share branch instructions: dispose cannot set the target to null because somebody else might be using it. you cannot allow duplicate targeters (interestingly, the 'fix' was in the code, but commented out) targeters.diff has these changes. Please review and see what you think. I have not had a chance to review the changes to Select.java. I will try to get that done tomorrow. InstructionHandle.addTargeter(t) currently has the code:         //if(!targeters.contains(t)) // (A)        targeters.add(t).            // (B) The patch proposes to enable (A) above. According to the Javadoc for HashSet, this should make no difference to the set, as it will only add the value if it is not already contained in it. So this code already prevents duplicate Targeters, at least in the Set contained in the InstructionHandle. Duplicate here means that the hashcodes are the same and the objects must compare equal. And of course equal objects must have equal hashcodes. (The reverse is not true) If either the hashcode or the equals() changes whilst an object is in a set, then the object may not be found. Now the hashcode is currently the opcode. One might think that the opcode was immutable once set up, but GOTO may change it to GOTO_W and similarly for other instructions (JSR => JSR_W, perhaps others). I think it's impossible to support changing an Instruction whilst it is in any kind of HASH set. If an Instruction can only be changed when it is not in a Hash, then of course the problem does not occur, but that may be tricky to do with the current design (and probably impossible to enforce). There are other sets that use equals() and not hashes, but they will be equally compromised by changes to the instruction - if the change does not affect the equals() method, then there's no point doing the change! [Later] however it does look like it might be possible to use something like TreeSet or ConcurrentArraySet, which only use equals(). I assume that the InstructionList is supposed to contain all distinct InstructionHandle instances (and the search uses == rather than equals) but I don't know how that is guaranteed. The way that IH instances are generated is rather convoluted once the ih_list cache has been initialised. One change which should help in debugging would be to ensure that the opcode and other mutable fields are only accessed via getter/setters. I will make a start on that. I have created a pull request (https://github.com/apache/commons-bcel/pull/2) which peripherally concerns this issue. A simple solution is remove equals/hashCode and create an InstructionFactory that will only reuse the immutable Instructions. All other Instructions would be newly created. Does anyone have data that shows reusing Immutable instructions has a significant impact on memory usage or execution time? I assume that the intention of re-using Instructions is partly to save space, but also so that BIs with the same target can be updated more easily, as only one instruction has to be changed. Though another way to do this is of course to move the IH to a different part of the list. Changing the design to require use of an Instruction Factory would probably require substantial changes to user code, so I think should be avoided unless absolutely essential. In which case, I would start again and make the Instructions immutable (I'm still not sure it's necessary to be able to change them). Likewise, I'm not sure the IH cache is a good idea. As to considerations of memory usage or time: we need to get the code working properly first. Which means we really need unit tests that properly represent a wide range of existing use cases. This problem is very complicated and there are a number of factors in play. One is that the objects in the HashSet of targeters are modified which violates the basic Set contract. BranchInstructions are added to the set with their target==null. Then the branch target is set with the correct value. This means that there are duplicates in the set if the target is branched to from more than one location. BUT, this turns out to be a good thing because you really do want a separate targeter for each branch so they can be modified independently of each other (more on this later). The problem arises when we replace a branch instruction and, hence, need to remove its targeter from the target set. Since all the branch instructions in the targeters set now compare equal, an arbitrary one is removed and is disposed. The correct solution (ignoring the whole issue of Factories for now) is that the targeter entries really should be the instruction handle of the branch source not the branch instruction itself. OR, and much simpler, we go back to my original solution of changing InstructionComparator to say that two branches are never equal. This works because when we dispose the branch instruction nothing happens BUT we set the target back to null. Then when we dispose the containing InstructionHandle it calls dispose on the instruction again and now it matches how it was originally added to the set and gets deleted. I understand this is nasty but I would really like to adopt this solution for now. I have used it for months and I know it works. I've spent two additional days on this issue and would really like to work on the other open items. Thank you. For the record: I tried replacing the HashSet used for InstructionHandle.targeters with a TreeSet. That fails, because the entries need to be Comparable. The tests work fine with CopyOnWriteArraySet. Using this would avoid the problematic hashCodes. However there is still the issue of equality in the case of mutable targeters. Is there a downside to making BIs unique (apart from the potential space/performance aspect)? Is it likely to affect the way people expect to be able to modify code? We really need some tests that exercise branch instruction replacement. Even a very basic one would be better than nothing. There is no space/performance hit because they were never unique. They are not defined in InstructionConstants so Instruction.readInstruction always creates a new instance for every branch instruction (among others). I guess I hadn't made that clear before. The only purpose of my change to InstructionComparator is to trick the current targeter design into working the way I think it should (via tricking HashSet). Daikon does branch instruction replacement all the time - but that would be the opposite of a very basic test case. OK, I see. Do both patches need to be applied still? But we really need some test code that can potentially expose the problem and test the new code. I realise that it's not possible to provide a copy of everything Daikon does, but even a single sample would help. Seems to me that there are at least two types of branch changes: changing one or more branch instructions to point to a new location changing the position of an Instruction handle within the list by adding/removing instructions earlier in the list I assume it is the first case that is causing problems. I can still repro the Select problem. I'm working on getting a small test case for that, but it might actually cover both pieces. Yes, it’s the first case. Only a problem if more than one branch targets the same location. If we try to move one of them, the targeter stuff gets confused and may change the wrong one. I've deleted both of the old patches and attached a new diff file. Same change to InstructionComparator, but a much cleaner fix to the Select problem. I'll try to create a test case tomorrow. test case. just add the following lines to some existing test InstructionList il = new InstructionList(). InstructionHandle ih = il.append(InstructionConstants.NOP). Instruction i1 = new TABLESWITCH(new int[0], new InstructionHandle[0], ih). Instruction i2 = new TABLESWITCH(new int[0], new InstructionHandle[0], ih). Without the Select fix, it will go boom. I can confirm the issue. This is definitely caused by accessing the class before it has been fully initialsed. Even initialising the targets field in the declaration does not help, as the getTargets() method is invoked before that has been done (and before the ctors). Just shows how bad it is to let the "this" reference escape during class construction. So my new patch only fixes a particular problem I noticed and my original patch fixes all but violates some coding guidelines? What do you recommend we do? I don't follow what you mean about coding guidelines. The new patch passes all tests including the test case you provided. However it is a work-round for the fact that the Select object is not properly constructed. So there may be other nasties that appear in the future. the behaviour may well change with updates to JVMs. So although it works now, it may not be a long-term solution. I never got a chance to try the original patch because I did not have a test case at the time. == I do now agree that trying to re-use branch instructions is a non-starter with the current design. So I wonder why the comparator still tries to compare Select instructions? Should it still try to compare them? I just checked, and always returning false for Selects also fixes the new test case - because it avoids calling getTargets(). Given that the behaviour of getTargets() is effectively undefined during Select construction, it would be safer not to try comparing them, even with the fix for the NPE. It would still be good to fix the construction issue however. There may be other use cases that fail or behave incorrectly because the Select object behaves in other unexpected ways. Having the comparator return false for both branch and select sounds fine. Then we can leave Select as is and close this out? ian.jira.plugin.system.issuetabpanels:all-tabpanel ] I still think the underlying construction sequence problem needs to be addressed at some point, but that can be raised as a separate issue. I've attached my original suggested fix to the constructor. I think it goes a long way towards making sure the select object is initialized before allowing 'this' to be used. Thanks very much. I tried the patch without the change to the comparator and without the getTargets() fix, and the test case passed. I created a new issue (BCEL-261) to track the problem as it is ongoing URL: http://svn.apache.org/r1698243 Log: BCEL-195 addition of hashCode() to generic/Instruction.java breaks Targeters. Never make distinct BranchInstructions compare equal Modified: commons/proper/bcel/trunk/src/changes/changes.xml commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/InstructionComparator.java commons/proper/bcel/trunk/src/test/java/org/apache/commons/bcel6/generic/InstructionHandleTestCase.java I thought better of the equality short-cut check (added as an afterthought). Although that check would make sense for ordinary HashSet usage, the conditions here are different. The test still passed, but I suspect it would cause problems. [We could still add the equality check after rejecting BIs] URL: http://svn.apache.org/r1698244 Log: BCEL-195 addition of hashCode() to generic/Instruction.java breaks Targeters. Never make BranchInstructions compare equal Revert short-cut equality check because that would allow a single BI to be shared. Modified: commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/InstructionComparator.java What remains to be done to close this issue? I'm not sure if there's anything left now. Seems to be fixed];
BCEL-196;[BCEL-196] why is Instruction.setOpcode private?;Won't Fix;Resolved;Unassigned;1423086091000;1425720977000;Bug;[instruction.diff];[];[Am I missing another way to modify an instruction opcode? Deleting and recreating does not appear to be a good alternative due to having to deal with target pointers.];[Each opcode has a dedicated sub-class. Changing the opCode would require changing the sub-class. I think I would have written this differently and tried to make opCode final. A quick look at the code suggests that this would be possible. I could refactor the code that way but I think there are more useful things I could be doing than implementing a refactoring that is more about style than it is substance. markro: what was your use case for changing the opcode? I guess you want to morph an instruction into another one without changing the targeters? Maybe we could provide some helper methods that swap an instruction with another one and modifies the targeters, but I agree with markt the opcode for a given instruction should not change. I must apologize for this request. Some time ago we used setOpcode to, for example, change an 'aload_1' to an 'aload_2'. Later we realized that just incrementing the index with setIndex was good enough, BCEL took care of the details. (well done) Unfortunately, we never undid our change to make setOpcode public and when I diffed our tree with yours this change was still there and I included it in my list. Long story short - go ahead and close this issue.];
BCEL-199;[BCEL-199] verifier does not handle merge of local variables with a superclass of type Object properly;Unresolved;Open;Unassigned;1423089559000;0;Bug;[bcel199.diff];[];[The current LocalVariables.merge() method does not check assignment compatiblity correctly for variables whose superclass is Object. This patch corrects this problem.];[I have updated the diff file to be relative to current trunk. Thanks. Is there a test case for this?];
BCEL-200;[BCEL-200] allow uninitialized types in PUTFIELD;Unresolved;Open;Unassigned;1423090484000;0;Bug;[bcel200.diff];[];[visitPUTFIELD needs to allow uninitialized types as this can occur within a constructor. This patch also improves the information content of a couple of error messages.];[This looks ok to me, according to the JVM spec §4.10.2.4: http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.10.2.4 The instance initialization method (§2.9) for class myClass sees the new uninitialized object as its this argument in local variable 0. Before that method invokes another instance initialization method of myClass or its direct superclass on this, the only operation the method can perform on this is assigning fields declared within myClass. Mark, do you think you could write a class exposing this case please? I will try to construct a test case.];
BCEL-202;[BCEL-202] StackMap[Table]Entry.copy() needs to be deep Improved support for StackMaps;Fixed;Closed;Unassigned;1423095004000;1440192790000;Bug;[stack-map.diff];[];[There are several ways a user can modify a Java class file that should cause BCEL to update the StackMaps automatically. Unfortunately, it does not. These additional methods at least allow users to take care of these issues for themselves. The patch also fixes a bug - StackMapTableEntry.copy() needs to be a deep copy to prevent StackMapTypes from being reused.];[Some more work needs to be done for allowing users to adjust a method's stack-map-table. Some entry-types have their offset-delta stored in the frame-type. Thus altering the offset-delta may need altering the frame-type, too. It can therefore not be final any more. I also suggest to rename the getEntryByteSize() method reduce its visibility to package-private as follows: StackMapTableEntry.java: int calculateLength() { if (frame_type >= Constants.SAME_FRAME && frame_type <= Constants.SAME_FRAME_MAX) { return 1. } else if (frame_type >= Constants.SAME_LOCALS_1_STACK_ITEM_FRAME && frame_type <= Constants.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) { return 1 + (types_of_stack_items[0].hasIndex() ? 3 : 1). } else if (frame_type == Constants.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) { return 3 + (types_of_stack_items[0].hasIndex() ? 3 : 1). } else if (frame_type >= Constants.CHOP_FRAME && frame_type <= Constants.CHOP_FRAME_MAX) { return 3. } else if (frame_type == Constants.SAME_FRAME_EXTENDED) { return 3. } else if (frame_type >= Constants.APPEND_FRAME && frame_type <= Constants.APPEND_FRAME_MAX) { int len = 3. for (int i = 0. i < types_of_locals.length. i++) { len += types_of_locals[i].hasIndex() ? 3 : 1. } return len. } else if (frame_type == Constants.FULL_FRAME) { int len = 7. for (int i = 0. i < types_of_locals.length. i++) { len += types_of_locals[i].hasIndex() ? 3 : 1. } for (int i = 0. i < types_of_stack_items.length. i++) { len += types_of_stack_items[i].hasIndex() ? 3 : 1. } return len. } else { /* Can't happen */ throw new ClassFormatException ("Invalid Stack map table tag: " + frame_type). } } Furthermore it might be necessary to completely replace a stack-map-entry with another element resulting in a different length of the whole stack-map-table. I do this as follows: StackMapTable.java public final void setStackMapTable( StackMapTableEntry[] map ) { this.map = map. int len = 2. for (int i = 0. i < map.length. i++) { len += map[i].calculateLength(). } setLength(len). } This enforces a slight change in one constructor by directly setting the map variable rather than calling setStackMapTable(...): public StackMapTable(int name_index, int length, StackMapTableEntry[] map, ConstantPool constant_pool) { super(Constants.ATTR_STACK_MAP_TABLE, name_index, length, constant_pool). this.map = map. } I just checked this out. There is no "number_of_locals" or "number_of_stack_items" field, but you constantly refer to them in getEntryByteSize() and copy(). Unless you're using a different branch 'cause I just used trunk. My diff was relative to 1651903. version 1664574 deleted these members Ah, that makes sense. In any case, just adding int number_of_locals = (types_of_locals == null) ? 0 : types_of_locals.length. and similar for number_of_stack_items to the beginning of those two methods seems to work just fine. Thank you so much for this .diff, by the way, it absolutely saved my Bachelor's thesis. I did notice, though, that the StackMapTable's "length" attribute is not recalculated based on the StackMapTableEntry instances contained within, so you have to manually set the StackMapTable's length before dumping it. That seems like a thing that BCEL should do automatically, but at least I now have the tools to correctly do that myself by using the getEntryByteSize() method. Okay, I have studied Daniel's comments and will be working on revised versions of StackMapTable and StackMapTableEntry today. Will advise as soon as I have tested with our Daikon tools that modify class files: Chicory and DynComp . I have removed the old diff file and attached a new one. These changes address/incorporate all of Daniel's comments. Pleas note that per BCEL-248 I have made my changes to StackMap.java and StackMapEntry.java NOT the newer versions (StackMapTable.java and StackMapTableEntry.java). I have attached another diff file to BCEL-248 that shows the changes necessary to delete the two latter files. I have modified our Daikon tools and tested them with these changes and all looks good. The patch changes the public constructor parameters. It would be better to keep the original one in case we can restore binary compat with 5.2. I will add it back in and deprecate it The setStackMap() method uses "int len = 2'." without explanation. What does that represent? [No need to update the patch. I can update the code directly] URL: http://svn.apache.org/r1696959 Log: BCEL-202 StackMapTableEntry.copy() needs to be deep. Improved support for StackMaps Modified: commons/proper/bcel/trunk/src/changes/changes.xml commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/StackMap.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/StackMapEntry.java The len=2 is accounting for the 'number_of_entries' field prior to the array of stack maps. I suppose you could put the number_of_locals and number_of_stack_items arguments back in the constructor with a comment that these items are now ignored and the lengths are derived from the matching array arguments.];
BCEL-203;[BCEL-203] Incorrect return types in Runtime...ParameterAnnotations;Fixed;Closed;Unassigned;1423146741000;1423147713000;Bug;[parameterannotations.diff];[];[Maybe a cut and paste error?];[I don't know but that doesn't make any difference, the same method is called and the same result is returned with the patch or not. I moved the copy() method to the ParameterAnnotations class and changed the cast type.];
BCEL-206;[BCEL-206] special case arguments to embedded, anonymous <init> methods;Won't Fix;Resolved;Unassigned;1423153002000;1439491794000;Bug;[methodgen2.diff];[];[For some reason, the Java compiler does not generate local variables for arguments to embedded, anonymous <init> methods. This ensures they are included in the LocalVariableGen.];[In rare cases my proposed change can loose the correct variable names. I have devised a better solution in the host application (Chicory from the Daikon toolset). This item should be closed 'Invalid' or 'Won't Fix' or some such. Thank you.];
BCEL-207;[BCEL-207] RemoveLocalVariable(s) doesn't remove the associated Targetters.;Fixed;Closed;Unassigned;1423153437000;1424444023000;Bug;[methodgen3.diff];[];[RemoveLocalVariable(s) doesn't remove the associated Targetters.];[What about adding a dispose() method in LocalVariableGen performing this cleanup and also clearing the handlers defining the scope? Thus removing a local variable would make it ready to be reused elsewhere, if ever that could make sense. I'm sorry, I don't follow you - how does that fix the removeLocalVariable problem? If you don't delete the targeters and try to reuse the localVariable it would have to have the exact same live range as the previous one. But before that problem, I think you run into null pointer issues with the method's StackMap. Actually the dispose() method would call notifyTarget, and removeLocalVariable would call dispose(). This avoids repeating the notifyTarget in two methods for the same purpose. oh, I see - you are talking about re-factoring the code. In that case, why not just have removeLocalVariables call removeLocalVariable within the loop instead of the notifyTarget(s). Originially, I was worried about the performance of n variable_vec.remove(s) versus a single variable_vec.clear - but I suspect that in the vast majority of cases the number of locals would be fairly small. This is now fixed on the trunk and I added a test case. Thank you Mark. The dispose() change causes a problem with my existing code. But I believe the real issue is the whole shallow vs deep copy thing. MethodGen.getLocalVariables() returns a shallow copy. My client code wants to rebuild the LocalVarableTable. So it calls getLocalVariables to get a copy of the old table and then calls removeLocalVariables to prepare for creating the new table. But, of course, the new table is a variation of the old so you need to copy some of the items from the old to the new table. There is/was a subtle assumption that getLocalVariables returned a deep copy in order to do this properly. It turned out even though the copy was shollow, it worked okay, because removeLocalVariables() didn't really remove anything, just reset the Targeters. Now dispose really removes things so we have trouble. I'm not suggesting we remove the dispose stuff. I would like to discuss just what we mean by a method called getFoo(). Does it return a shallow or deep copy of the Foo object? I think I am arguing that it should be deep. This issue gets even messier because some BCEL objects override clone() and some don't. And some have a copy() method (which I assume is always deep?) and some don't. (oh boy, now I'm wondering if I should have sent this to the commons list instead.) Well. as usual, it's more complicated than that. Turns out sometimes we want getFoo() to be shallow so we can modify the Foo object and sometimes we want getFoo() to be deep so we can create a new Foo from the copy. So now I'm thinking getFoo() should be shallow, and the user needs to say getFoo().copy() if he wants deep? What do you think? (Of course, very few of the BCEL objects have a copy() method....)];
BCEL-208;[BCEL-208] Need to check for an empty InstructionList;Fixed;Closed;Unassigned;1423153714000;1439500985000;Bug;[b208.diff];[];[A couple of methods in MethodGen.java needed to test for an empty InstructionList.];[Under what condition the InstructionList could be null? Is it possible to write a test to check this case? Well, several of your existing test cases create methods with a null InstructionList. By design, the BCEL API covers just about every facet of reading or writing a Java class file. It's not hard to imagine users calling the various methods in unexpected (and incorrect) orders. In the process of studying this example in more detail I found that one of the patches was not needed and an additional patch was needed elsewhere. I have attached a new diff file with the revised patch and a test case that demonstrates the problem. The b208.diff file I attached last month has a test case. Mark URL: http://svn.apache.org/r1695781 Log: BCEL-208 Need to check for an empty InstructionList Added: commons/proper/bcel/trunk/src/test/java/org/apache/commons/bcel6/PLSETestCase.java (with props) commons/proper/bcel/trunk/src/test/java/org/apache/commons/bcel6/data/PLSETestClass.java (with props) Modified: commons/proper/bcel/trunk/src/changes/changes.xml commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/LocalVariableGen.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/MethodGen.java URL: http://svn.apache.org/r1695782 Log: Oops Modified: commons/proper/bcel/trunk/src/changes/changes.xml];
BCEL-209;[BCEL-209] Bug fixes and improvements to InvokeDynamic and BootStrapMethods implementation;Fixed;Closed;Charles Honton;1423160951000;1437340283000;Bug;[counter.diff, invoke4.diff];[];[(Apologies in advance - this is a very large diff.) During the past year, both the Apache Commons BCEL team and our group here at the UW independently completed the support for InvokeDynamic . Some things we chose to do the same way, but there are a few items that are quite different. Trying not to be too biased, I believe our method is better. One of the larger differences is your decision to add the abstract class NameSignatureMethod between FieldOrMethod and CPInstruction and then have InvokeDynamic extend from that instead of from InvokeInstruction. To me this seems wrong. In addition to forcing InvokeDynamic to duplicate all the methods from InvokeInstruction and FieldOrMethod, it is awkward that it is the only form of the Invoke Instruction that doesn't derive from InvokeInstruction. This patch also includes several methods missing from the current implementation: alternative initializers, toString, and support for the Visitor paradigm. There are bug fixes to Constants.java and InstructionFinder.java as well.];[These changes cause the CounterVisitor test case to fail. I have attached a patch to update this test case. These changes also cause Class2HTMLTestCase to fail. The fixes are in classfile/ConstantPool.java and util/CodeHTML.java. I have updated the patch to reflect these changes. Note that I removed invoke3.diff and added invoke4.diff. This change would fix the issue reported in https://issues.apache.org/jira/browse/BCEL-213. invokedynamic support for InstructionFinder. InstructionFinder doesn't currently know about invokedynamic and is unable to match it. If we change INVOKEDYNAMIC to extend InvokeInstruction, what should be the value returned by getReferenceType()? null, java.lang.Object or an exception? AspectJ maintains a fork of BCEL where invokedynamic has also been implemented as a subclass of InvokeInstruction. And getReferenceType() throws an IllegalStateException: http://git.eclipse.org/c/aspectj/org.aspectj.git/tree/bcel-builder/src/org/aspectj/apache/bcel/generic/InvokeDynamic.java haven't really tested it, but the approach seems fine to me. Mark, why adding num_bootstrap_arguments to BootstrapMethod? The number of arguments could be retrieved with getBootstrapArguments().length, and there is no need to keep in sync num_bootstrap_arguments with the actual number of elements in bootstrap_arguments. I guess I was reflecting the fact that this field is in the class file format. Also, if you don't make it a member of BootStrapMethod, it makes it a little messier to write the three different constructors. I like the recursive call to the 'basic' constructor. But you could certainly code it the way you describe if you wish. Are there any other questions before we can commit this code? Committed revision 1691855. It's still possible to keep the recursive call - just ensure the array is set up in the common ctor. URL: http://svn.apache.org/r1697916 Log: Follow-up to BCEL-209 Drop the field num_bootstrap_arguments it is not necessary, and was not kept in sync if the arguments were updated Modified: commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/BootstrapMethod.java Oops! URL: http://svn.apache.org/r1697925 Log: Follow-up to BCEL-209 Drop the field num_bootstrap_arguments it is not necessary, and was not kept in sync if the arguments were updated Oops - incomplete fix, now working Modified: commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/BootstrapMethod.java Modified: commons/proper/bce];
BCEL-216;[BCEL-216] Allow creation of class object constants;Unresolved;Open;Unassigned;1428394881000;0;Bug;[];[];[Accessing class objects (e.g. String.class) gets BCELified as new PUSH(_cp, new ObjectType("java.lang.String")) which works fine. Trying to create such a constant using Factory.createConstant throws a ClassGenException, however: _factory.createConstant(new ObjectType("java.lang.String"))];[];
BCEL-217;[BCEL-217] long type instructions are not searched by InstructionFinder using regular expression;Fixed;Closed;Unassigned;1429301654000;1439495521000;Bug;[INSTRUCTIONFINDER-LONGTYPE.patch];[];[InstructionFinder initialises the pattern map by precompiling variations of type-specific instructions such as lload_0, lload_1, etc. Currently, long type instructions are missing from the pattern map. Consequently, you cannot use InstructionFinder and regular expression to search for long type instructions. Also, this means that lload instruction is not returned when searching for LoadInstruction.];[Patch prepares the pattern map to include load and store instructions for long type. URL: http://svn.apache.org/r1695767 Log: BCEL-217 long type instructions are not searched by InstructionFinder using regular expression Modified: commons/proper/bcel/trunk/src/changes/changes.xml commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/util/InstructionFinder.java];
BCEL-219;[BCEL-219] Make org.apache.bcel.classfile.ConstantPool.ConstantPool(DataInput) public;Fixed;Closed;Gary D. Gregory;1437751591000;1440056913000;Bug;[];[];[Make org.apache.bcel.classfile.ConstantPool.ConstantPool(DataInput) public. See https://github.com/apache/commons-bcel/pull/1];[RL: http://svn.apache.org/r1692539 Log: BCEL-219 Make org.apache.bcel.classfile.ConstantPool.ConstantPool(DataInput) public. Modified: commons/proper/bcel/trunk/src/changes/changes.xml commons/proper/bcel/trunk/src/main/java/org/apache/bcel/classfile/ConstantPool.java];
BCEL-221;[BCEL-221] BCELifier is not working for Java8Example;Unresolved;Open;Unassigned;1437887763000;0;Bug;[];[];[org.apache.bcel.util.BCELifier Java8Example fails: Exception in thread "main" org.apache.bcel.classfile.ClassFormatException: Constant pool at index 0 is null. at org.apache.bcel.classfile.ConstantPool.getConstant(ConstantPool.java:259) at org.apache.bcel.classfile.ConstantPool.getConstantString(ConstantPool.java:294) at org.apache.bcel.generic.FieldOrMethod.getClassName(FieldOrMethod.java:89) at org.apache.bcel.util.BCELFactory.visitInvokeInstruction(BCELFactory.java:162) at org.apache.bcel.generic.INVOKEDYNAMIC.accept(INVOKEDYNAMIC.java:117) at org.apache.bcel.util.BCELFactory.start(BCELFactory.java:101) at org.apache.bcel.util.BCELifier.visitMethod(BCELifier.java:181) at org.apache.bcel.classfile.Method.accept(Method.java:106) at org.apache.bcel.util.BCELifier.visitJavaClass(BCELifier.java:120) at org.apache.bcel.util.BCELifier.start(BCELifier.java:69) at org.apache.bcel.util.BCELifier.main(BCELifier.java:270)];[I can confirm this. There is a comment in the ctor ConstantPool(DataInput input) which says: /* constant_pool[0] is unused by the compiler and may be used freely by the implementation. */ However CONSTANT_InvokeDynamic appears to create itself with index 0. looks like it is reading the class file incorrectly. https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.10 defines the second attribute of CONSTANT_InvokeDynamic_info to be bootstrap_method_attr_index (an index into the bootstrap_methods array of the bootstrap method table) I suspect we're using bootstrap_method_attr_index as an index into constant pool. Yes, the ID class is a currently a subclass of ConstantCP which was originally for the Fieldref, Methodref, InterfaceMethodref constants That does not work properly. ID has 2 parameters but they are not class_index and name_and_type_index as ConstantCP expects. They are bootstrap_method_attr_index and name_and_type_index instead, and the former is 0-based unlike class_index which is why the crash occurs It looks like the intention in BCEL-209 was to share code, but the InvokeDynamic instruction is not really compatible I applied a fix which seems to work. not sure if it's correct. Need more unit tests. URL: http://svn.apache.org/r1702447 Log: BCEL-221 BCELifier is not working for Java8Example Workround for crash. may need further work Modified: commons/proper/bcel/trunk/src/changes/changes.xml commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/INVOKEDYNAMIC.java commons/proper/bcel/trunk/src/test/java/org/apache/commons/bcel6/util/BCELifierTestCase.java Definitely needs further work - the generated code is wrong for InvokeDynamic - e.g. it does not create the correct CP and bootstrap entries.];
BCEL-225;[BCEL-225] Add clirr report to build;Won't Fix;Closed;Charles Honton;1439214515000;1439269024000;Bug;[];[];[We need clirr report in site to prove no regressions.];[Exceedingly difficult to produce CLIRR when package names have changed. I have produced a CLIRR comparing 5.2 with 6.0 RC3 showing 12 errors and 1 warning. (https://people.apache.org/~chas/bcel-6.0-RC3/clirr-report.html will be available for a while) We do need package name change.];
BCEL-226;[BCEL-226] FIx RAT messages;Fixed;Closed;Charles Honton;1439214580000;1439270380000;Bug;[];[];[Several files missing apache license.];[];
BCEL-227;[BCEL-227] @author tags should be removed.;Fixed;Closed;Charles Honton;1439214624000;1439270804000;Bug;[];[];[Remove @author tags from source files];[Note that @author tags need to be replaced with a mention in the pom (unless the author agrees to a total removal). Most of the removed entries were already in the pom. added the missing ones here: URL: http://svn.apache.org/r1695470 Log: BCEL-227 replace @author tags with mention in pom Modified: commons/proper/bcel/trunk/pom.xml URL: http://svn.apache.org/r1695471 Log: Oops - inadvertent revert of recent change Modified: commons/proper/bcel/trunk/pom.xml];
BCEL-228;[BCEL-228] Findbugs issues;Unresolved;Open;Unassigned;1439214718000;0;Bug;[];[];[Fix findbugs issues. The fixable issues may be dependent upon whether BC is broken.];[Work in progress - not for 6.0.];
BCEL-229;[BCEL-229] Checkstyle issues;Unresolved;Open;Unassigned;1439214752000;0;Bug;[];[];[Fix checkstyle issues. The fixable issues may be dependent upon whether BC is broken.];[Have started fixing issues. There were several thousand initially, so most of the checks have been temporarily disabled. They can be gradually re-enabled and fixed. Not for 6.0];
BCEL-231;[BCEL-231] Remove deprecated methods and classes;Unresolved;Reopened;Unassigned;1439215094000;0;Bug;[];[];[As this is a major release, deprecated methods and classes should be removed.];[URL: http://svn.apache.org/r1695473 Log: BCEL-231 Remove deprecated methods and classes Part 1 (of several) Modified: commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/Attribute.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/ReferenceType.java URL: http://svn.apache.org/r1695478 Log: BCEL-231 Remove deprecated methods and classes Part 2 (of several) Removed: commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/AttributeReader.java Modified: commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/Attribute.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/FieldOrMethod.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/StackMapEntry.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/Instruction.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/ReferenceType.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/util/ClassPath.java URL: http://svn.apache.org/r1695427 Log: BCEL-236: remove deprecated Constants Modified: commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/Constants.java URL: http://svn.apache.org/r1695426 Log: BCEL-236: remove deprecated ASCII_CharStream methods Modified: commons/proper/bcel/trunk/src/examples/Mini/ASCII_CharStream.java URL: http://svn.apache.org/r1695425 Log: BCEL-236: remove deprecated FieldOrMethod.getClassType(ConConstantPoolGen) Modified: commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/FieldOrMethod.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/verifier/statics/Pass3aVerifier.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/verifier/structurals/InstConstraintVisitor.java URL: http://svn.apache.org/r1695422 Log: BCEL-236 remove deprecated ClassVector Removed: commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/util/ClassVector.java URL: http://svn.apache.org/r1695481 Log: BCEL-231 Remove deprecated methods and classes (continued...) Modified: commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/ObjectType.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/verifier/structurals/InstConstraintVisitor.java r1695642 | chas | 2015-08-12 18:36:31 -0700 (Wed, 12 Aug 2015) | 2 lines Changed paths: M /commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/LocalVariableTable.java M /commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/Utility.java URL: http://svn.apache.org/r1695789 Log: BCEL-231 Remove deprecated methods and classes Modified: commons/proper/bcel/trunk/src/changes/changes.xml commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/ConstantUtf8.java Mostly reverted];
BCEL-232;[BCEL-232] Make mutable fields private.;Won't Fix;Resolved;Unassigned;1439215191000;1439893215000;Bug;[];[];[As this is a major release and backward compatibility is not an issue, make fields private.];[URL: http://svn.apache.org/r1695518 Log: BCEL-232 Make mutable fields private. Modified: commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/Attribute.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/Constant.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/ConstantCP.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/ElementValue.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/FieldOrMethod.java URL: http://svn.apache.org/r1695519 Log: BCEL-232 Make mutable fields private. Modified: commons/proper/bcel/trunk/src/changes/changes.xml URL: http://svn.apache.org/r1695618 Log: BCEL-232 Make mutable fields private. Modified: commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/BranchHandle.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/BranchInstruction.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/GOTO.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/GOTO_W.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/IFEQ.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/IFGE.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/IFGT.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/IFLE.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/IFLT.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/IFNE.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/IFNONNULL.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/IFNULL.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/IF_ACMPEQ.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/IF_ACMPNE.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/IF_ICMPEQ.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/IF_ICMPGE.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/IF_ICMPGT.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/IF_ICMPLE.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/IF_ICMPLT.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/IF_ICMPNE.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/InstructionComparator.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/InstructionList.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/JSR.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/JSR_W.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/JsrInstruction.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/Select.java URL: http://svn.apache.org/r1695624 Log: BCEL-232 Make mutable fields private. Modified: commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/ArrayType.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/BasicType.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/Type.java URL: http://svn.apache.org/r1695625 Log: BCEL-232 Make mutable fields private. Modified: commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/CPInstruction.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/ConstantPoolGen.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/FieldInstruction.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/FieldOrMethod.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/INVOKEDYNAMIC.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/INVOKEINTERFACE.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/InvokeInstruction.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/LDC.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/LDC2_W.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/MULTIANEWARRAY.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/NameSignatureInstruction.java URL: http://svn.apache.org/r1695627 Log: BCEL-232 Make mutable fields private. Modified: commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/AnnotationElementValueGen.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/ArrayElementValueGen.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/ClassElementValueGen.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/ElementValueGen.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/EnumElementValueGen.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/SimpleElementValueGen.java The above changes were premature. revert for now. It may still be possible to privatise mutable fields later, but this should be done separately from removing apparently unused setters. URL: http://svn.apache.org/r1696385 Log: Revert most of BCEL-232 Re-instate "unused" setters. revert protections on mutable fields for now. Modified: commons/proper/bcel/trunk/src/changes/changes.xml commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/Attribute.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/Constant.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/ConstantCP.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/ElementValue.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/FieldOrMethod.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/AnnotationElementValueGen.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/ArrayElementValueGen.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/ArrayType.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/BranchInstruction.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/CPInstruction.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/ClassElementValueGen.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/ConstantPoolGen.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/ElementValueGen.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/EnumElementValueGen.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/Instruction.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/InstructionComparator.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/LDC.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/SimpleElementValueGen.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/Type.java];
BCEL-234;[BCEL-234] Code must not swallow Throwable;Fixed;Closed;Unassigned;1439223597000;1439376964000;Bug;[];[];[Code should never catch and ignore all Throwables - at least ThreadDeath and VirtualMachineError must be rethrown. EIther check for these specifically, and rethrow them, or else replace the generic catch blocks with ones specific to the try block. This issue applies to: ClassLoader NativeVerifier VerifyDialog];[URL: http://svn.apache.org/r1695472 Log: BCEL-234 Code must not swallow Throwable Modified: commons/proper/bcel/trunk/src/changes/changes.xml commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/util/ClassLoader.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/verifier/NativeVerifier.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/verifier/VerifyDialog.java];
BCEL-237;[BCEL-237] non-empty final arrays should be private as they are mutable;Fixed;Closed;Unassigned;1439380816000;1466261433000;Bug;[];[];[Final array elements are not themselves final. So any final arrays should always be private, otherwise external code can corrupt the entries accidentally or deliberately. Either the array can be accessed through a getter that clones the contents, or the entries can be accessed through a getter that returns a single entry. This issue affects: Constants.class: CONSTANT_NAMES ACCESS_NAMES INTERFACES_IMPLEMENTED_BY_ARRAYS TYPE_NAMES CLASS_TYPE_NAMES SHORT_TYPE_NAMES NO_OF_OPERANDS TYPE_OF_OPERANDS OPCODE_NAMES CONSUME_STACK PRODUCE_STACK ATTRIBUTE_NAMES ITEM_NAMES METHODHANDLE_NAMES];[Also ExceptionConstants I have started to work on an enum to replace most of the constants defined in arrays. There are a couple of design concerns: 1. It''s difficult to determine which constants are expected to be used as part of BCEL's interface and which constants are purely implementation detail. What clues will we use to determine what was expected to be externally available? 2. Replacing constants with enums breaks source compatibility as well as binary compatibility. Do we deprecate the constant and implement in terms of the enum. Or, do we just remove the constants? Fixed InstructionConstants: URL: http://svn.apache.org/r1695590 Log: BCEL-237 non-empty final arrays should be private as they are mutable Modified: commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/Instruction.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/InstructionConstants.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/PUSH.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/util/BCELFactory.java Fixed ExceptionConstants URL: http://svn.apache.org/r1695594 Log: BCEL-237 non-empty final arrays should be private as they are mutable Modified: commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/ExceptionConstants.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/ANEWARRAY.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/ArrayInstruction.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/CHECKCAST.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/GETFIELD.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/GETSTATIC.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/INSTANCEOF.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/INVOKEDYNAMIC.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/INVOKEINTERFACE.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/INVOKESPECIAL.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/INVOKESTATIC.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/INVOKEVIRTUAL.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/LDC.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/MULTIANEWARRAY.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/NEW.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/PUTFIELD.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/PUTSTATIC.java 1) The constants which are defined in the JLS are presumably part of the API. Constants invented for use in BCEL are presumably almost all internal, and should be enums. 2) We should not release the code with any deprecations. Looks like this has already been fixed. Closing as fixed. It was not fixed. the code was reverted as part of reverting some non-compatible changes Sorry, it was fixed, it's just that the original class was kept for compatibility (but deprecated) However the BCEL code does not use the original class any more (it uses Const), so it does not really matter if user code mutates any of the arrays.];
BCEL-238;[BCEL-238] Getters/setters for array should use clone;Unresolved;Open;Unassigned;1439381127000;0;Bug;[];[];[Further to BCEL-237, if a getter returns a reference to a private final array, then the array contents can be corrupted. Similarly if a setter stores an array reference without cloning it, then any holders of the original reference can subsequently change the array entries.];[Should method contracts be changed to use Lists or Collections? That would be OK by me, but is a bigger change. Cloning the arrays is a simple fix, and Lists etc inherently use more memory. In any case, any setters might need to clone the input list in order to protect it against subsequent external changes. Cloning can be implemented after 6.0. It's not needed for Constants ( BCEL-237) as that has been deprecated and is no longer used. If there are any other getters/setters that use arrays without cloning, these should be fixed at some point.];
BCEL-239;[BCEL-239] Interfaces should not be used to define constants;Fixed;Closed;Unassigned;1439381667000;1439393454000;Bug;[];[];[Interfaces should not be used to define constants. This is often done as a way to save typing the name of a class that defines the constants. However using an interface pollutes any implementing classes with all the constant names, even if they are not used. This issue applies to Constants ExceptionConstants InstructionConstants];[Note: I've just checked, and code can update entries in a final array defined in an interface. URL: http://svn.apache.org/r1695495 Log: BCEL-239 Interfaces should not be used to define constants Convert ExceptionConstants to class (it was not implemented anywhere) Modified: commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/ExceptionConstants.java URL: http://svn.apache.org/r1695546 Log: BCEL-239 Interfaces should not be used to define constants Convert InstructionConstants to a class Modified: commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/InstructionConstants.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/InstructionFactory.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/PUSH.java URL: http://svn.apache.org/r1695556 Log: BCEL-239 Interfaces should not be used to define constants Modified: commons/proper/bcel/trunk/src/changes/changes.xml commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/Constants.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/AnnotationEntry.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/CodeException.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/LocalVariable.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/ParameterAnnotationEntry.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/util/AttributeHTML.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/util/Class2HTML.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/util/CodeHTML.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/util/ConstantHTML.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/util/MethodHTML.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/verifier/statics/Pass2Verifier.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/verifier/structurals/UninitializedObjectType.java commons/proper/bcel/trunk/src/test/java/org/apache/commons/bcel6/verifier/tests/TestArrayAccess02Creator.java commons/proper/bcel/trunk/src/test/java/org/apache/commons/bcel6/verifier/tests/TestArrayAccess03Creator.java commons/proper/bcel/trunk/src/test/java/org/apache/commons/bcel6/verifier/tests/TestArrayAccess04Creator.java commons/proper/bcel/trunk/src/test/java/org/apache/commons/bcel6/verifier/tests/TestReturn01Creator.java commons/proper/bcel/trunk/src/test/java/org/apache/commons/bcel6/verifier/tests/TestReturn03Creator.java];
BCEL-241;[BCEL-241] ExceptionThrower#getException() is not tested;Unresolved;Open;Unassigned;1439399796000;0;Bug;[];[];[There don't appear to be any tests that exercise ExceptionThrower#getException() and the method does not appear to be invoked anywhere in the code. These tests need to be created];[];
BCEL-243;[BCEL-243] Type.getType() needs to understand TypeVariableSignature(s);Fixed;Closed;Sebb;1439485848000;1467477300000;Bug;[b243test.txt, type.diff];[];[Correct Type.getType() to use the updated Type support added as part of BCEL-197.];[Is there a test case for this? This shows up with jdk8. I've been testing all the recent changes with jdk7. I will be testing with jdk8 soon and should be able to provide a test case. Just tried "mvn clean test" on MacOSX with java version "1.8.0_45" Java(TM) SE Runtime Environment (build 1.8.0_45-b14) Does not fail for me. This issue is we run our tools over every member of the java rt.jar. The jdk8 version has extensive use of generics not present in the jdk7 version. I'm pretty sure it will fail and I can produce a reduced test case. Doesn't the PerformanceTest do this anyway? I see the following output: parsing /Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home/jre/lib/rt.jar ClassParser.parse: 0.544061941 s ClassGen.init: 0.359797973 s MethodGen.init: 1.176918051 s MethodGen.getMethod: 1.065771658 s ClassGen.getJavaClass.getBytes: 0.558252155 s Total: 4.008984552 s The test calls quite a few different methods, including ClassParser.parse(), but maybe there are others that need exercising to find issues. I have attached a test snippet that demonstrates the problem. In general, BCEL has not been updated to fully support generics. There is a basic flaw throughout the code base that assumes a Java 'descriptor' and a Java 'signature' are the same thing. Kinda sorta true before generics, but definitely wrong now. In the process of working on this example I found two more places that are incorrect, no doubt there are many more. [for the record: the constructor for generic.ObjectType and classfile.Signature.translate()] I'm not proposing we fix this larger problem for 6.0, but it should be noted as a significant work item for the future. URL: http://svn.apache.org/viewvc?rev=1748444&view=rev Log: BCEL-243 Type.getType() needs to understand TypeVariableSignature(s) Added: commons/proper/bcel/trunk/src/test/java/org/apache/bcel/generic/TypeTestCase.java (with props) Modified: commons/proper/bcel/trunk/src/changes/changes.xml commons/proper/bcel/trunk/src/main/java/org/apache/bcel/generic/Type.java];
BCEL-245;[BCEL-245] Type class includes constants that reference subclasses;Fixed;Closed;Unassigned;1439493547000;1440369427000;Bug;[];[];[FindBugs notes that the Type class tries to use the ObjectType class before it has been initialised: public static final BasicType CHAR = new BasicType(Constants.T_CHAR).public static final ObjectType OBJECT = ObjectType.getInstance("java.lang.Object"). Now both BasicType and ObjectType are sub-classes of Type. However FindBugs only complains about the ObjectType call. Perhaps this is because it uses a static method? The getInstance() method could be replaced with the equivalent: public static final ObjectType OBJECT = new ObjectType("java.lang.Object"). But why does FindBugs not complain about the other references? Surely BasicType cannot be constructed until Type has been constructed? It's not (yet) clear what is going on here...];[Findbugs seems to be happy with the following fix: URL: http://svn.apache.org/r1697218 Log: BCEL-245 FindBugs: class may not have been constructed warning when using getInstance Modified: commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/Type.java URL: http://svn.apache.org/r1697271 Log: BCEL-245 Type class includes constants that reference subclasses Modified: commons/proper/bcel/trunk/src/changes/changes.xml];
BCEL-246;[BCEL-246] Confusing to have two classes named Repository;Unresolved;Open;Unassigned;1439716525000;0;Bug;[];[];[There are two classes named Repository: org.apache.commons.bcel6.Repository org.apache.commons.bcel6.util.Repository This is confusing, especially as the first needs to use the second.];[];
BCEL-247;[BCEL-247] Confusing to have two interfaces named Visitor both with EmptyVisitor implementations;Unresolved;Open;Unassigned;1439719972000;0;Bug;[];[];[It's confusing to use the same name in different packages: org.apache.commons.bcel6.generic.Visitor org.apache.commons.bcel6.classfile.Visitor org.apache.commons.bcel6.generic.EmptyVisitor org.apache.commons.bcel6.classfile.EmptyVisitor];[];
BCEL-249;[BCEL-249] Check for max Short seems wrong;Fixed;Closed;Unassigned;1440026566000;1440073230000;Bug;[];[];[There are some checks for the max value that will fit in a short. These are of the form: if (Math.abs(value) >= 32767) This seems wrong, as Short.MAX_VALUE = 32767, so the check should be if (Math.abs(value) > 32767) There's a further problem, which is that Short.MIN_VALUE = -32768. This will be disallowed, unless the condition is written as: if ((value >= -32768) && (value <= 32767)) This is how the ctor generic.PUSH.PUSH(ConstantPoolGen cp, int value) does the check.];[URL: http://svn.apache.org/r1696777 Log: BCEL-249 Check for max Short seems wrong Modified: commons/proper/bcel/trunk/src/changes/changes.xml commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/BranchInstruction.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/GOTO.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/Instruction.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/JSR.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/PUSH.java];
BCEL-250;[BCEL-250] InstructionConstants are mutable;Unresolved;Open;Unassigned;1440067569000;0;Bug;[];[];[The InstructionConstants fields are all final. However unfortunately the objects themselves are mutable, because the Instruction class is mutable. This means that it is quite easy to corrupt the fields accidentally or deliberately.];[];
BCEL-251;[BCEL-251] Pass3aVerifier visitANEWARRAY() does not allow 255 array dimensions;Fixed;Resolved;Unassigned;1440156035000;1440369060000;Bug;[];[];[The visitANEWARRAY() method performs the following check: if (dimensions >= 255){    constraintViolated(o, "Not allowed to create an array with more than 255 dimensions.").} That is clearly wrong. it should allow 255 as per the constraint message];[Also there are no tests for the method at all, AFAICT URL: http://svn.apache.org/r1696944 Log: BCEL-251 Pass3aVerifier visitANEWARRAY() does not allow 255 array dimensions Modified: commons/proper/bcel/trunk/src/changes/changes.xml commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/Constants.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/verifier/statics/Pass3aVerifier.java TODO - TESTS Raise separate issue for unit tests];
BCEL-252;[BCEL-252] Messy coding in Class2HTML and helper classes;Unresolved;Open;Unassigned;1440172742000;0;Bug;[];[];[The class Class2HTML has several package-protected helper classes: AttributeHTML CodeHTML ConstantHTML MethodHTML The helper classes make reference to static methods in Class2HTML which means that several fields need to be static. Ideally needs a redesign...];[];
BCEL-253;[BCEL-253] Pass 3b verifier is too strict.;Fixed;Closed;Unassigned;1440181004000;1440368904000;Bug;[];[];[Quoting from src/main/java/org/apache/commons/bcel6/verifier/structurals/Subroutines.java: JustIce also mandates subroutines not to be protected by exception handling code (for the sake of control flow predictability). This is too strict. Several methods in the jdk contain this construct and hence fail to verify. (javax/management/remote/rmi/_RMIServer_Stub.class is one such example.) The lines at 479-496 need to be removed or modified is some way to allow a BCEL based tool to process all of the JDK.];[I can reproduce the issue by using the Verifier class. Dropping the check entirely seems wrong. maybe add a new constructor to allow the check to be omitted? [BTW, the code is now at 482-299] Alternatively, would it make sense to log a warning instead? The way we get started is with a new ControlFlowGraph. So if that constructor had an optional flag to say ignore this case - that would be great. URL: http://svn.apache.org/r1697224 Log: BCEL-253 Pass 3b verifier is too strict. Modified: commons/proper/bcel/trunk/src/changes/changes.xml commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/verifier/structurals/ControlFlowGraph.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/verifier/structurals/Subroutines.java];
BCEL-254;[BCEL-254] Two more methods that would be nice to be public.;Fixed;Closed;Unassigned;1440182931000;1440445744000;Bug;[bcelifier.diff, dumpClass.java];[];[As a 'proof of concept' I wrote a version of javap using BCEL.jar. It worked well, except for two items: classfile.Constant.readConstant needed to be public. util/BCELifier.printFlags was super useful to be public.];[Which printFlags method? Or both? Sorry: public static String printFlags( int flags, int reason ) What about FLAG_FOR_CLASS and FLAG_FOR_METHOD? Won't those also be needed? They should probably be turned into an enum anyway. Also, any chance that you could contibute the javap code? This would be very useful as example code. changed flags to enum attached test case Thanks very much. Applied the patches with a few minor changes. URL: http://svn.apache.org/r1697493 Log: BCEL-254 Two more methods that would be nice to be public. Modified: commons/proper/bcel/trunk/src/changes/changes.xml commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/Constant.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/util/BCELifier.java URL: http://svn.apache.org/r1697494 Log: BCEL-254 Two more methods that would be nice to be public. Sample class using BCEL to produce output like javap Added: commons/proper/bcel/trunk/src/examples/ClassDumper.java (with props)];
BCEL-257;[BCEL-257] INVOKESPECIAL, INVOKESTATIC, INVOKEVIRTUAL need to define dump() methods;Fixed;Closed;Sebb;1440585145000;1440612373000;Bug;[];[];[It looks like the INVOKESPECIAL, INVOKESTATIC, INVOKEVIRTUAL classes need to define dump() methods, otherwise they will just dump the opcode. Note that INVOKEDYNAMIC and INVOKEINTERFACE both define dump() methods that correspond with their descriptions in the JVMS 6.5];[Note: the unit test submitted as part of BCEL-258 showed that the fixes here were needed URL: http://svn.apache.org/r1697982 Log: BCEL-257 INVOKESPECIAL, INVOKESTATIC, INVOKEVIRTUAL need to define dump() methods Modified: commons/proper/bcel/trunk/src/changes/changes.xml commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/INVOKESPECIAL.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/INVOKESTATIC.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/INVOKEVIRTUAL.java];
BCEL-258;[BCEL-258] No tests to check the output of dump methods;Fixed;Closed;Unassigned;1440586577000;1440612261000;Bug;[];[];[There don't appear to be any tests that check whether the dump methods work OK. As an experiment I tried adding extra output to Instruction.dump(), and that only caused an error in GeneratingAnnotatedClassesTestCase. It should have caused lots of errors.];[URL: http://svn.apache.org/r1697951 Log: BCEL-258 No tests to check the output of dump methods Added (optional) test to check the dump methods in the classfile package Added: commons/proper/bcel/trunk/src/test/java/org/apache/commons/bcel6/classfile/JDKClassDumpTestCase.java (with props) Modified: commons/proper/bcel/trunk/pom.xml Still need tests for the generic dump() methods URL: http://svn.apache.org/r1697983 Log: BCEL-258 No tests to check the output of dump methods Added test for generic package dump methods Added: commons/proper/bcel/trunk/src/test/java/org/apache/commons/bcel6/generic/JDKGenericDumpTestCase.java (with props) Modified: commons/proper/bcel/trunk/src/changes/changes.xml];
BCEL-260;[BCEL-260] ClassDumper example duplicates field attribute types;Fixed;Closed;Unassigned;1440709212000;1440714459000;Bug;[classdumper.diff];[];[It looks like some time ago the toString() for attributes was changed to include the attribute type. This patch updates ClassDumper.];[URL: http://svn.apache.org/r1698233 Log: BCEL-260 ClassDumper example duplicates field attribute types Modified: commons/proper/bcel/trunk/src/changes/changes.xml commons/proper/bcel/trunk/src/examples/ClassDumper.java];
BCEL-261;[BCEL-261] Select constructor allows partially constructed instance to escape;Unresolved;Open;Unassigned;1440715311000;0;Bug;[select-init.diff];[];[The main Select constructor allows its instance to be accessed by other code before the constructor has completed. This causes problems such as BCEL-195 because the behaviour of a partially constructed object is not well defined.];[Patch select-init.diff copied from BCEL-195. This performs as much initialisation as possible before allowing the partially constructed object to escape. However, there is still a remote possibility that the object will behave in unexpected ways, so ideally the design issue needs to be addressed URL: http://svn.apache.org/r1698238 Log: BCEL-261 Select constructor allows partially constructed instance to escape. Re-ordered code to delay the escape Modified: commons/proper/bcel/trunk/src/changes/changes.xml commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/generic/Select.java];
BCEL-264;[BCEL-264] Add missing Node.accept() implementations (ConstantMethodHandle, ConstantMethodType, ParameterAnnotationEntry);Fixed;Closed;Unassigned;1442055592000;1442058263000;Bug;[];[];[Several new classes were added with empty Node.accept(Visitor) implementations. These need to be implemented. ConstantMethodHandle ConstantMethodType ParameterAnnotationEntry];[URL: http://svn.apache.org/r1702615 Log: BCEL-264 Add missing Node.accept() implementations (ConstantMethodHandle, ConstantMethodType, ParameterAnnotationEntry) Modified: commons/proper/bcel/trunk/src/changes/changes.xml commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/ConstantMethodHandle.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/ConstantMethodType.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/DescendingVisitor.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/EmptyVisitor.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/ParameterAnnotationEntry.java commons/proper/bcel/trunk/src/main/java/org/apache/commons/bcel6/classfile/Visitor.java commons/proper/bcel/trunk/src/test/java/org/apache/commons/bcel6/visitors/CounterVisitor.java];
BCEL-266;[BCEL-266] INVOKEDYNAMIC is missing from Constants.java in 5.2;Not A Problem;Resolved;Unassigned;1442708201000;1442709531000;Bug;[];[];[Strangely, INVOKEDYNAMIC is missing in Constants.java for the tarball of BCEL-5.2 It should say: public static final short INVOKEDYNAMIC = 186. as it does in the code browser: http://commons.apache.org/proper/commons-bcel/apidocs/src-html/org/apache/bcel/Constants.html];[The API docs are for the current (trunk, 6.0) version of BCEL. 5.2 does not support InvokeDynamic];
BCEL-267;[BCEL-267] Race conditions on static fields in BranchHandle and InstructionHandle;Fixed;Resolved;Unassigned;1443557562000;1549898595000;Bug;[BCEL267--Race-conditions-on-static-fields-in-BranchH.patch];[];[I have observed race conditions causing NullPointerException like this java.lang.NullPointerException        at org.apache.bcel.generic.InstructionList.getInstructionHandles(InstructionList.java:1021)        at org.apache.bcel.generic.InstructionList.findHandle(InstructionList.java:141)        at org.apache.bcel.generic.MethodGen.<init>(MethodGen.java:194) In the debugger I could verify that concurrent access to the fields BranchHandle.bh_list or InstructionHandle.ih_list can cause corruption of those lists. I succeeded to make the exception less frequent by adding synchronized blocks, but still the exception could be observed. I concluded that for safe protection the fields would need to be made volatile, which in the end might actually defeat their original purpose of optimization. I have since then run with a patched version of BCEL, where those static fields were simply removed and new Handles were created on every request. This variant finally was free of the race condition. Seeing activity towards a 6.0 release, I'd appreciate if this change could be incorporated. The original bug tracking my experiments can be found in Eclipse bugzilla: https://bugs.eclipse.org/344350 The modified classes (based on 5.2) can be found here: http://git.eclipse.org/c/objectteams/org.eclipse.objectteams.git/tree/plugins/org.eclipse.objectteams.otre/bcelpatchsrc/org/apache/bcel/generic];[Thanks for the report. However, at this point in time there are no plans to support multi-threaded use of BCEL. See also BCEL-105 However, at this point in time there are no plans to support multi-threaded use of BCEL. I'd like to ask you to reconsider this, because we might be talking about two different levels of support for multi-threading. I understand that two threads simultaneously working on the same data can cause arbitrary havoc and making BCEL safe against this kind of usage is probably hard, agreed. In my use-case, however, the clients of BCEL already ensure, that never two threads operate on the same class files / data structures of BCEL. Still the bogus use of a static field makes it impossible that two threads ever use BCEL concurrently even on 100% disjoint data. I don't think it is reasonable to burden clients so much as to prevent even these completely isolated calls into BCEL. Please see that this style of concurrency was impossible with original BCEL and never again caused any concurrency issues after my tiny changes have been applied. In order to protect against this style of concurrency, we would need a single, global lock in front of every call into BCEL, which is not feasible. I believe a static mutable field with no protection is reason enough for fixing under any circumstances Static mutable fields are definitely a bad idea - they are thread-hostile - but it's only necessary to fix them if code is intended for multi-threaded use. The problem is that this area of BCEL is quite complicated. further there is insufficient unit test coverage to be sure that regressions would be caught. Removing the fields is not to be undertaken lightly. These fields are nothing but an attempt at optimization Explicitly and unconditionally creating a new handle when one is needed does not break anything. Let me explain more: in my use-case BCEL is invoked during class loading of an inherently concurrent application: Eclipse. If client-side synchronization based on data is not sufficient, then BCEL is DOA in this context. By saying that BCEL is not intended for any multi-threaded use – including concurrency with 100% data isolation – you seem to be saying that BCEL is not intended for use in any Java applications other than tools operating in batch mode. Is that the message? Seeing this unfixed even in version 6.0 implies that BCEL cannot be used during class loading of applications: If thread A loads and transforms class X it can be nuked by thread B loading and transforming class Y. Given that I provided a fix and the reasoning why this patch is safe I am clueless why this change has not been accepted. Please re-consider and provide a 6.1 release, otherwise all the work having gone into BCEL 6.0 (thanks!) is useless for real-life use cases. Please remember that I am not requesting full thread-safety, just that BCEL behaves well in a multi-threaded application where clients guarantee isolation based on data. Hello shermann, Can you provide a patch and unit test so we can see precisely what you are proposing? You can also provide a PR if you prefer on our GitHub mirror https://github.com/apache/commons-bcel Gary I finally found the time to create a test case that effectively triggers the problem (see attached BCEL267--Race-conditions-on-static-fields-in-BranchH.patch). The core issue is: two threads with no shared data create an instruction list each, and add lots of instructions to their respective list. After some random - but not very big - number of iterations, one of the instruction lists will be corrupt, having a next or prev pointer pointing into the other list, which can surface with one of 3 possible symptoms: NullPointerException in InstructionList.getInstructionHandles(..) instruction list does not contain the expected instructions instruction list has corrupt link structure: ih.getNext().getPrev() != ih Re-run the test (without the changes in InstructionHandle and BranchHandle ) several times to see all three symptoms (it may even randomly succeed, but that should be rare). While running other tests I observed a ClassCastException in org.apache.bcel.PLSETestCase.testB262() even on unmodified sources. Given that the entire business of the bogusly shared ih_list and bh_list is performance optimization I took a quick look at the output of PerformanceTest but difference looked like normal white noise, i.e.: no indication at a performance regression due to the fix. Ping? A patch containing a test & the fix has been attached a year ago. Without this, BCEL is not usable when triggered from class loaders in a multi-threaded environment, even if different invocations of BCEL don't share any data. Could the patch please be considered? Note that BCEL was not designed with multi-threaded use in mind, so there are likely to be other data races in the code. Note that BCEL was not designed with multi-threaded use in mind We're going in circles I already (repeatedly) responded to that. Sebb, I'm a very conservative open source committer myself, but in all my imagination, I can't find an explanation why you would be so much afraid of this simple fix to a proven bug. so there are likely to be other data races in the code. No reason to speculate, just look at the attached test case, run it, inspect the code, and tell me what you see. (FWIW, I just checked: the tests still blow up in 6.2). sebb@apache.org There is a difference between accessing the same instance or different instances from multiple threads. It has always been (how do I say this politely?) "not exactly a good design decision" to use statics like this - at all. So I think sherrmann has a valid point here. Making BCEL instances thread-safe will probably never happen (and should not be the goal), but it should be possible to use different BCEL instances from different threads. But I agree - this might not be the last place to fix this. Of course it is a project decision to support this. (This pain is one of the reasons I moved away from BCEL at javaflow times). I already wrote that mutable statics are a bad idea [1]. Fixing those is obviously a pre-requisite for using BCEL in multiple threads. I was just pointing out that whilst that is necessary, it is not sufficient, so one should not expect it to be a magic bullet. Even if instances are confined to a single thread, there could be other shared resources, for example singleton classes or files. [1] https://issues.apache.org/jira/browse/BCEL-267?focusedCommentId=14935957&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14935957 I don't expect a silver bullet, but I can report [1] that a patched version of bcel is successfully in use in a multi-threaded environment for many years now. The original version frequently blew up, but the patched version never showed any thread-related anomalies. [1] https://issues.apache.org/jira/browse/BCEL-267?focusedCommentId=14935916&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14935916 [ANNOUNCEMENT] Apache Commons BCEL 6.3 Released Still no committer accepts the fact that a bug exists, for which fix & test have been submitted years ago? What else do you need? C'mon guys, open source can do better than just hand waving and shrugging the issue off, which effectively prohibits the use of BCEL for load time transformers. I missed this issue when I did my Jira review for 6.3. I'll try to take a look later. Note: We do not use @author tags anymore in source code. instead we use the POM file to track contributions. I hope you'll be OK with that. PR: https://github.com/apache/commons-bcel/pull/23 sherrmann: In git master. Please verify and close. Gary In git master. Please verify and close. This is excellent news! Do you have a nightly build that I can use for testing?];
BCEL-268;[BCEL-268] Support for generating StackMaps;Unresolved;Open;Unassigned;1446299403000;0;Bug;[];[];[As of Java 8, Stack Maps are REQUIRED by the Java Verifier in order to run. This effectively makes BCEL unusable for the purpose of instrumenting classes.];[GitHub user JanUlrich opened a pull request: https://github.com/apache/commons-bcel/pull/7 BCEL-268: Add StackMapTable-Generator I used some code from the ASM-framework which already supports Stackmaptables and applied small changes to fit the BCEL-framework. The code is not complete yet. There are many things to do, like implementing support for arrays and static fields/functions. I would love any kind of feedback ( a.stadelmeier@hb.dhbw-stuttgart.de ) You can merge this pull request into a Git repository by running: $ git pull https://github.com/JanUlrich/commons-bcel trunk Alternatively you can review and apply these changes as the patch at: https://github.com/apache/commons-bcel/pull/7.patch To close this pull request, make a commit to your master/trunk branch with (at least) the following in the commit message: This closes #7 commit 53599aec22ac48886014fb9e00344963d1e16f06 Author: JanUlrich <andi@michlaustderaffe.de> Date: 2016-07-13T19:31:10Z BCEL-268: Add StackMapTable-Generator];
BCEL-269;[BCEL-269] Flushing DataOutputStream before calling toByteArray on the underlying ByteArrayOutputStream;Fixed;Closed;Unassigned;1454645020000;1562459020000;Bug;[BCEL-269-0.patch];[];[In src/main/java/org/apache/commons/bcel6/generic/InstructionList.java         ByteArrayOutputStream b = new ByteArrayOutputStream().         DataOutputStream out = new DataOutputStream(b).         try {             for (InstructionHandle ih = start. ih != null. ih = ih.getNext()) {                 Instruction i = ih.getInstruction().                 i.dump(out). // Traverse list             }         } catch (IOException e) {             System.err.println(e).             return new byte[0]. When a DataOutputStream instance wraps an underlying ByteArrayOutputStream instance, it is recommended to flush or close the DataOutputStream before invoking the underlying instances's toByteArray(). Also, it is a good practice to call flush/close explicitly as mentioned for example http://stackoverflow.com/questions/2984538/how-to-use-bytearrayoutputstream-and-dataoutputstream-simultaneously-java. The patch is to add flush method before calling toByteArray.];[This was fixed by commit 07e0698ed6961ac535a8971e52d61e53f877f58e on 2016-02-05 01:09:42 before 6.0 was released.];
BCEL-270;[BCEL-270] Calling toString(ConstantPool) on InvokeInstruction throws NullPointerException;Fixed;Closed;Unassigned;1458386548000;1562458539000;Bug;[invokeinstruction.patch];[];[];[It doesn't seem that the StringTokenizer ever has more than one token inside InvokeInstruction's toString method but i kept it there just in case I'm wrong. Closing as this method was updated for BCEL-278. Please provide a test case in if this is still an issue.];
BCEL-271;[BCEL-271] FCONST pattern does not include FCONST_2;Fixed;Closed;Unassigned;1459813414000;1464756431000;Bug;[];[];[The FCONST pattern in InstructionFinder.java:356 should include FCONST_2.];[Patches welcome, with unit tests of course In svn trunk.];
BCEL-273;[BCEL-273] Regressions running FindBugs on BCEL6;Fixed;Closed;Unassigned;1465218918000;1465560490000;Bug;[BetterCFGBuilder2.java, bcel6_test_result.txt, invokedynamic.txt];[];[PREFACE I'm trying to port FindBugs to the latest greatest BCEL 6 state from trunk, see https://github.com/findbugsproject/findbugs/issues/106. In short, FindBugs was using some manually created BCEL 5.2 fork which allowed us somehow run BCEL on Java 8 and even Java 9. Unfortunately I have no idea how to rebuild that fork, because no one in the project left any documentation. So anyway, my goal was to use unmodified BCEL6, therefore I fixed all compile issues caused by BCEL-222 () and was able to run FB with BCEL6 head. Unfortunately I found some regressions. Environment I'm using my own git clone from BCEL mirror https://github.com/iloveeclipse/commons-bcel/commits/trunk The clone only adds few Eclipse files and fixes some obvious errors, nothing worth to mention here. The reason why I'm not using svn because it is too slow and I won't waste my time. To see commits I needed to port FB to BCEL6 port, go to https://github.com/findbugsproject/findbugs/tree/java9_bcel6 How to reproduce git clone https://github.com/findbugsproject/findbugs.gitcd findbugsgit checkout java9_bcel6cd findbugsantcd ../findbugsTestCasesant You should run Java 8. After running tests, you should see many various errors, like: https://github.com/findbugsproject/findbugs/files/300401/bcel6_test_result.txt None of those error appear with the old private patched BCEL5.2 snapshot we've used before. It would be nice to fix the errors before the BCEL release.];[bcel6_test_result.txt: test results of FindBugs running with BCEL6. dbrosius: can you please take a look? Thanks I'll debug your fork tonight i believe FindBug's DismantleBytecode.java is wrong, in how it handles invoke dynamic. I'd attached a patch file that i believe fixes the issue process invoke dynamic before CP I see this problem  Exception analyzing FPEnumValueOf using detector edu.umd.cs.findbugs.detect.NoteNonnullReturnValues    java.lang.IllegalArgumentException: Cannot be used on an array type      At org.apache.commons.bcel6.generic.InvokeInstruction.getClassName(InvokeInstruction.java:135)      At edu.umd.cs.findbugs.ba.Hierarchy2.findExactMethod(Hierarchy2.java:84) And it does seem to be a problem with BCEL, due to a new construct that i didn't notice before, namely for enums, the generated values() method of enum looks like  public static FPEnumValueOf[] values().    descriptor: ()[LFPEnumValueOf.    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=1, locals=0, args_size=0         0: getstatic     #1                  // Field $VALUES:[LFPEnumValueOf.         3: invokevirtual #2                  // Method "[LFPEnumValueOf.".clone:()Ljava/lang/Object.         6: checkcast     #3                  // class "[LFPEnumValueOf."         9: areturn      LineNumberTable:        line 56: 0 notice the call to clone on an array!! and in the constant pool, is this Constant pool:   #1 = Fieldref           #4.#40         // FPEnumValueOf.$VALUES:[LFPEnumValueOf.   #2 = Methodref          #41.#42        // "[LFPEnumValueOf.".clone:()Ljava/lang/Object. So java 8 is calling methods on arrays that bcel doesn't expect. I'll see if i can track down where that is handled. In theory, you can call toString() on an array, and BCEL doesn't have a fit, so we should be able to address this. I'll keep looking Array problem fixed here r1747124 | dbrosius | 2016-06-06 22:43:06 -0400 (Mon, 06 Jun 2016) | 1 line revert erroneous override of getClassName in InvokeInstruction, introduced in r1702349 I see this problem Exception analyzing JPAI_Sample$MyEntity using detector edu.umd.cs.findbugs.detect.NoteUnconditionalParamDerefs java.lang.ClassCastException: edu.umd.cs.findbugs.bcel.generic.NULL2Z cannot be cast to org.apache.commons.bcel6.generic.BranchInstruction At org.apache.commons.bcel6.generic.BranchHandle.getBI(BranchHandle.java:64) At org.apache.commons.bcel6.generic.BranchHandle.getPosition(BranchHandle.java:73) At edu.umd.cs.findbugs.ba.BetterCFGBuilder2$Subroutine.addInstruction(BetterCFGBuilder2.java:296) At edu.umd.cs.findbugs.ba.BetterCFGBuilder2.build(BetterCFGBuilder2.java:867) This is caused by Findbugs optimization pass in BetterCFGBuilder2.optimize, specifically ` if (nullIsTrue) { // System.out.println("Found NULL2Z instruction"). head.swapInstruction(new NULL2Z()). } else { // System.out.println("Found NONNULL2Z instruction"). head.swapInstruction(new NONNULL2Z()). } ` This takes an IFNONNULL BranchHandle, and injects a special NULL2Z BranchInstruction into it. It does not however change what head is, and so head is still a BranchHandle that is holding a ConversionInstruction. Really, the head BranchHandle should be removed from the InstructionList, and replaced with the NULL2Z (or at least a non-BranchHandle), but it does not. Now this broke because of Sebb's changes, to BranchHandle.java, here private BranchInstruction getBI() { return (BranchInstruction) super.getInstruction(). } @Override public int getPosition() { return getBI().getPosition(). } where getBI() assumes, (probably correctly) the the instruction is going to be of type BranchInstruction, but NULL2Z is a ConversionInstruction. So while this was caused by BCEL changes, i actually think the changes were right, and findbugs needs to rewrite the InstructionList to take out the BranchHandle and replace it with a plain InstructionHandle. dbrosius: thanks for the pointers! I've pushed https://github.com/findbugsproject/findbugs/commits/java9_bcel6_old branch which applies the DismantleBytecode fix proposed earlier - this works! The current (last visible) problem is ClassCastException in org.apache.commons.bcel6.generic.BranchHandle.getBI(BranchHandle.java:64). If I change BranchHandle.java to https://github.com/iloveeclipse/commons-bcel/commit/25dfa20fd99e4053e68b6054ff21f55fd915e003, the CCE disappear and all FB tests pass on Java 8. However I've failed to do a fix on the FB side which would NOT require https://github.com/iloveeclipse/commons-bcel/commit/25dfa20fd99e4053e68b6054ff21f55fd915e003. If I change FB code, see attached BetterCFGBuilder2.java, I see other errors, and tests are still failing. I've never used BCEL before, so my primitive fix was to replace calls to InstructionHandle head.Instruction replacement....head.swapInstruction(replacement). with ...   head = swapInstruction(instructionList, head, replacement)....    static InstructionHandle swapInstruction(InstructionList list, InstructionHandle handle, Instruction i){        InstructionHandle newOne = list.insert(handle, i).        try {            list.delete(handle).        } catch (TargetLostException e) {            // TODO Auto-generated catch block            e.printStackTrace().        }        return newOne.    } I'm not sure if replacing BranchInstruction by ConversionInstruction in the way as it shown above is a good idea (I see that the TargetLostException are flying around which means we have some loose ends in the list). But honestly speaking, I have no clue how the BetterCFGBuilder2 code works and how to fix it in the "right" way. In that sense, sebb@apache.org: WDYT about https://github.com/iloveeclipse/commons-bcel/commit/25dfa20fd99e4053e68b6054ff21f55fd915e003? GitHub user iloveeclipse opened a pull request: https://github.com/apache/commons-bcel/pull/6 Fix for BCEL-273 Fixes BCEL-273 by partly reverting adf9fc13b37f866d731c73a09071170d50bfa807. This allows FindBugs to run on latest greatest BCEL state and avoid exceptions below: java.lang.ClassCastException: edu.umd.cs.findbugs.bcel.generic.NULL2Z cannot be cast to org.apache.commons.bcel6.generic.BranchInstruction At org.apache.commons.bcel6.generic.BranchHandle.getBI(BranchHandle.java:64) At org.apache.commons.bcel6.generic.BranchHandle.getPosition(BranchHandle.java:73) At edu.umd.cs.findbugs.ba.BetterCFGBuilder2$Subroutine.addInstruction(BetterCFGBuilder2.java:296) At edu.umd.cs.findbugs.ba.BetterCFGBuilder2.build(BetterCFGBuilder2.java:867) You can merge this pull request into a Git repository by running: $ git pull https://github.com/iloveeclipse/commons-bcel BCEL-273 Alternatively you can review and apply these changes as the patch at: https://github.com/apache/commons-bcel/pull/6.patch To close this pull request, make a commit to your master/trunk branch with (at least) the following in the commit message: This closes #6 commit 25dfa20fd99e4053e68b6054ff21f55fd915e003 Author: Andrey Loskutov <loskutov@gmx.de> Date: 2016-06-08T13:27:07Z Fixes BCEL-273 by partly reverting adf9fc13b37f866d731c73a09071170d50bfa807. java.lang.ClassCastException: edu.umd.cs.findbugs.bcel.generic.NULL2Z cannot be cast to org.apache.commons.bcel6.generic.BranchInstruction At org.apache.commons.bcel6.generic.BranchHandle.getBI(BranchHandle.java:64) At org.apache.commons.bcel6.generic.BranchHandle.getPosition(BranchHandle.java:73) At edu.umd.cs.findbugs.ba.BetterCFGBuilder2$Subroutine.addInstruction(BetterCFGBuilder2.java:296) At edu.umd.cs.findbugs.ba.BetterCFGBuilder2.build(BetterCFGBuilder2.java:867) The stack trace looks very odd. It looks like you are mixing two different versions of BCEL using different package names and/or creating your own classes which are not BranchInstructions. If the following patch comment is true, then there should be no reason for the CCE: private BranchInstruction bi. // An alias in fact, but saves lots of casts I'm not keen to re-introduce a local copy of the instruction, as it makes testing harder. ["If there are two copies of a piece of data, at least one of them may be wrong"] I would rather see the casts. The problem are not two different BCEL versions but the BCEL API, which allows you to swap the instruction on InstructionHandle without using setInstruction(): org.apache.bcel.generic.InstructionHandle.swapInstruction(Instruction). If the code uses swapInstruction() and then calls any of BranchHandle methods, we will get a CCE without the patch. BTW, I'm not saying the BCEL swapInstruction API is/was good, but it was invented to serve some purposes, it was published and it was used, so the original patch, which makes sense from the clean code point of view, unintentionally broke existing clients which just used that public API. The Javadoc for swapInstruction says: Temporarily swap the current instruction, without disturbing anything. Meant to be used by a debugger, implementing breakpoints. Current instruction is returned. If the method is being used for anything else, then I think the user has to be aware it may break things. They should not expect the class to be have normally until the original instruction has been restored. AFAICT Dave Brosius agrees with me on this. Findbugs should not be (ab)using the method this way. That's right, but we should not make things worse. If one API allows to swap instructions on handle, the handle should not fail if the swapped instruction is requested. BTW "meant to be used" is not "shall be used only for". AFAICT it's not possible to fix the code so that it works properly once the swapInstruction method has been used. Caching the original instruction avoids the CCE, but means that the other methods return stale data. Caveat emptor. While I think Sebb's changes in BranchHandle are technically correct, I'm not sure they add any significant value, and so reverting that probably is the safe option. Agree. I don't think the old state was buggy, otherwise we would see bug reports. Cleaning the code base is OK, but sometimes existing API can not be cleaned because it is simply not well designed. There was a reason for original author of swapInstruction to allow instruction handles have different instructions, and the branch handle worked well with that approach. The CCE we see on changed code in FindBugs will appear also in other tools used that API. To be consistent and clean, swapInstruction must be removed entirely. Compromise: release patch with 6.0 and remove that inconsistent API in 7.0. OK, but I think we need to carefully document the restrictions on the use of swapInstruction if used with a BranchHandle. URL: http://svn.apache.org/viewvc?rev=1747689&view=rev Log: BCEL-273 - Regressions running FindBugs on BCEL6 Reverted to previous code. added comments Modified: commons/proper/bcel/trunk/src/main/java/org/apache/bcel/generic/BranchHandle.java commons/proper/bcel/trunk/src/main/java/org/apache/bcel/generic/InstructionHandle.java Github user iloveeclipse closed the pull request at: https://github.com/apache/commons-bcel/pull/6];
BCEL-274;[BCEL-274] Constants is deprecated and unused internally so should not be updated;Unresolved;Open;Unassigned;1466695783000;0;Bug;[];[];[The constants class is deprecated, and no longer used internally, so I don't think it makes sense to add any fields to it. The Clirr report shows that INVOKEDYNAMIC was added. this should be dropped (or, if it is to be kept, it needs the @since marker!)];[];
BCEL-275;[BCEL-275] Build fails on Java 9 EA;Unresolved;Open;Unassigned;1468501245000;0;Bug;[mvn-clean-install-without-jacoco.txt, mvn-clean-install.txt];[];[mvn clean install fails when building on Java 9 EA.];[Attached result of running mvn clean install. The build fails because the JaCoCo instrumentation does not work with Java 9. Attached the result of running mvn clean install -P-jacoco. Several tests are failing. I tested this again for 6.1 release with: ~/w/a/c/commons-bcel > java --versionjava 9Java(TM) SE Runtime Environment (build 9+181)Java HotSpot(TM) 64-Bit Server VM (build 9+181, mixed mode) Build still fails.];
BCEL-276;[BCEL-276] LocalVariableTypeTable is not updated. ;Fixed;Closed;Benedikt Ritter;1469009678000;1504121683000;Bug;[LocalVariable.mark.diff, LocalVariableGen.mark.diff, LocalVariableTypeTableTest.java, MethodGen.mark.diff2, SimpleClassHasMethodIncludeGenericArgument.java];[];[If a method for BCI have at least one generic type of argument JVM throw java.lang.ClassFormatError due to not updated LocalVariableTable. I know there is workaround as call removeLocalVariables method. But I think it's better that BCEL can stay proper LocalVariableTable. I'm also pull test case can reproduce error.];[Attach error stack. java.lang.ClassFormatError: LVTT entry for 'a2' in class file org/apache/bcel/data/SimpleClassHasMethodIncludeGenericArgument does not match any LVT entry at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:760) at java.lang.ClassLoader.defineClass(ClassLoader.java:642) at org.apache.bcel.LocalVariableTypeTableTest$TestClassLoader.findClass(LocalVariableTypeTableTest.java:27) at org.apache.bcel.LocalVariableTypeTableTest.testWihtoutGenericArgument(LocalVariableTypeTableTest.java:47) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497) at junit.framework.TestCase.runTest(TestCase.java:176) at junit.framework.TestCase.runBare(TestCase.java:141) at junit.framework.TestResult$1.protect(TestResult.java:122) at junit.framework.TestResult.runProtected(TestResult.java:142) at junit.framework.TestResult.run(TestResult.java:125) at junit.framework.TestCase.run(TestCase.java:129) at junit.framework.TestSuite.runTest(TestSuite.java:252) at junit.framework.TestSuite.run(TestSuite.java:247) at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:42) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:253) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:84) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147) GitHub user KyongSik-Yoon opened a pull request: https://github.com/apache/commons-bcel/pull/10 BCEL-276 LocalVariableTypeTable is not updated when use MethodGen. If a method for BCI have at least one generic type of argument JVM throw java.lang.ClassFormatError due to not updated LocalVariableTable. I know there is workaround as call removeLocalVariables method. But I think it's better that BCEL can stay proper LocalVariableTable. This PR include unit test for reproduce a bug. You can merge this pull request into a Git repository by running: $ git pull https://github.com/KyongSik-Yoon/commons-bcel BCEL-276 Alternatively you can review and apply these changes as the patch at: https://github.com/apache/commons-bcel/pull/10.patch To close this pull request, make a commit to your master/trunk branch with (at least) the following in the commit message: This closes #10 commit b0105bf90c0cdbe08f9076e24859aae07b46bcb2 Author: sam <sam1287@gmail.com> Date: 2016-07-28T11:11:03Z BCEL-276 LocalVariableTypeTable is not updated when use MethodGen. Test seems to be incomplete. See GitHub conversation. I wrote an additional comment to GitHub. Github user asfgit closed the pull request at: https://github.com/apache/commons-bcel/pull/10 Fixed in http://svn.apache.org/viewvc?view=revision&revision=1759364 Thank you! This issue needs to be reopened as the code is incorrect. It saves a copy of the LocalVariableTable and then reuses it later. But that is obviously incorrect as any changes that have been made to the LocalVariableTable in the meantime are discarded. I have attached a diff file with the changes I made to correct the problem. Unfortunately, that broke the new associated test case for reasons I could not understand. The original patch developer will need to review the situation. The key point is the change at line 622 where we get the latest copy of the LocalVariableTable - not some previously cached version. Note that I also added a couple of minimal routines that allow a user to get a copy of or delete the LocalVariableTypeTable. This is necessary if you make major changes to the LocalVariableTable (such as changing the slot number) so that the two tables cannot be resynchronized. BCEL should take care of all of this automatically, but as we all know the support in this area and in the StackMapTable area is lacking. Reopening this issue to address problems identified by Mark Roberts. I saw this issue lately. I'll check it after finishing my job. markro I think we need to add test case for reproduce an expected situation that any changes after cache LocalVariableTable can be discarded. GitHub user KyongSik-Yoon opened a pull request: https://github.com/apache/commons-bcel/pull/12 BCEL-276 LocalVariableTypeTable is not updated. @britter I was fixed the problem reported by Mark Robert. This PR include small change. You can merge this pull request into a Git repository by running: $ git pull https://github.com/KyongSik-Yoon/commons-bcel BCEL-276 Alternatively you can review and apply these changes as the patch at: https://github.com/apache/commons-bcel/pull/12.patch To close this pull request, make a commit to your master/trunk branch with (at least) the following in the commit message: This closes #12 commit 825d992e1ceadb05a8187a5b6bf9fc6083072f02 Author: sam <sam1287@gmail.com> Date: 2016-07-28T10:44:29Z BCEL-277 Resolve constant to a string representation occur NoSuchElementException in case CONSTANT_NameAndType constant. commit b0105bf90c0cdbe08f9076e24859aae07b46bcb2 Author: sam <sam1287@gmail.com> Date: 2016-07-28T11:11:03Z BCEL-276 LocalVariableTypeTable is not updated when use MethodGen. commit d4522b52c6240b7e4c028563b34a05bc7684a7c7 Author: sam <sam1287@gmail.com> Date: 2016-07-28T11:11:03Z BCEL-276 LocalVariableTypeTable is not updated when use MethodGen. commit 500730c2058d1c4ebf611e401a66eb605d8467fc Author: sam <sam1287@gmail.com> Date: 2016-08-22T02:05:51Z BCEL-276 LocalVariableTypeTable is not updated when use MethodGen. commit 496c6ecef0d097383d8e2558a65f62bf38a5bdb2 Author: sam <sam1287@gmail.com> Date: 2016-08-22T02:08:57Z Merge remote-tracking branch 'origin/ BCEL-276' into BCEL-276 Conflicts: src/main/java/org/apache/bcel/generic/MethodGen.java src/test/java/org/apache/bcel/data/SimpleClassHasMethodIncludeGenericArgument.java commit 6c2a6f01fdcd4400bb5decb910915eb78137a07b Author: sam <sam1287@gmail.com> Date: 2016-08-23T01:12:02Z Merge remote-tracking branch 'remotes/upstream/trunk' into BCEL-276 Conflicts: src/test/java/org/apache/bcel/classfile/ConstantPoolTestCase.java src/test/java/org/apache/bcel/data/SimpleClassWithDefaultConstructor.java commit d6c7fed046b8c49de35ff833cc984f4f4da26602 Author: sam <sam1287@gmail.com> Date: 2016-08-23T01:16:26Z BCEL-276 Remove old test case and add simple comment after rebase with trunk. commit 92e8797cf4aacdeeb2407fe3333b4835a2378886 Author: sam <sam1287@gmail.com> Date: 2016-08-23T14:25:31Z BCEL-276 Remove old test case and add simple comment after rebase with trunk. Revert reorganize import. commit 907d204d0a81edb0343881552416e2c1db3c718d Author: sam <sam1287@gmail.com> Date: 2016-08-30T08:00:59Z BCEL-276 Generate LocalVariableTypeTable section commit c294cf5355ef244d707e1219cdccc4253ecc195a Author: sam <sam1287@gmail.com> Date: 2016-08-30T21:59:36Z BCEL-276 Move generate LocalVariableTable section to call getMethod() commit cb4a2e48df1da938fa9a990aa05c10be127ef5b3 Author: sam <sam1287@gmail.com> Date: 2016-09-06T01:59:05Z BCEL-276 Fixed NullPointerException commit 6fca90afed94a8b8fc32821bbc28c655bc48aae3 Author: sam <sam1287@gmail.com> Date: 2016-12-24T15:18:47Z BCEL-276 Add missing part that adjust to start pc each of local variables on local variable type table and rename method. commit 6917052a54643f63b5abebf79dae59eab5aebc4c Author: sam <sam1287@gmail.com> Date: 2016-12-24T15:34:17Z BCEL-276 Add missing part that adjust to start pc each of local variables on local variable type table and rename method. britter I was PR again including small change reported problem by markro. The reason is simple. I've missed update to start pc each of local variable on LVTT. My test case passed without conflict. Please check it. I was able to get the code working to pass both your tests and my tests, but there were two issues that needed to be fixed. First, when copying the LocalVariableTypeTable, you need to make a true copy, not just save the pointer. Approx line 229. The other change is more complex. You cannot match a LocalVariable and a LocalVariableType based on having the same index and it may have been modified. I Added code to LocalVariable.java and LocalVariableGen.java to maintain a copy of the original index of a LocalVariable and then use this for matching. I have attached three diff files with my changes. britter I was applied a patch suggested by markro and push to my branch. Thanks for you advice. This does not appear to be corrected in the current sources. I have updated the patch for MethodGen to sync with changes made from my last upload. It is now called MethodGen.mark.diff2. ~/w/a/c/commons-bcel > svn ci -m "BCEL-276: LocalVariableTypeTable is not updated. Updated fix thanks to Mark Roberts. This closes #12 from GitHub."Sending        src/changes/changes.xmlSending        src/main/java/org/apache/bcel/classfile/LocalVariable.javaSending        src/main/java/org/apache/bcel/generic/LocalVariableGen.javaSending        src/main/java/org/apache/bcel/generic/MethodGen.javaTransmitting file data ....doneCommitting transaction...Committed revision 1806728. Github user asfgit closed the pull request at: https://github.com/apache/commons-bcel/pull/12];
BCEL-277;[BCEL-277] Resolving the String representation of a constant throws NoSuchElementException in case of CONSTANT_NameAndType constant.;Fixed;Closed;Benedikt Ritter;1469471830000;1469779834000;Bug;[ConstantPoolTestCase.java, SimpleClassWithDefaultConstructor.java, patch];[];[A method that constantToString of ConstantPool class always occur NoSuchElementException when face with costant type of CONSTANT_NameAndType. A reason is invalid separator for StringTokenizer that colon. It should be replaced to empty string. I had pull request include ConstantPoolTestCase.];[Hello Sam, Can you provide a stack trace in your description please? If you do provide a patch, can you please provide a unit test? Thank you, Gary I attach patch and unit test. You can also refer my pull request from Github. https://github.com/apache/commons-bcel/pull/8/commits/04b56ea23d5d9b2b947abadb064d877a4a72d19b https://github.com/apache/commons-bcel/pull/8/commits/c39f2c6ec365cbe3303a89bca2fdc73f898ee013 Stack trace. java.util.NoSuchElementException at java.util.StringTokenizer.nextToken(StringTokenizer.java:349) at org.apache.bcel.generic.InvokeInstruction.toString(InvokeInstruction.java:59) at org.apache.bcel.classfile.ConstantPoolTestCase.testConstantToString(ConstantPoolTestCase.java:29) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497) at junit.framework.TestCase.runTest(TestCase.java:176) at junit.framework.TestCase.runBare(TestCase.java:141) at junit.framework.TestResult$1.protect(TestResult.java:122) at junit.framework.TestResult.runProtected(TestResult.java:142) at junit.framework.TestResult.run(TestResult.java:125) at junit.framework.TestCase.run(TestCase.java:129) at junit.framework.TestSuite.runTest(TestSuite.java:252) at junit.framework.TestSuite.run(TestSuite.java:247) at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:42) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:253) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:84) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147) I attached patch and a unit test. GitHub user KyongSik-Yoon opened a pull request: https://github.com/apache/commons-bcel/pull/9 BCEL-277 Resolve constant to a string representation occur NoSuchElementException in case CONSTANT_NameAndType constant. A method that constantToString of ConstantPool class always occur NoSuchElementException when face with costant type of CONSTANT_NameAndType. A reason is invalid separator for StringTokenizer that colon. It should be replaced to empty string. I had pull request include ConstantPoolTestCase. You can merge this pull request into a Git repository by running: $ git pull https://github.com/KyongSik-Yoon/commons-bcel BCEL-277 Alternatively you can review and apply these changes as the patch at: https://github.com/apache/commons-bcel/pull/9.patch To close this pull request, make a commit to your master/trunk branch with (at least) the following in the commit message: This closes #9 commit 53e91a2259a3656ef81334d00bc2bfea2b14d626 Author: sam <sam1287@gmail.com> Date: 2016-07-28T10:52:06Z BCEL-277 Resolve constant to a string representation occur NoSuchElementException in case CONSTANT_NameAndType constant. $ svn ci -m "BCEL-277: Resolving the String representation of a constant throws NoSuchElementException in case of CONSTANT_NameAndType constant. Thanks to Sam Yoon. This also closes #9 from GitHub."Sending        src/changes/changes.xmlSending        src/main/java/org/apache/bcel/classfile/ConstantPool.javaAdding         src/test/java/org/apache/bcel/classfile/ConstantPoolTestCase.javaAdding         src/test/java/org/apache/bcel/data/SimpleClassWithDefaultConstructor.javaTransmitting file data ....doneCommitting transaction...Committed revision 1754483. Thank you! Github user asfgit closed the pull request at: https://github.com/apache/commons-bcel/pull/9];
BCEL-278;[BCEL-278] InvokeInstruction.toString(final ConstantPool cp) throws NoSuchElementException;Fixed;Resolved;Unassigned;1471470208000;1556367432000;Bug;[];[];[Compile JasminVisitor.java and execute with self class as parameter. Exception in thread "main" java.util.NoSuchElementExceptionat java.util.StringTokenizer.nextToken(StringTokenizer.java:349)at org.apache.bcel.generic.InvokeInstruction.toString(InvokeInstruction.java:58)at JasminVisitor.visitCode(JasminVisitor.java:268)at org.apache.bcel.classfile.Code.accept(Code.java:132)at org.apache.bcel.classfile.DescendingVisitor.visitCode(DescendingVisitor.java:179)at org.apache.bcel.classfile.Code.accept(Code.java:132)at org.apache.bcel.classfile.DescendingVisitor.visitMethod(DescendingVisitor.java:162)at org.apache.bcel.classfile.Method.accept(Method.java:108)at org.apache.bcel.classfile.DescendingVisitor.visitJavaClass(DescendingVisitor.java:99)at org.apache.bcel.classfile.JavaClass.accept(JavaClass.java:213)at org.apache.bcel.classfile.DescendingVisitor.visit(DescendingVisitor.java:85)at JasminVisitor.disassemble(JasminVisitor.java:77)at JasminVisitor.main(JasminVisitor.java:333)];[GitHub user valery-barysok opened a pull request: https://github.com/apache/commons-bcel/pull/11 BCEL-278: Resolving NoSuchElementException You can merge this pull request into a Git repository by running: $ git pull https://github.com/valery-barysok/commons-bcel trunk Alternatively you can review and apply these changes as the patch at: https://github.com/apache/commons-bcel/pull/11.patch To close this pull request, make a commit to your master/trunk branch with (at least) the following in the commit message: This closes #11 commit f7bf3250a2a6e7f45bb1261e31c8ed2c979b149b Author: Valery Barysok <valery.barysok@gmail.com> Date: 2016-08-17T21:49:41Z BCEL-278: Resolving NoSuchElementException in InvokeInstruction.toString(final ConstantPool cp) In git master.];
BCEL-279;[BCEL-279] Utility.methodSignature* throw ClassFormatException when converting binary names with generics.;Unresolved;Open;Unassigned;1471618977000;0;Bug;[bcel279.patch];[];[When I try the following, Utility class throws ClassFormatException: String sig = "<T:Ljava/lang/Object.>(Lcom/google/common/io/ByteProcessor<TT.>.)TT."Utility.methodSignatureArgumentTypes(sig, false) The above signature actually exists in com.google.common.io.ByteSource in Google Guava. Utility.methodSignatureReturnType does not throw any exception but its return value does not look valid. When I try this: String sig = "<T:Ljava/lang/Object.>(Lcom/google/common/io/ByteProcessor<TT.>.)TT."Utility.methodSignaturerReturnType(sig, false) expected: java.lang.Object actual: T It seems that org.apache.bcel.generic.Type.java also has the same issue. Dongsun.];[The signature processing in BCEL has not been updated to support generic types. I have been trying to add some support (see https://issues.apache.org/jira/browse/BCEL-286) but the code really needs a complete rewrite. It should probably be modified to use sun.reflect.generics.parser. markro, Where does this ticket stand now that BCEL-286 is closed? There are still two problems here. The first is there is no code in BCEL to deal with Type Parameters. This is the major rewrite mentioned above and it is why methodSignatureReturnType returns T instead of java.lang.Object. The second is that because we don't know anything about type parameters we assert the the first character of a method signature must be "(". This has a simple fix, but the returned argument types would still have the problem of not expanding type parameters. I could do part two quite easily in a day. Part one would probably take longer and I would need to clear the time with my manager. I have gone over this is some detail and believe that the methods in Utility.java will now scan most any Signature. (Can't do Interface without an arg list change to include flags so can tell difference between Class and Interface.) I have updated the test case as well. Please review patch and let me know of any issues. I have submitted a patch that adds a lot of the missing features. > markro, Did you rebase your patch on git master. I am getting: {nofomat} git apply c:\temp\bcel279.patch.txt error: patch failed: src/main/java/org/apache/bcel/classfile/LocalVariable.java:26 error: src/main/java/org/apache/bcel/classfile/LocalVariable.java: patch does not apply May you please provide a GitHub PR instead? Thank you, Gary I created a branch (BCEL-279) with the changes for my pull request but I don't have permission to push to it. I guess I don't understand the expected workflow when you say you accept pull requests via github. Thanks, Mark > You have to fork the Apache repo first and then you push branches to your forked repo. see https://help.github.com/en/articles/about-pull-requests https://github.com/apache/commons-bcel/pull/32];
BCEL-280;[BCEL-280] MethodGen.setMaxLocals() should take in account local variables defined in Local Variable table;Unresolved;Open;Unassigned;1472898088000;0;Bug;[sample-project.zip];[];[Kotlin compiler generates additional fake local variables that are not used in method code, after processing such methods with BCEL fake variables are kept in local variable table but maxLocals value decreased to number of locals used in method bytecode. As result "java.lang.ClassFormatError: Invalid index 6 in LocalVariableTable in class file test/Bug2" exception is thrown at runtime on attemt to load newly generated class. Sample code: bug.kt package bugimport org.apache.bcel.classfile.ClassParserimport org.apache.bcel.generic.ClassGenimport org.apache.bcel.generic.MethodGenclass Bug {    fun test() {        val list = arrayListOf(1, 2, 3)        list.forEach {            println(it)        }       //here additional variable are generated - see bytecode below    }}fun main(args: Array<String>) {    val parser = ClassParser(ClassLoader.getSystemClassLoader().getResourceAsStream("bug/Bug.class"), "Bug.class").    val javaClass = parser.parse().    val classGen = ClassGen(javaClass)    classGen.className = "test.Bug2"    val originalMethod = classGen.methods.filter { it.name == "test" }.single()    classGen.removeMethod(originalMethod)    val newMethodGen = MethodGen(originalMethod, classGen.className, classGen.constantPool)    newMethodGen.setMaxLocals()    val newMethod = newMethodGen.method    classGen.addMethod(newMethod)    val bug2Class = classGen.javaClass//    Exception in thread "main" java.lang.ClassFormatError: Invalid index 6 in LocalVariableTable in class file test/Bug2//    at java.lang.ClassLoader.defineClass1(Native Method)//    at java.lang.ClassLoader.defineClass(ClassLoader.java:760)//    at java.lang.ClassLoader.defineClass(ClassLoader.java:642)//    at bug.BugKt$main$1.findClass(bug.kt:53)//    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)//    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)//    at bug.BugKt.main(bug.kt:58)    object : ClassLoader(ClassLoader.getSystemClassLoader()) {        @Throws(ClassNotFoundException::class)        protected override fun findClass(name: String): Class<*> {            if (name == "test.Bug2") {                val bytes = bug2Class.bytes                return defineClass(name, bytes, 0, bytes.size)            }            return super.findClass(name)        }    }.loadClass("test.Bug2").newInstance()    //8 != 6    assert(originalMethod.code.maxLocals == newMethod.code.maxLocals)} Bug.test() original bytecode  // access flags 0x11  public final test()V   L0    LINENUMBER 9 L0    ICONST_3    ANEWARRAY java/lang/Integer    DUP    ICONST_0    ICONST_1    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer.    AASTORE    DUP    ICONST_1    ICONST_2    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer.    AASTORE    DUP    ICONST_2    ICONST_3    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer.    AASTORE    INVOKESTATIC kotlin/collections/CollectionsKt.arrayListOf ([Ljava/lang/Object.)Ljava/util/ArrayList.    ASTORE 1   L1    LINENUMBER 10 L1    ALOAD 1    CHECKCAST java/lang/Iterable    ASTORE 2    NOP   L2    LINENUMBER 56 L2    ALOAD 2    INVOKEINTERFACE java/lang/Iterable.iterator ()Ljava/util/Iterator.    ASTORE 3   L3    ALOAD 3    INVOKEINTERFACE java/util/Iterator.hasNext ()Z    IFEQ L4    ALOAD 3    INVOKEINTERFACE java/util/Iterator.next ()Ljava/lang/Object.    ASTORE 4   L5    ALOAD 4    CHECKCAST java/lang/Number    INVOKEVIRTUAL java/lang/Number.intValue ()I    ISTORE 5   L6    LINENUMBER 11 L6    NOP   L7    GETSTATIC java/lang/System.out : Ljava/io/PrintStream.    ILOAD 5    INVOKEVIRTUAL java/io/PrintStream.println (I)V   L8   L9    LINENUMBER 11 L9   L10    LINENUMBER 12 L10   L11    NOP   L12    GOTO L3   L4    LINENUMBER 57 L4   L13   L14    LINENUMBER 14 L14    RETURN   L15    LOCALVARIABLE it I L6 L11 5    LOCALVARIABLE $i$a$1$forEach I L6 L11 6    LOCALVARIABLE element$iv Ljava/lang/Object. L5 L12 4    LOCALVARIABLE $receiver$iv Ljava/lang/Iterable. L2 L13 2    LOCALVARIABLE $i$f$forEach I L2 L13 7    LOCALVARIABLE list Ljava/util/ArrayList. L1 L15 1    LOCALVARIABLE this Lbug/Bug. L0 L15 0    MAXSTACK = 4    MAXLOCALS = 8];[We welcome PRs on GitHub];
BCEL-281;[BCEL-281] Not Compatible w/ Java 8;Duplicate;Closed;Unassigned;1478615059000;1478628796000;Bug;[];[];[When executing the mvn install after upgrading to Java 1.8, the project failed to compile. I've included the Pom entries and stack trace. Plugin: org.jibx:maven-jibx-plugin:1.2.6:bind Error: java.lang.IllegalStateException: Error loading class java.lang.CharSequence: Error reading path java/lang/CharSequence.class for class java.lang.CharSequence pom.xml:     <dependency>      <groupId>org.apache.bcel</groupId>      <artifactId>bcel</artifactId>      <version>${bcel.ver}</version>    </dependency>...  <plugin><groupId>org.jibx</groupId><artifactId>maven-jibx-plugin</artifactId><version>${maven-jibx-plugin.ver}</version><configuration>  <includes><includes>*-binding.xml</includes>  </includes></configuration><executions>  <execution><goals>  <goal>bind</goal></goals>  </execution></executions>  </plugin> Stack Trace [ERROR] Failed to execute goal org.jibx:maven-jibx-plugin:1.2.6:bind (default) on project pts2-core: Error loading class java.lang.CharSequence: Error reading path java/lang/CharSequence.class for class java.lang.CharSequence -> [Help1]org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.jibx:maven-jibx-plugin:1.2.6:bind (default) on project pts2-core: Error loading class java.lang.CharSequence: Error reading path java/lang/CharSequence.class for class java.lang.CharSequence        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:212)        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)        at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:116)        at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:80)        at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)        at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)        at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:307)        at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:193)        at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:106)        at org.apache.maven.cli.MavenCli.execute(MavenCli.java:863)        at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:288)        at org.apache.maven.cli.MavenCli.main(MavenCli.java:199)        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)        at java.lang.reflect.Method.invoke(Method.java:498)        at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)        at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)        at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)        at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)Caused by: org.apache.maven.plugin.MojoExecutionException: Error loading class java.lang.CharSequence: Error reading path java/lang/CharSequence.class for class java.lang.CharSequence        at org.jibx.maven.AbstractBaseBindingMojo.compile(AbstractBaseBindingMojo.java:166)        at org.jibx.maven.AbstractBaseBindingMojo.execute(AbstractBaseBindingMojo.java:133)        at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134)        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:207)        ... 20 moreCaused by: java.lang.IllegalStateException: Error loading class java.lang.CharSequence: Error reading path java/lang/CharSequence.class for class java.lang.CharSequence        at org.jibx.binding.classes.ClassCache$ClassCacheLocator.getClassInfo(ClassCache.java:291)        at org.jibx.binding.model.ClassHierarchyContext.accumulateInterfaces(ClassHierarchyContext.java:95)        at org.jibx.binding.model.ClassHierarchyContext.addTypedComponent(ClassHierarchyContext.java:121)        at org.jibx.binding.model.DefinitionContext.addFormat(DefinitionContext.java:527)        at org.jibx.binding.model.BindingElement.defineBaseFormat(BindingElement.java:843)        at org.jibx.binding.model.BindingElement.runValidation(BindingElement.java:865)        at org.jibx.binding.model.BindingElement.runValidation(BindingElement.java:899)        at org.jibx.binding.model.BindingElement.validateBinding(BindingElement.java:969)        at org.jibx.binding.Utility.validateBinding(Utility.java:226)        at org.jibx.binding.Utility.loadBinding(Utility.java:269)        at org.jibx.binding.Utility.loadFileBinding(Utility.java:420)        at org.jibx.binding.Compile.compile(Compile.java:217)        at org.jibx.maven.AbstractBaseBindingMojo.compile(AbstractBaseBindingMojo.java:163)        ... 23 more];[Looking into the stack trace, I don't see BCEL involved. So, what makes you blame BCEL? Duplicate of BCEL-282. FYI - It was an issue w/ an older version (pre 6.0). The stack trace was swallowed. All that is left is Error loading class java.lang.CharSequence: Error reading path java/lang/CharSequence On Tue, Nov 8, 2016 at 9:45 AM, Jochen Wiedmann (JIRA) <jira@apache.org>];
BCEL-282;[BCEL-282] Not Compatible w/ Java 8;Invalid;Closed;Unassigned;1478615062000;1478628751000;Bug;[];[];[When executing the mvn install after upgrading to Java 1.8, the project failed to compile. I've included the Pom entries and stack trace. Plugin: org.jibx:maven-jibx-plugin:1.2.6:bind Error: java.lang.IllegalStateException: Error loading class java.lang.CharSequence: Error reading path java/lang/CharSequence.class for class java.lang.CharSequence pom.xml:     <dependency>      <groupId>org.apache.bcel</groupId>      <artifactId>bcel</artifactId>      <version>${bcel.ver}</version>    </dependency>...  <plugin><groupId>org.jibx</groupId><artifactId>maven-jibx-plugin</artifactId><version>${maven-jibx-plugin.ver}</version><configuration>  <includes><includes>*-binding.xml</includes>  </includes></configuration><executions>  <execution><goals>  <goal>bind</goal></goals>  </execution></executions>  </plugin> Stack Trace [ERROR] Failed to execute goal org.jibx:maven-jibx-plugin:1.2.6:bind (default) on project pts2-core: Error loading class java.lang.CharSequence: Error reading path java/lang/CharSequence.class for class java.lang.CharSequence -> [Help1]org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.jibx:maven-jibx-plugin:1.2.6:bind (default) on project pts2-core: Error loading class java.lang.CharSequence: Error reading path java/lang/CharSequence.class for class java.lang.CharSequence        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:212)        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)        at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:116)        at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:80)        at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)        at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)        at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:307)        at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:193)        at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:106)        at org.apache.maven.cli.MavenCli.execute(MavenCli.java:863)        at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:288)        at org.apache.maven.cli.MavenCli.main(MavenCli.java:199)        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)        at java.lang.reflect.Method.invoke(Method.java:498)        at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)        at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)        at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)        at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)Caused by: org.apache.maven.plugin.MojoExecutionException: Error loading class java.lang.CharSequence: Error reading path java/lang/CharSequence.class for class java.lang.CharSequence        at org.jibx.maven.AbstractBaseBindingMojo.compile(AbstractBaseBindingMojo.java:166)        at org.jibx.maven.AbstractBaseBindingMojo.execute(AbstractBaseBindingMojo.java:133)        at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134)        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:207)        ... 20 moreCaused by: java.lang.IllegalStateException: Error loading class java.lang.CharSequence: Error reading path java/lang/CharSequence.class for class java.lang.CharSequence        at org.jibx.binding.classes.ClassCache$ClassCacheLocator.getClassInfo(ClassCache.java:291)        at org.jibx.binding.model.ClassHierarchyContext.accumulateInterfaces(ClassHierarchyContext.java:95)        at org.jibx.binding.model.ClassHierarchyContext.addTypedComponent(ClassHierarchyContext.java:121)        at org.jibx.binding.model.DefinitionContext.addFormat(DefinitionContext.java:527)        at org.jibx.binding.model.BindingElement.defineBaseFormat(BindingElement.java:843)        at org.jibx.binding.model.BindingElement.runValidation(BindingElement.java:865)        at org.jibx.binding.model.BindingElement.runValidation(BindingElement.java:899)        at org.jibx.binding.model.BindingElement.validateBinding(BindingElement.java:969)        at org.jibx.binding.Utility.validateBinding(Utility.java:226)        at org.jibx.binding.Utility.loadBinding(Utility.java:269)        at org.jibx.binding.Utility.loadFileBinding(Utility.java:420)        at org.jibx.binding.Compile.compile(Compile.java:217)        at org.jibx.maven.AbstractBaseBindingMojo.compile(AbstractBaseBindingMojo.java:163)        ... 23 more];[What makes you think this is a BCEL issue as opposed to a jibx issue? Gary It looks like that was related to an earlier version. Closing ticket.];
BCEL-283;[BCEL-283] Support for StackMap should be different from StackMapTable;Fixed;Closed;Benedikt Ritter;1478711051000;1504121001000;Bug;[Appendix1-verifier.pdf, Attribute.diff, ClassFileCMP-SE6.0.pdf];[];[It turns out we made a mistake with the StackMap renaming changes. I ran into a problem decoding some old .class files and went back to the Java Specification Requests (JSRs) to try and understand the history of the StackMap attribute. While I was not able to get the complete story, I have a pretty good guess at what happened and it does explain the problem I have seen. The official introduction of StackMaps appears to be JSR 202 from (approx.) Sept. 2006 and it is part of JDK6 (see attached spec) . However, StackMaps were originally proposed much earlier (approx.) March 2002 - see the attached verifier spec. It appears there were some implementations of this earlier specification - the ASM tool was one and there may be others. The key differences are: Typechecker Spec: StackMap attribute with fixed format and no frame type byte JDK 6 Spec: StackMapTable attribute with variable format including a frame type byte. The JVM and the javap tool support BOTH formats. BCEL recognizes both attribute names, but treats them the same, as JDK6 version. I don't think the changes will be too difficult. I will create a proposed fix within the next few days.];[Hi markro, Any news on this? Just curious, Gary I have changed my mind on this - we do not need to support - in fact, we should disallow. StackMaps are not needed for Java versions < JDK6 and the new style StackMapTable is required for Java versions > JDK5. So I made a small change to Attribute.java that warns and ignores old style StackMaps. This worked fine for the problems I had observed. Added comment and diff with suggested change. Mark ~/w/a/c/commons-bcel > svn ci -m "BCEL-283: Support for StackMap should be different from StackMapTable. Thanks to Mark Roberts"Sending        src/changes/changes.xmlSending        src/main/java/org/apache/bcel/classfile/Attribute.javaTransmitting file data ..doneCommitting transaction...Committed revision 1806724. Thank you!];
BCEL-284;[BCEL-284] InvokeDynamic needs to override getReferenceType to return 'something' more right;Fixed;Closed;Unassigned;1481074178000;1481074716000;Bug;[];[];[InvokeDynamic inherits it's getReferenceType from FieldOrMethod which is the wrong implementation. It should override it, to java.lang.Object? null? not sure. probably Object];[svn commit 1773000.];
BCEL-285;[BCEL-285] "ClassFormatException: Invalid signature" thrown on generics;Unresolved;Open;Unassigned;1484687103000;0;Bug;[];[];[The following stripped down example throws an Exception in BCEL: Bar.java import java.io.IOException.import java.util.stream.Stream.import org.apache.bcel.classfile.ClassParser.public class Main {  public static void main(String[] args) throws IOException {    ClassParser parser = new ClassParser(Main.class.getResourceAsStream("Main.class"), "Main.class").    parser.parse().getMethods()[2].getCode().toString(). /* <- EXCEPTION thrown */    ((Stream<? extends Object>)null).peek(x -> {}). /* <- problem spot */  }} The exception is: Exception in thread "main" org.apache.bcel.classfile.ClassFormatException: Invalid signature: `!+Ljava/lang/Object.'at org.apache.bcel.classfile.Utility.signatureToString(Utility.java:930)at org.apache.bcel.classfile.LocalVariable.toStringShared(LocalVariable.java:187)at org.apache.bcel.classfile.LocalVariableTypeTable.toString(LocalVariableTypeTable.java:121)at java.lang.String.valueOf(String.java:2994)at java.lang.StringBuilder.append(StringBuilder.java:131)at org.apache.bcel.classfile.Code.toString(Code.java:316)at org.apache.bcel.classfile.Code.toString(Code.java:328)at Main.main(Main.java:9) This problem only occurs in eclipse (I am using NEON.2) and does not occur in Intellij (I am using 2016.3.2). This probably indicates that ecj and javac differ in their class code generator. Since our project uses sonar:findbugs which uses BCEL this is a major problem for us.];[This does look like an invalid signature to me. The error message does not show the entire signature, just the part it could not parse. The "!" should not be there. The remainder of the signature (after the !) looks correct and corresponds to "extends Object" the "?" should have been compiled into a "*" in the signature. Perhaps this is a bug in the compiler you mention that it is using "!" instead of "*"? Where is Main.class? No idea. My comments are based on reading the information in the bug report. I don't have access to either of the compilers mentioned. Probably should ask original reporter.];
BCEL-286;[BCEL-286] Utility.signatureToString fails if a method has multiple type arguments;Fixed;Closed;Benedikt Ritter;1487171130000;1505234244000;Bug;[Utility.diff];[];[signatureToString (in classfile/Utility.java) gets confused if a method has multiple type arguments. I have included a patch for fix and update to test-case that demonstrates the problem.];[I found more problems and have expanded the fix and the test case. The revised changes are in signature2.diff. The signature processing in BCEL has only a little support for generic types. I have been trying to add some more support but the code really needs a complete rewrite. It should probably be modified to use sun.reflect.generics.parser. Hello markro, this patch does not apply because of missing target: 'src/test/java/org/apache/bcel/PLSE2TestCase.java'. Can you update your diff? Thank you! Sorry about that. There was some duplication in our local tests. I have deleted PLSE2TestCase and updated UtilityTestCase instead. New Utility.diff should be good to go. ~/w/a/c/commons-bcel > svn ci -m "BCEL-286: Utility.signatureToString fails if a method has multiple type arguments. Thanks to Mark Roberts."Sending        src/changes/changes.xmlSending        src/main/java/org/apache/bcel/classfile/Utility.javaSending        src/test/java/org/apache/bcel/classfile/UtilityTestCase.javaTransmitting file data ...doneCommitting transaction...Committed revision 1808131. Thank you!];
BCEL-287;[BCEL-287] IINC does not handle -128 properly;Fixed;Resolved;Benedikt Ritter;1487973315000;1504121324000;Bug;[IINC.diff];[];[src/main/java/org/apache/bcel/generic/IINC.java is only allowing -127 to +127 as an argument. it should allow -128 as well. I have attached a patch.];[~/w/a/c/commons-bcel > svn ci -m "BCEL-287: IINC does not handle -128 properly. Thanks to Mark Roberts"Sending        src/changes/changes.xmlSending        src/main/java/org/apache/bcel/generic/IINC.javaTransmitting file data ..doneCommitting transaction...Committed revision 1806726.];
BCEL-288;[BCEL-288] NoSuchElementException in org.apache.bcel.generic.InvokeInstruction.toString();Unresolved;Open;Unassigned;1488128745000;0;Bug;[];[];[When I run JasminVisitor example I get: java.util.NoSuchElementExceptionat java.util.StringTokenizer.nextToken(StringTokenizer.java:349)at org.apache.bcel.generic.InvokeInstruction.toString(InvokeInstruction.java:59) Possible bug fix in `org.apache.bcel.generic.InvokeInstruction`, add ":" as delimiter in the `java.util.StringTokenizer`:     /**     * @return mnemonic for instruction with symbolic references resolved     */    @Override    public String toString( final ConstantPool cp ) {        final Constant c = cp.getConstant(super.getIndex()).        final StringTokenizer tok = new StringTokenizer(cp.constantToString(c), ":").        return Const.getOpcodeName(super.getOpcode()) + " " + tok.nextToken().replace('.', '/')                + tok.nextToken().    }];[];
BCEL-289;[BCEL-289] Crash when parsing constructor of inner classes with parameters annotated;Fixed;Closed;Bruno P. Kinoshita;1494946366000;1495176237000;Bug;[];[];[BCEL crashes when parsing the constructor of an inner class whose parameters are annotated. For instance, when parsing the jar obtained from the following classes: public @interface A {}public @interface B {}public class Test {    public class Inner {public Inner(@A Object a, @B Object b) {}    }} In particular: ClassParser cp = new ClassParser(args[0]).ClassGen cg = new ClassGen(cp.parse()).MethodGen mg = new MethodGen(cg.getMethodAt(0), cg.getClassName(), cg.getConstantPool()).mg.getAnnotationsOnParameter(0). (where args[0] points to Test$Inner.class) you get Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 2at org.apache.bcel.generic.MethodGen.ensureExistingParameterAnnotationsUnpacked(MethodGen.java:1120)at org.apache.bcel.generic.MethodGen.getAnnotationsOnParameter(MethodGen.java:1073)];[Reproduced issue locally. Didn't have time to debug with latest from master branch, nor to investigate it very deeply. If anyone feels like jumping in and having a look, feel free (-: Noticed that removing the annotations the issue is gone. Not sure what's the problem. As far as I can understand (I'm debugging with the code of release 6.0), it seems that there is a problem with the syntetic parameter of the inner constructor: at bytecode level, the signature of the constructor is: public void <init>(Test arg0, Object arg1, Object arg2)  The code raising the exception is the first line of the following for loop: for (int j = 0. j < arg_types.length. j++) {  // This returns Annotation[] ...  final ParameterAnnotationEntry immutableArray = rpa  .getParameterAnnotationEntries()[j].  // ... which needs transforming into an AnnotationGen[] ...  final List<AnnotationEntryGen> mutable = makeMutableVersion(immutableArray.getAnnotationEntries()).  // ... then add these to any we already know about  param_annotations[j].addAll(mutable). } When I debug class MethodGen just before the exception is raisen, I see that: arg_types is: [Test, java.lang.Object, java.lang.Object] rpa.parameter_annotation_table (returned by getParameterAnnotationEntries) is: [@LA., @LB.] It looks like when rpa (RuntimeVisibleParameterAnnotations) is built it does not take into account the syntectic parameter. rpa comes from the field attribute_vect. If you don't have any annotation on parameters, I expect attribute_vect to be an empty collection, so the body of the for loop wrapping the code crashing is never executed. Hope this helps! Reproduced with BCEL 6.1-SNAPSHOT. pferrara thanks for the detailed report. Yesterday I didn't have much time to debug the issue. Will try to debug in the next days with the latest version from master branch (i.e. BCEL 6.1-SNAPSHOT) and see if there is an easy way to fix it. But if you find a way to fix it before, feel free to submit a pull request and/or update this ticket. Cheers Bruno kinow honestly I do not think I'm in position to propose a fix for this: I am not sure whether the problem is just in the for loop raising the exception (and the fix might be rather straightforward if one can know that a parameter is syntetic), or in how parameter_annotation_table is built (and here I would have no idea where to start). I think the best is if you can give a look and find out where the problem is (and obviously no problem at all if it will take some time!). Thanks! GitHub user kinow opened a pull request: https://github.com/apache/commons-bcel/pull/13 BCEL-289: iterate through parameter annotation entries using the right limit The code was iterating through the number of parameters (3 in this case, the Bar parent class, and the two annotated parameters, while looking for annotated parameters. As the constructor method has two annotated parameters, it throws an ArrayIndexOutOfBoundsException. Found no pull requests with this fix, Maven site reports look OK, no new warnings/errors added, added a simple unit test. As I never contributed to BCEL, will drop a message to the mailing list asking for someone to review it before I merge it. Cheers Bruno You can merge this pull request into a Git repository by running: $ git pull https://github.com/kinow/commons-bcel BCEL-289 Alternatively you can review and apply these changes as the patch at: https://github.com/apache/commons-bcel/pull/13.patch To close this pull request, make a commit to your master/trunk branch with (at least) the following in the commit message: This closes #13 commit d60291173e4d4a589873338547d968a540210507 Author: Bruno P. Kinoshita <brunodepaulak@yahoo.com.br> Date: 2017-05-18T09:37:07Z BCEL-289: iterate through parameter annotation entries using the right limit Pull request submitted pferrara feel free to give it a try and comment if that works for you. Included a test case based on your example. Will drop an e-mail to the mailing list as I never really used much BCEL, nor know the code base very well. Cheers Bruno kinow The fix works, thank you very much!!! Pull request merged in Subversion. The sync process takes a while normally, so we may have to wait minutes/hours till it is marked as closed in GitHub, and the ASF bot comments here. Should be included in BCEL 6.1. Thanks! Bruno Github user asfgit closed the pull request at: https://github.com/apache/commons-bcel/pull/13 Time to migrate to Git then? +1 that would be great];
BCEL-290;[BCEL-290] Verifier reports 'Constant pool at index 0 is null' for invokedynamic;Duplicate;Resolved;Unassigned;1497028646000;1497029043000;Bug;[];[];[When the BCEL Verifier encounters an invokedynamic bytecode (such as those generated by javac for lambdas), it throws a org.apache.bcel.classfile.ClassFormatException in Pass3a reporting that "Constant pool at index 0 is null." Test case: public class Bug3 {    public Runnable foo() {return () -> {}.    }} Output: JustIce by Enver Haase, (C) 2001-2002.<http://bcel.sourceforge.net><http://commons.apache.org/bcel>Now verifying: Bug3Pass 1:VERIFIED_OKPassed verification.Pass 2:VERIFIED_OKPassed verification.Pass 3a, method number 0 ['public void <init>()']:VERIFIED_OKPassed verification.Pass 3b, method number 0 ['public void <init>()']:VERIFIED_OKPassed verification.Exception in thread "main" org.apache.bcel.classfile.ClassFormatException: Constant pool at index 0 is null.at org.apache.bcel.classfile.ConstantPool.getConstant(ConstantPool.java:258)at org.apache.bcel.classfile.ConstantPool.getConstantString(ConstantPool.java:293)at org.apache.bcel.generic.FieldOrMethod.getReferenceType(FieldOrMethod.java:116)at org.apache.bcel.generic.FieldOrMethod.getLoadClassType(FieldOrMethod.java:133)at org.apache.bcel.verifier.statics.Pass3aVerifier$InstOperandConstraintVisitor.visitLoadClass(Pass3aVerifier.java:521)at org.apache.bcel.generic.INVOKEDYNAMIC.accept(INVOKEDYNAMIC.java:114)at org.apache.bcel.generic.InstructionHandle.accept(InstructionHandle.java:302)at org.apache.bcel.verifier.statics.Pass3aVerifier.pass3StaticInstructionOperandsChecks(Pass3aVerifier.java:443)at org.apache.bcel.verifier.statics.Pass3aVerifier.do_verify(Pass3aVerifier.java:208)at org.apache.bcel.verifier.PassVerifier.verify(PassVerifier.java:71)at org.apache.bcel.verifier.Verifier.doPass3a(Verifier.java:89)at org.apache.bcel.verifier.Verifier.main(Verifier.java:216)];[];
BCEL-291;[BCEL-291] Verifier rejects invokevirtual on array: org.apache.bcel.generic.ClassGenException: [Ljava/lang/Object does not represent an ObjectType;Unresolved;Reopened;Unassigned;1497029455000;0;Bug;[];[];[If a Java program invokes a java.lang.Object method on a variable whose static type is an array, the methodref associated with the invokevirtual will refer to an array class. When the BCEL verifier encounters such a class, it fails with a ClassGenException. Test case: public class Bug1 {    public static Object[] bug(Object[] arg) {return arg.clone().    }} Outoput: JustIce by Enver Haase, (C) 2001-2002.<http://bcel.sourceforge.net><http://commons.apache.org/bcel>Now verifying: Bug1Pass 1:VERIFIED_OKPassed verification.Pass 2:VERIFIED_OKPassed verification.Pass 3a, method number 0 ['public void <init>()']:VERIFIED_OKPassed verification.Pass 3b, method number 0 ['public void <init>()']:VERIFIED_OKPassed verification.Exception in thread "main" org.apache.bcel.generic.ClassGenException: [Ljava/lang/Object. does not represent an ObjectTypeat org.apache.bcel.generic.FieldOrMethod.getLoadClassType(FieldOrMethod.java:137)at org.apache.bcel.verifier.statics.Pass3aVerifier$InstOperandConstraintVisitor.visitLoadClass(Pass3aVerifier.java:521)at org.apache.bcel.generic.INVOKEVIRTUAL.accept(INVOKEVIRTUAL.java:85)at org.apache.bcel.generic.InstructionHandle.accept(InstructionHandle.java:302)at org.apache.bcel.verifier.statics.Pass3aVerifier.pass3StaticInstructionOperandsChecks(Pass3aVerifier.java:443)at org.apache.bcel.verifier.statics.Pass3aVerifier.do_verify(Pass3aVerifier.java:208)at org.apache.bcel.verifier.PassVerifier.verify(PassVerifier.java:71)at org.apache.bcel.verifier.Verifier.doPass3a(Verifier.java:89)at org.apache.bcel.verifier.Verifier.main(Verifier.java:216)];[Added test org.apache.bcel.verifier.JiraBcel291TestCase.];
BCEL-295;[BCEL-295] Incorrect live range information in LocalVariableGen;Fixed;Resolved;Unassigned;1507648676000;1512246332000;Bug;[LocalVariableGen.diff];[];[(Not sure of priority - blocker for me, but probably of little consequence for most clients.) There is a design flaw with the treatment of local variable live ranges. In the .class file these are demarcated via byte code offsets into the method's instructions. The range is from start up to, but not including, the length. If the live range lasts through the end of the method, then length points to the first byte 'past' the end of the method. BCEL converts these offsets into InstructionHandles and in doing so can no longer differentiate between a live range that ends prior to the last instruction of the method or one that includes the last instruction of the method. How to fix this is a bit of a problem. The 'correct' solution would seem to be to keep end as a null InstructionHandle as indicated by some of the comments. Unfortunately, LocalVariableGen does not have access to the method's InstructionList and thus cannot easily convert this null pointer back to the correct length for output. We could grab the InstructionHandle for start and then count the instruction bytes as we iterate to the end. But all this still begs the question of the fact this would be a change in behavior - a client would now have to check for a null end handle before dereferencing. The proposed fix I have attached takes another approach. It sets a flag in the constructor if the initial value for end is null and then lets all else proceed unchanged. A client may test this flag to see if the special case is active. Also, the getLocalVariable method uses this flag to correctly set the length on output. I believe this approach would have no effect on existing code. We would only need to document the new flag for clients that might care.];[The patch is small and seems OK at first glance but I am not comfortable applying without a matching unit test. I do appreciate the low/no impact WRT compatibility. That's a plus What do others think? I might have time to provide a unit test next week. GitHub user markro49 opened a pull request: https://github.com/apache/commons-bcel/pull/17 BCEL-295 fix local variable live range length. add test case You can merge this pull request into a Git repository by running: $ git pull https://github.com/markro49/commons-bcel bcel295 Alternatively you can review and apply these changes as the patch at: https://github.com/apache/commons-bcel/pull/17.patch To close this pull request, make a commit to your master/trunk branch with (at least) the following in the commit message: This closes #17 commit 9bda4c39979c184c4aa73bf99c93387bbbbf30d1 Author: Mark Roberts <markro@cs.washington.edu> Date: 2017-10-13T20:06:11Z fix local variable live range length. add test case Github user asfgit closed the pull request at: https://github.com/apache/commons-bcel/pull/17 In svn trunk already.];
BCEL-297;[BCEL-297] Possible NPE in override implementation of Object.equals;Fixed;Resolved;Unassigned;1507658365000;1549898844000;Bug;[];[];[classfile/JavaClass.java: classfile/Field.java: classfile/Constant.java: classfile/Method.java: generic/FieldGen.java: generic/MethodGen.java: all define a bcelComparator that overrides Object.equals. However, they will throw a null pointer exception for myConstant.equals(null) instead of returning false. This non-standard behavior should either be corrected or documented.];[Hey, markro We can just use Objects.equals to avoid this issue. Instead of throw a null pointer exception. but a false instead. I will give a PR to this issue. Thanks. GitHub user zhangminglei opened a pull request: https://github.com/apache/commons-bcel/pull/20 BCEL-297 Fix NPE in BCELComparator concrete implementations. This PR fix the potential NPE. You can merge this pull request into a Git repository by running: $ git pull https://github.com/zhangminglei/commons-bcel BCEL-297 Alternatively you can review and apply these changes as the patch at: https://github.com/apache/commons-bcel/pull/20.patch To close this pull request, make a commit to your master/trunk branch with (at least) the following in the commit message: This closes #20 commit 2338bf801caf437c3ee11cc666d2054c8f56d968 Author: zhangminglei <zml13856086071@163.com> Date: 2017-11-04T12:43:35Z BCEL-297 Fix NPE in BCELComparator concrete implementations. In git master. Please verify and close.];
BCEL-299;[BCEL-299] Fix example src/examples/ClassDumper.java ClassDumper.processID().;Fixed;Closed;Unassigned;1509800605000;1562439019000;Bug;[];[];[In ClassDumper.java example , We can not resolve symbol Constants.JVM_CLASSFILE_MAGIC in processID method as Constants does not have a JVM_CLASSFILE_MAGIC constant number.];[GitHub user zhangminglei opened a pull request: https://github.com/apache/commons-bcel/pull/21 BCEL-299 Fix resolve symbol error You can merge this pull request into a Git repository by running: $ git pull https://github.com/zhangminglei/commons-bcel BCEL-299 Alternatively you can review and apply these changes as the patch at: https://github.com/apache/commons-bcel/pull/21.patch To close this pull request, make a commit to your master/trunk branch with (at least) the following in the commit message: This closes #21 commit 0f61c7c18f46d8bdb96e05b290baf629811ac6f1 Author: zhangminglei <zml13856086071@163.com> Date: 2017-11-04T13:14:18Z BCEL-299 Fix resolve symbol error Resolved independently in git master now.];
BCEL-302;[BCEL-302] Ancient jakarta branch;Unresolved;Open;Unassigned;1518713373000;0;Bug;[];[];[The repository at https://github.com/apache/commons-bcel/branches contains a branch named "jakarta" that has not been updated in 7 years. Can this branch be deleted in order to clean up the repossitory?];[];
BCEL-303;[BCEL-303] AssertionViolatedException in Pass 3A Verification of invoke instructions;Unresolved;Open;Unassigned;1529990603000;0;Bug;[A.class];[];[The verifier throws an assertion violation / INTERNAL ERROR in pass 3A when verifying a malformed class file. As I understand it, the issue is that if class A implements interface B, then class A can be pass stage 1 verification even if class B is not resolved. However, pass 3A verification of code that invokes a method defined on class A assumes that the receiver type and all its interfaces are fully resolved. Steps to reproduce: Save the attached file as "example/A.class" and run: java -cp <classpath> org.apache.bcel.verifier.Verifier example.A The file A.class was generated automatically by the fuzzer JQF (https://github.com/rohanpadhye/jqf). Expected output: VERIFIED_REJECTED Observed output: JustIce by Enver Haase, (C) 2001-2002. <http://bcel.sourceforge.net> <http://commons.apache.org/bcel> Now verifying: example.A Pass 1: VERIFIED_OK Passed verification. Pass 2: VERIFIED_OK Passed verification. Exception in thread "main" org.apache.bcel.verifier.exc.AssertionViolatedException: INTERNAL ERROR: Missing class: java.lang.ClassNotFoundException: Exception while looking for class example.I0: java.io.IOException: Couldn't find: example/I0.class at org.apache.bcel.verifier.statics.Pass3aVerifier$InstOperandConstraintVisitor.visitINVOKEVIRTUAL(Pass3aVerifier.java:1315) at org.apache.bcel.generic.INVOKEVIRTUAL.accept(INVOKEVIRTUAL.java:89) at org.apache.bcel.generic.InstructionHandle.accept(InstructionHandle.java:302) at org.apache.bcel.verifier.statics.Pass3aVerifier.pass3StaticInstructionOperandsChecks(Pass3aVerifier.java:443) at org.apache.bcel.verifier.statics.Pass3aVerifier.do_verify(Pass3aVerifier.java:208) at org.apache.bcel.verifier.PassVerifier.verify(PassVerifier.java:71) at org.apache.bcel.verifier.Verifier.doPass3a(Verifier.java:89) at org.apache.bcel.verifier.Verifier.main(Verifier.java:216) Caused by: java.lang.ClassNotFoundException: Exception while looking for class example.I0: java.io.IOException: Couldn't find: example/I0.class at org.apache.bcel.util.MemorySensitiveClassPathRepository.loadClass(MemorySensitiveClassPathRepository.java:97) at org.apache.bcel.classfile.JavaClass.getInterfaces(JavaClass.java:847) at org.apache.bcel.verifier.statics.Pass3aVerifier$InstOperandConstraintVisitor.getMethodRecursive(Pass3aVerifier.java:1181) at org.apache.bcel.verifier.statics.Pass3aVerifier$InstOperandConstraintVisitor.visitINVOKEVIRTUAL(Pass3aVerifier.java:1304) ... 7 more Caused by: java.io.IOException: Couldn't find: example/I0.class at org.apache.bcel.util.ClassPath.getClassFile(ClassPath.java:279) at org.apache.bcel.util.ClassPath.getInputStream(ClassPath.java:209) at org.apache.bcel.util.ClassPath.getInputStream(ClassPath.java:188) at org.apache.bcel.util.MemorySensitiveClassPathRepository.loadClass(MemorySensitiveClassPathRepository.java:95) ... 10 more];[The A class file you provided is not in a Java package, therefore I cannot add it along with all of your other classes with the exact same unpackaged class name to our src/test/resources folder. It would be great if you could provide class files in a package named after something like jqf_0, jqf_1, and son on. This would allow us to add these files as src/test/resources/jqf_0/Hello.class, src/test/resources/jqf_1/A.class, and so on. The class files attached with this bug report and similar ones that I submitted (BCEL-303, BCEL-307, BCEL-308, BCEL-309, BCEL-310, BCEL-311, BCEL-312, BCEL-313) are all automatically generated by a fuzzer. I do not have corresponding source to compile with package names. Do you know of a tool for editing the bytecode directly to add a package name? Thanks. Otherwise, I would suggest not including all these test cases in the same classpath, but instead having the tests use a temporary class loader to load these package-less classes from a given directory. Fixed with https://github.com/apache/commons-bcel/pull/117];
BCEL-304;[BCEL-304] ClassPath.getClassFile() and friends do not work with JDK 9 and higher;Fixed;Closed;Gary D. Gregory;1531853616000;1532754117000;Bug;[];[];[When trying to get the class file for Java classes (ie. java.lang.String), an IOException is thrown: Exception in thread "main" java.io.IOException: Couldn't find: java.lang.String.class at org.apache.bcel.util.ClassPath.getClassFile(ClassPath.java:279) at org.apache.bcel.util.ClassPath.getClassFile(ClassPath.java:301) at bcel.test.GetClassFileTest.main(GetClassFileTest.java:12) The root cause appears to be the restructuring of Java starting with Java 9. Specifically, the removal of the rt.jar. The above excpetion can be reproduced using a simple application: package bcel.test. import java.io.IOException. import org.apache.bcel.util.ClassPath. public class GetClassFileTest { public static void main(String[] args) throws IOException { String className = "java.lang.String". System.out.println("Looking up ClassPath.ClassFile for: " + className). ClassPath.ClassFile classFile = ClassPath.SYSTEM_CLASS_PATH.getClassFile(className). if (classFile != null) { System.out.println("Class file base: " + classFile.getBase()). System.out.println("Class file path: " + classFile.getPath()). } } } Running this on Java 8 produces the following output, whereas running it on Java 9+ produces the IOException: Class file base: C:\jdk1.8.0_161\jre\lib\rt.jar Class file path: java/lang/String.class];[I pulled the commons-bcel code to investigate and found a potential solution: 1. In ClassPath.getClassPath(), add the *.jomd files in JAVA_HOME/jmods to the classpath list. (Perhaps include a property for greater flexibility.) 2. In ClassPath.Zip.getClassFile(String, String), include logic to look up a ZipEntry in a .jmod file. The structure of the jmod file differs slightly from a jar file in that the .class files are in a classes directory so the zip.getEntry call needs to be told to look in that directory instead of the root. Hi epavlak, If you can provide a test case and/or solution via a GitHub PR [1], that would greatly accelerate any possible resolution. Thank you! Gary [1] https://github.com/apache/commons-bcel GitHub user epavlak opened a pull request: https://github.com/apache/commons-bcel/pull/22 BCEL-304 Include Java 9+ modules in path used by ClassPath.java With the restructuring of Java .class files in Java 9 and higher to be in modules instead of the rt.jar, the ClassPath.getClassFile method would fail to find Java class files (ex: String.class). These modifications include the Java 9+ modules in the path used by ClassPath.java so that the .class files can be located. You can merge this pull request into a Git repository by running: $ git pull https://github.com/epavlak/commons-bcel BCEL-304 Alternatively you can review and apply these changes as the patch at: https://github.com/apache/commons-bcel/pull/22.patch To close this pull request, make a commit to your master/trunk branch with (at least) the following in the commit message: This closes #22 commit e331171f168ab335b9756294406e85d9995731bd Author: epavlak <epavlak@...> Date: 2018-07-27T19:50:30Z BCEL-304 Include Java 9+ modules in path used by ClassPath.java commit 98157fb61a547d8d4fe40826d1f863a1c1f1c374 Author: epavlak <epavlak@...> Date: 2018-07-27T19:53:58Z BCEL-304 Include Java 9+ modules in path used by ClassPath.java commit d5a73b6987eb262d90f809e3a2b77845fcce95d2 Author: epavlak <epavlak@...> Date: 2018-07-27T19:56:57Z BCEL-304 Include Java 9+ modules in path used by ClassPath.java I have created a PR. This is my first time doing so. If I have done anything incorrectly, please let me know. Hi epavlak, Thank you for your patch. The patch only works on a JDK, it does not solve the problem when running on a JRE since there is no jmods directory in a JRE Gary I applied a quite reworked version of the patch and changed this ticket description to say "JDK" instead of "Java". Dealing with a JRE will be in a new ticket. epavlak: Please verifty and close. Github user asfgit closed the pull request at: https://github.com/apache/commons-bcel/pull/22 Everything appears to be working as it should. Closing the defect. garydgregory, thanks for everything on this one. Do you have any information on when this will be included in a release? Nothing is scheduled ATM. If I were you I would tests the SNAPSHOT build out the wazoo on your Java 9 or above set up and report back on the dev mailing list once you are certain that nothing is missing or broken WRT Java >= 9. garydgregory, I wanted to follow-up and see if you had any information on when the 6.3 release will be available. It's becoming somewhat of a hot topic for us as we move applications to Java 9+. Thanks. epavlak, We do not have a release planned ATM. You might want to ping the dev mailing list and raise awareness for your need for a release. Gary];
BCEL-306;[BCEL-306] Why is this string.replace line needed in generic.ObjectType constructor?;Unresolved;Open;Unassigned;1534688845000;0;Bug;[];[];[Why is this line present in the ObjectType constructor: https://github.com/apache/commons-bcel/blob/5e2febea94ae56db7fd0729e808625f7be1f6a32/src/main/java/org/apache/bcel/generic/ObjectType.java#L45 The javadoc states that this constructor expects a fully qualified name(which do not contain '/'s). Is it some legacy stuff which is no longer needed since all the tests pass if I replace this line with this one: this.class_name = class_name.];[Let's see if anyone chimes in with some historical context...];
BCEL-307;[BCEL-307] ClassFormatException thrown in Pass 3A verification;Unresolved;Open;Unassigned;1534910706000;0;Bug;[A.class];[];[The verifier throws a ClassFormatException during Pass 3A verification of a malformed class file even though Pass 1 and Pass 2 have completed successfully. Note that the input class file is indeed malformed, however the verifier should ideally just return a verification result of REJECTED instead of throwing an unchecked run-time exception. Steps to reproduce: Save the attached file as "example/A.class" and run: java -cp <classpath> org.apache.bcel.verifier.Verifier example.A The file A.class was generated automatically by the fuzzer JQF (https://github.com/rohanpadhye/jqf). Expected output: VERIFIED_REJECTED Observed output: JustIce by Enver Haase, (C) 2001-2002. <http://bcel.sourceforge.net> <http://commons.apache.org/bcel> Now verifying: example.A Pass 1: VERIFIED_OK Passed verification. Pass 2: VERIFIED_OK Passed verification. Exception in thread "main" org.apache.bcel.classfile.ClassFormatException: Expected class `CONSTANT_InvokeDynamic' at index 14 and got CONSTANT_Methodref[10](class_index = 13, name_and_type_index = 11) at org.apache.bcel.classfile.ConstantPool.getConstant(ConstantPool.java:261) at org.apache.bcel.classfile.ConstantPool.constantToString(ConstantPool.java:207) at org.apache.bcel.classfile.Utility.codeToString(Utility.java:373) at org.apache.bcel.classfile.Utility.codeToString(Utility.java:157) at org.apache.bcel.classfile.Code.toString(Code.java:306) at org.apache.bcel.classfile.Code.toString(Code.java:328) at java.lang.String.valueOf(String.java:2994) at java.lang.StringBuilder.append(StringBuilder.java:131) at org.apache.bcel.verifier.statics.Pass3aVerifier.delayedPass2Checks(Pass3aVerifier.java:289) at org.apache.bcel.verifier.statics.Pass3aVerifier.do_verify(Pass3aVerifier.java:200) at org.apache.bcel.verifier.PassVerifier.verify(PassVerifier.java:71) at org.apache.bcel.verifier.Verifier.doPass3a(Verifier.java:89) at org.apache.bcel.verifier.Verifier.main(Verifier.java:216)];[The bug occurs when Pass 3A is attempting to internally throw a ClassConstraintException (which if thrown properly would indeed result in the expected VERIFICATION_REJECTED). however, the generation of the error message for this exception itself fails when attempting to call the toString() method on the Code attribute, leading to the uncaught ClassFormatException leaking out of the API. We welcome pull requests with unit tests: https://github.com/apache/commons-bcel The A class file you provided is not in a Java package, therefore I cannot add it along with all of your other classes with the exact same unpackaged class name to our src/test/resources folder. It would be great if you could provide class files in a package named after something like jqf_0, jqf_1, and son on. This would allow us to add these files as src/test/resources/jqf_0/Hello.class, src/test/resources/jqf_1/A.class, and so on. Fixed with https://github.com/apache/commons-bcel/pull/117];
BCEL-308;[BCEL-308] NullPointerException in Verifier Pass 3A;Unresolved;Open;Unassigned;1534991934000;0;Bug;[Hello.class];[];[Verifier throws NPE on malformed input instead of reporting verification failure. Steps to reproduce: Save the attached file as "Hello.class" and run: java -cp <classpath> org.apache.bcel.verifier.Verifier Hello The file Hello.class was generated automatically by the fuzzer JQF (https://github.com/rohanpadhye/jqf). Expected output: VERIFIED_REJECTED Observed output: JustIce by Enver Haase, (C) 2001-2002. <http://bcel.sourceforge.net> <http://commons.apache.org/bcel> Now verifying: Hello Pass 1: VERIFIED_OK Passed verification. Pass 2: VERIFIED_OK Passed verification. Exception in thread "main" java.lang.NullPointerException at org.apache.bcel.generic.FieldOrMethod.getReferenceType(FieldOrMethod.java:116) at org.apache.bcel.generic.FieldOrMethod.getLoadClassType(FieldOrMethod.java:133) at org.apache.bcel.verifier.statics.Pass3aVerifier$InstOperandConstraintVisitor.visitLoadClass(Pass3aVerifier.java:521) at org.apache.bcel.generic.INVOKESPECIAL.accept(INVOKESPECIAL.java:86) at org.apache.bcel.generic.InstructionHandle.accept(InstructionHandle.java:302) at org.apache.bcel.verifier.statics.Pass3aVerifier.pass3StaticInstructionOperandsChecks(Pass3aVerifier.java:443) at org.apache.bcel.verifier.statics.Pass3aVerifier.do_verify(Pass3aVerifier.java:208) at org.apache.bcel.verifier.PassVerifier.verify(PassVerifier.java:71) at org.apache.bcel.verifier.Verifier.doPass3a(Verifier.java:89) at org.apache.bcel.verifier.Verifier.main(Verifier.java:216)];[We welcome pull requests with unit tests: https://github.com/apache/commons-bcel The Hello class file you provided is not in a Java package, therefore I cannot add it along with all of your other classes with the exact same unpackaged class name to our src/test/resources folder. It would be great if you could provide class files in a package named after something like jqf_0, jqf_1, and son on. This would allow us to add these files as src/test/resources/jqf_0/Hello.class, src/test/resources/jqf_1/Hello.class, and so on. Fixed with https://github.com/apache/commons-bcel/pull/117];
BCEL-309;[BCEL-309] NegativeArraySizeException when Code attribute length is negative;Unresolved;Open;Unassigned;1534992363000;0;Bug;[Hello.class];[];[Class parser throws an undocumented NegativeArraySizeException when parsing a malformed class file. Steps to reproduce: Attempt to parse the attached file "Hello.class" using the API org.apache.bcel.classfile.ClassParser.parse(java.io.InputStream) The file Hello.class was generated automatically by the fuzzer JQF (https://github.com/rohanpadhye/jqf). Expected output: ClassFormatException should be thrown as the class file is malformed. Observed output: Undocumented run-time exception is thrown: java.lang.NegativeArraySizeException at org.apache.bcel.classfile.Code.<init>(Code.java:75) at org.apache.bcel.classfile.Attribute.readAttribute(Attribute.java:220) at org.apache.bcel.classfile.FieldOrMethod.<init>(FieldOrMethod.java:109) at org.apache.bcel.classfile.Method.<init>(Method.java:82) at org.apache.bcel.classfile.ClassParser.readMethods(ClassParser.java:294) at org.apache.bcel.classfile.ClassParser.parse(ClassParser.java:153) This is probably because the length of the Code attribute in a method is read as a 4-byte signed integer, an an array of that size is allocated without checking to see if the integer is negative.];[We welcome pull requests with unit tests: https://github.com/apache/commons-bcel The Hello class file you provided is not in a Java package, therefore I cannot add it along with all of your other classes with the exact same unpackaged class name to our src/test/resources folder. It would be great if you could provide class files in a package named after something like jqf_0, jqf_1, and son on. This would allow us to add these files as src/test/resources/jqf_0/Hello.class, src/test/resources/jqf_1/Hello.class, and so on. It is common practice to read the code_length value e.g. using readInt(). The JVM specification mandates that the code_length does not exceed 65536, see https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.9.1 Also when running javap on the class it generates an error: public static void main(java.lang.String[]). descriptor: ([Ljava/lang/String.)V flags: (0x0009) ACC_PUBLIC, ACC_STATICError: Unexpected or invalid value for Code attributeError: java.lang.reflect.InvocationTargetException Code: length = 0x25 00 02 00 F5 3D 85 1B FD B2 00 02 12 03 B6 00 04 B1 00 00 00 01 00 0A 00 00 00 0A 00 02 00 00 00 03 00 08 00 04 Also proguard can not process this class file, I would not consider this as a bug and rather close the issue as won't fix. The tool that processed this class file is more likely to contain a bug. Fixed with https://github.com/apache/commons-bcel/pull/117];
BCEL-310;[BCEL-310] ArrayIndexOutOfBounds in Verifier Pass 3A;Unresolved;Open;Unassigned;1534992640000;0;Bug;[Hello.class];[];[Verifier throws OOB on malformed input instead of reporting verification failure. Steps to reproduce: Save the attached file as "Hello.class" and run: java -cp <classpath> org.apache.bcel.verifier.Verifier Hello The file Hello.class was generated automatically by the fuzzer JQF (https://github.com/rohanpadhye/jqf). Expected output: VERIFIED_REJECTED Observed output: JustIce by Enver Haase, (C) 2001-2002. <http://bcel.sourceforge.net> <http://commons.apache.org/bcel> Now verifying: Hello Pass 1: VERIFIED_OK Passed verification. Pass 2: VERIFIED_OK Passed verification. Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: -73 at org.apache.bcel.Const.getTypeName(Const.java:1799) at org.apache.bcel.generic.NEWARRAY.toString(NEWARRAY.java:90) at org.apache.bcel.generic.Instruction.toString(Instruction.java:101) at java.lang.String.valueOf(String.java:2994) at java.lang.StringBuilder.append(StringBuilder.java:131) at org.apache.bcel.verifier.statics.Pass3aVerifier$InstOperandConstraintVisitor.constraintViolated(Pass3aVerifier.java:499) at org.apache.bcel.verifier.statics.Pass3aVerifier$InstOperandConstraintVisitor.visitNEWARRAY(Pass3aVerifier.java:835) at org.apache.bcel.generic.NEWARRAY.accept(NEWARRAY.java:125) at org.apache.bcel.generic.InstructionHandle.accept(InstructionHandle.java:302) at org.apache.bcel.verifier.statics.Pass3aVerifier.pass3StaticInstructionOperandsChecks(Pass3aVerifier.java:443) at org.apache.bcel.verifier.statics.Pass3aVerifier.do_verify(Pass3aVerifier.java:208) at org.apache.bcel.verifier.PassVerifier.verify(PassVerifier.java:71) at org.apache.bcel.verifier.Verifier.doPass3a(Verifier.java:8];[We welcome pull requests with unit tests: https://github.com/apache/commons-bcel The Hello class file you provided is not in a Java package, therefore I cannot add it along with all of your other classes with the exact same unpackaged class name to our src/test/resources folder. It would be great if you could provide class files in a package named after something like jqf_0, jqf_1, and son on. This would allow us to add these files as src/test/resources/jqf_0/Hello.class, src/test/resources/jqf_1/Hello.class, and so on. Running javap on the class file produces this output: public Hello(). descriptor: ()V flags: (0x0001) ACC_PUBLIC Code: stack=1, locals=1, args_size=1Error: A serious internal error has occurred: java.lang.NullPointerExceptionPlease file a bug report, and include the following information:java.lang.NullPointerException at jdk.jdeps/com.sun.tools.javap.CodeWriter$1.visitArrayType(CodeWriter.java:138) at jdk.jdeps/com.sun.tools.javap.CodeWriter$1.visitArrayType(CodeWriter.java:131) at jdk.jdeps/com.sun.tools.classfile.Instruction.accept(Instruction.java:258) at jdk.jdeps/com.sun.tools.javap.CodeWriter.writeInstr(CodeWriter.java:126) at jdk.jdeps/com.sun.tools.javap.CodeWriter.writeInstrs(CodeWriter.java:108) at jdk.jdeps/com.sun.tools.javap.CodeWriter.write(CodeWriter.java:75) at jdk.jdeps/com.sun.tools.javap.AttributeWriter.visitCode(AttributeWriter.java:235) at jdk.jdeps/com.sun.tools.javap.AttributeWriter.visitCode(AttributeWriter.java:87) at jdk.jdeps/com.sun.tools.classfile.Code_attribute.accept(Code_attribute.java:102) at jdk.jdeps/com.sun.tools.javap.AttributeWriter.write(AttributeWriter.java:112) at jdk.jdeps/com.sun.tools.javap.ClassWriter.writeMethod(ClassWriter.java:587) at jdk.jdeps/com.sun.tools.javap.ClassWriter.writeMethods(ClassWriter.java:471) at jdk.jdeps/com.sun.tools.javap.ClassWriter.write(ClassWriter.java:269) at jdk.jdeps/com.sun.tools.javap.JavapTask.write(JavapTask.java:836) at jdk.jdeps/com.sun.tools.javap.JavapTask.writeClass(JavapTask.java:655) at jdk.jdeps/com.sun.tools.javap.JavapTask.run(JavapTask.java:600) at jdk.jdeps/com.sun.tools.javap.JavapTask.run(JavapTask.java:450) at jdk.jdeps/com.sun.tools.javap.Main.main(Main.java:47) which is an indication that the class file is not well-formed. Fixed with https://github.com/apache/commons-bcel/pull/117];
BCEL-311;[BCEL-311] ClassCastException in Verifier Pass 2;Unresolved;Open;Unassigned;1534992736000;0;Bug;[Hello.class];[];[Verifier throws ClassCastException on malformed input instead of reporting verification failure. Steps to reproduce: Save the attached file as "Hello.class" and run: java -cp <classpath> org.apache.bcel.verifier.Verifier Hello The file Hello.class was generated automatically by the fuzzer JQF (https://github.com/rohanpadhye/jqf). Expected output: VERIFIED_REJECTED Observed output: JustIce by Enver Haase, (C) 2001-2002. <http://bcel.sourceforge.net> <http://commons.apache.org/bcel> Now verifying: Hello Pass 1: VERIFIED_OK Passed verification. Exception in thread "main" java.lang.ClassCastException: Illegal constant 'CONSTANT_Class[7](name_index = 21)' at index '5'. '<<Method>>' expects a 'class org.apache.bcel.classfile.ConstantUtf8'. at org.apache.bcel.verifier.statics.Pass2Verifier$CPESSC_Visitor.checkIndex(Pass2Verifier.java:372) at org.apache.bcel.verifier.statics.Pass2Verifier$CPESSC_Visitor.visitMethod(Pass2Verifier.java:622) at org.apache.bcel.classfile.Method.accept(Method.java:108) at org.apache.bcel.classfile.DescendingVisitor.visitMethod(DescendingVisitor.java:159) at org.apache.bcel.classfile.Method.accept(Method.java:108) at org.apache.bcel.classfile.DescendingVisitor.visitJavaClass(DescendingVisitor.java:99) at org.apache.bcel.classfile.JavaClass.accept(JavaClass.java:213) at org.apache.bcel.classfile.DescendingVisitor.visit(DescendingVisitor.java:85) at org.apache.bcel.verifier.statics.Pass2Verifier$CPESSC_Visitor.<init>(Pass2Verifier.java:361) at org.apache.bcel.verifier.statics.Pass2Verifier$CPESSC_Visitor.<init>(Pass2Verifier.java:317) at org.apache.bcel.verifier.statics.Pass2Verifier.constant_pool_entries_satisfy_static_constraints(Pass2Verifier.java:302) at org.apache.bcel.verifier.statics.Pass2Verifier.do_verify(Pass2Verifier.java:161) at org.apache.bcel.verifier.PassVerifier.verify(PassVerifier.java:71) at org.apache.bcel.verifier.Verifier.doPass2(Verifier.java:76) at org.apache.bcel.verifier.Verifier.main(Verifier.java:211)];[We welcome pull requests with unit tests: https://github.com/apache/commons-bcel The Hello class file you provided is not in a Java package, therefore I cannot add it along with all of your other classes with the exact same unpackaged class name to our src/test/resources folder. It would be great if you could provide class files in a package named after something like jqf_0, jqf_1, and son on. This would allow us to add these files as src/test/resources/jqf_0/Hello.class, src/test/resources/jqf_1/Hello.class, and so on. Running javap on the provided class produces this output: {Error: unexpected entry at #5 -- expected tag 1, found 7Error: invalid index #64400Error: invalid index #64400 public ??? ??????.Error: invalid index #64400 descriptor: ??? flags: (0x0001) ACC_PUBLIC Code:Error: invalid index #64400 which is an indication that the provided class is not well-formed. Fixed with https://github.com/apache/commons-bcel/pull/117];
BCEL-312;[BCEL-312] AssertionViolation: INTERNAL ERROR Please adapt StringRepresentation to deal with ConstantPackage in Verifier Pass 2;Unresolved;Open;Unassigned;1534992915000;0;Bug;[Hello.class];[];[Verifier pass 2 throws an INTERNAL ERROR on malformed input instead of reporting verification failure. Steps to reproduce: Save the attached file as "Hello.class" and run: java -cp <classpath> org.apache.bcel.verifier.Verifier Hello The file Hello.class was generated automatically by the fuzzer JQF (https://github.com/rohanpadhye/jqf). Expected output: VERIFIED_REJECTED Observed output: JustIce by Enver Haase, (C) 2001-2002. <http://bcel.sourceforge.net> <http://commons.apache.org/bcel> Now verifying: Hello Pass 1: VERIFIED_OK Passed verification. Exception in thread "main" org.apache.bcel.verifier.exc.AssertionViolatedException: INTERNAL ERROR: Please adapt 'class org.apache.bcel.verifier.statics.StringRepresentation' to deal with objects of class 'class org.apache.bcel.classfile.ConstantPackage'. at org.apache.bcel.verifier.statics.StringRepresentation.toString(StringRepresentation.java:110) at org.apache.bcel.verifier.statics.Pass2Verifier.tostring(Pass2Verifier.java:1569) at org.apache.bcel.verifier.statics.Pass2Verifier.access$100(Pass2Verifier.java:86) at org.apache.bcel.verifier.statics.Pass2Verifier$CPESSC_Visitor.checkIndex(Pass2Verifier.java:371) at org.apache.bcel.verifier.statics.Pass2Verifier$CPESSC_Visitor.visitConstantFieldref(Pass2Verifier.java:452) at org.apache.bcel.classfile.ConstantFieldref.accept(ConstantFieldref.java:69) at org.apache.bcel.classfile.DescendingVisitor.visitConstantFieldref(DescendingVisitor.java:295) at org.apache.bcel.classfile.ConstantFieldref.accept(ConstantFieldref.java:69) at org.apache.bcel.classfile.DescendingVisitor.visitConstantPool(DescendingVisitor.java:269) at org.apache.bcel.classfile.ConstantPool.accept(ConstantPool.java:91) at org.apache.bcel.classfile.DescendingVisitor.visitJavaClass(DescendingVisitor.java:105) at org.apache.bcel.classfile.JavaClass.accept(JavaClass.java:213) at org.apache.bcel.classfile.DescendingVisitor.visit(DescendingVisitor.java:85) at org.apache.bcel.verifier.statics.Pass2Verifier$CPESSC_Visitor.<init>(Pass2Verifier.java:361) at org.apache.bcel.verifier.statics.Pass2Verifier$CPESSC_Visitor.<init>(Pass2Verifier.java:317) at org.apache.bcel.verifier.statics.Pass2Verifier.constant_pool_entries_satisfy_static_constraints(Pass2Verifier.java:302) at org.apache.bcel.verifier.statics.Pass2Verifier.do_verify(Pass2Verifier.java:161) at org.apache.bcel.verifier.PassVerifier.verify(PassVerifier.java:71) at org.apache.bcel.verifier.Verifier.doPass2(Verifier.java:76) at org.apache.bcel.verifier.Verifier.main(Verifier.java:211)];[We welcome pull requests with unit tests: https://github.com/apache/commons-bcel The Hello class file you provided is not in a Java package, therefore I cannot add it along with all of your other classes with the exact same unpackaged class name to our src/test/resources folder. It would be great if you could provide class files in a package named after something like jqf_0, jqf_1, and son on. This would allow us to add these files as src/test/resources/jqf_0/Hello.class, src/test/resources/jqf_1/Hello.class, and so on. Fixed with https://github.com/apache/commons-bcel/pull/117];
BCEL-313;[BCEL-313] ClassFormatException: Invalid signature: Ljava/lang/String)V in Verifier Pass 3A;Unresolved;Open;Unassigned;1534993078000;0;Bug;[Hello.class];[];[Verifier pass 3A throws an unchecked ClassFormatException when presented with malformed input instead of returning a VERIFIER_REJECTED. Steps to reproduce: Save the attached file as "Hello.class" and run: java -cp <classpath> org.apache.bcel.verifier.Verifier Hello The file Hello.class was generated automatically by the fuzzer JQF (https://github.com/rohanpadhye/jqf). Expected output: VERIFIED_REJECTED Observed output: JustIce by Enver Haase, (C) 2001-2002. <http://bcel.sourceforge.net> <http://commons.apache.org/bcel> Now verifying: Hello Pass 1: VERIFIED_OK Passed verification. Pass 2: VERIFIED_OK Passed verification. Pass 3a, method number 0 ['public void <init>()']: VERIFIED_OK Passed verification. Pass 3b, method number 0 ['public void <init>()']: VERIFIED_OK Passed verification. Exception in thread "main" org.apache.bcel.classfile.ClassFormatException: Invalid signature: Ljava/lang/String)V at org.apache.bcel.classfile.Utility.signatureToString(Utility.java:850) at org.apache.bcel.generic.Type.getType(Type.java:217) at org.apache.bcel.generic.Type.getArgumentTypes(Type.java:256) at org.apache.bcel.generic.InvokeInstruction.getArgumentTypes(InvokeInstruction.java:134) at org.apache.bcel.verifier.statics.Pass3aVerifier$InstOperandConstraintVisitor.visitInvokeInstruction(Pass3aVerifier.java:721) at org.apache.bcel.generic.INVOKEVIRTUAL.accept(INVOKEVIRTUAL.java:88) at org.apache.bcel.generic.InstructionHandle.accept(InstructionHandle.java:302) at org.apache.bcel.verifier.statics.Pass3aVerifier.pass3StaticInstructionOperandsChecks(Pass3aVerifier.java:443) at org.apache.bcel.verifier.statics.Pass3aVerifier.do_verify(Pass3aVerifier.java:208) at org.apache.bcel.verifier.PassVerifier.verify(PassVerifier.java:71) at org.apache.bcel.verifier.Verifier.doPass3a(Verifier.java:89) at org.apache.bcel.verifier.Verifier.main(Verifier.java:216)];[We welcome pull requests with unit tests: https://github.com/apache/commons-bcel The Hello class file you provided is not in a Java package, therefore I cannot add it along with all of your other classes with the exact same unpackaged class name to our src/test/resources folder. It would be great if you could provide class files in a package named after something like jqf_0, jqf_1, and son on. This would allow us to add these files as src/test/resources/jqf_0/Hello.class, src/test/resources/jqf_1/Hello.class, and so on. Fixed with https://github.com/apache/commons-bcel/pull/117];
BCEL-316;[BCEL-316] org.apache.bcel.classfile.Attribute class and subclasses should NOT log to the console by default;Fixed;Closed;Gary D. Gregory;1555074164000;1555074354000;Bug;[];[];[org.apache.bcel.classfile.Attribute class and subclasses should NOT log to the console by default. To enable the logging that was previously going to System.err, set the system property org.apache.bcel.classfile.Attribute.debug to true.];[In git master.];
BCEL-325;[BCEL-325] ClassDumper crashes on a module-info.class;Fixed;Closed;Unassigned;1565637123000;1566943546000;Bug;[];[];[Looks like support missing for some of the newer Class/Module flags. I am working on changes to support these feautures. (Possibly related, PreformanceTest fails for me when trying to build/run on Java 9.)];[Pull request https://github.com/apache/commons-bcel/pull/33 fixes these problems.];
BCEL-328;[BCEL-328] java.util.EmptyStackException at org.apache.bcel.classfile.DescendingVisitor.visitModule (DescendingVisitor.java:592);Fixed;Closed;Unassigned;1569456524000;1569456653000;Bug;[];[];[---------- Forwarded message ---------From: Gary Gregory <garydgregory@gmail.com>Date: Wed, Sep 25, 2019 at 5:54 PMSubject: [bcel] java.util.EmptyStackException at org.apache.bcel.classfile.DescendingVisitor.visitModule (DescendingVisitor.java:592)To: Commons Developers List <dev@commons.apache.org>Hi All & Mark Roberts,It looks like I/we did not test BCEL 6.4.0 well enough or broadly enough.If I take git master for Apache Commons Pool and update the site report from 6.3.1 to 6.4.0:diff --git a/pom.xml b/pom.xmlindex c60f6a7..5207358 100644--- a/pom.xml+++ b/pom.xml@@ -213,7 +213,7 @@               <dependency>                 <groupId>org.apache.bcel</groupId>                 <artifactId>bcel</artifactId>-                <version>6.3.1</version>+                <version>6.4.0</version>               </dependency>             </dependencies>           </plugin>I get:[INFO] ------------------------------------------------------------------------[INFO] BUILD FAILURE[INFO] ------------------------------------------------------------------------[INFO] Total time:  06:11 min[INFO] Finished at: 2019-09-25T16:19:15-04:00[INFO] ------------------------------------------------------------------------[ERROR] Failed to execute goal org.apache.maven.plugins:maven-site-plugin:3.7.1:site (default-site) on project commons-pool2: Execution default-site of goal org.apache.maven.plugins:maven-site-plugin:3.7.1:site failed.: EmptyStackException -> [Help 1]org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.maven.plugins:maven-site-plugin:3.7.1:site (default-site) on project commons-pool2: Execution default-site of goal org.apache.maven.plugins:maven-site-plugin:3.7.1:site failed.    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:215)    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)    at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)    at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)    at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)    at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)    at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)    at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)    at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)    at java.lang.reflect.Method.invoke (Method.java:498)    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:282)    at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:225)    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:406)    at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:347)Caused by: org.apache.maven.plugin.PluginExecutionException: Execution default-site of goal org.apache.maven.plugins:maven-site-plugin:3.7.1:site failed.    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:148)    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)    at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)    at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)    at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)    at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)    at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)    at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)    at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)    at java.lang.reflect.Method.invoke (Method.java:498)    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:282)    at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:225)    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:406)    at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:347)Caused by: java.util.EmptyStackException    at java.util.Stack.peek (Stack.java:102)    at java.util.Stack.pop (Stack.java:84)    at org.apache.bcel.classfile.DescendingVisitor.visitModule (DescendingVisitor.java:592)    at org.apache.bcel.classfile.Module.accept (Module.java:102)    at org.apache.bcel.classfile.DescendingVisitor.visitJavaClass (DescendingVisitor.java:102)    at org.apache.bcel.classfile.JavaClass.accept (JavaClass.java:213)    at org.apache.maven.shared.jar.classes.JarClassesAnalysis.analyze (JarClassesAnalysis.java:132)    at org.apache.maven.report.projectinfo.dependencies.Dependencies.getJarDependencyDetails (Dependencies.java:258)    at org.apache.maven.report.projectinfo.dependencies.renderer.DependenciesRenderer.hasSealed (DependenciesRenderer.java:1142)    at org.apache.maven.report.projectinfo.dependencies.renderer.DependenciesRenderer.renderSectionDependencyFileDetails (DependenciesRenderer.java:531)    at org.apache.maven.report.projectinfo.dependencies.renderer.DependenciesRenderer.renderBody (DependenciesRenderer.java:230)    at org.apache.maven.reporting.AbstractMavenReportRenderer.render (AbstractMavenReportRenderer.java:80)    at org.apache.maven.report.projectinfo.DependenciesReport.executeReport (DependenciesReport.java:162)    at org.apache.maven.reporting.AbstractMavenReport.generate (AbstractMavenReport.java:251)    at org.apache.maven.plugins.site.render.ReportDocumentRenderer.renderDocument (ReportDocumentRenderer.java:230)    at org.apache.maven.doxia.siterenderer.DefaultSiteRenderer.render (DefaultSiteRenderer.java:349)    at org.apache.maven.plugins.site.render.SiteMojo.renderLocale (SiteMojo.java:198)    at org.apache.maven.plugins.site.render.SiteMojo.execute (SiteMojo.java:147)    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)    at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)    at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)    at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)    at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)    at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)    at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)    at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)    at java.lang.reflect.Method.invoke (Method.java:498)    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:282)    at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:225)    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:406)    at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:347)[ERROR][ERROR] Re-run Maven using the -X switch to enable full debug logging.[ERROR][ERROR] For more information about the errors and possible solutions, please read the following articles:[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/PluginExecutionExceptionWe are clearly missing some unit tests :-( Looking at org.apache.bcel.classfile.DescendingVisitor.visitModule (DescendingVisitor.java:592), the problem seems like push/pop are unbalanced:    /** @since 6.4.0 */    @Override    public void visitModule(final Module obj) {        stack.push(obj).        obj.accept(visitor).        final ModuleRequires[] rtable = obj.getRequiresTable().        for (final ModuleRequires element : rtable) {            element.accept(this).        }        final ModuleExports[] etable = obj.getExportsTable().        for (final ModuleExports element : etable) {            element.accept(this).        }        stack.pop().        final ModuleOpens[] otable = obj.getOpensTable().        for (final ModuleOpens element : otable) {            element.accept(this).        }        stack.pop().        final ModuleProvides[] ptable = obj.getProvidesTable().        for (final ModuleProvides element : ptable) {            element.accept(this).        }        stack.pop().    }Mark?Gary];[In git master.];
BCEL-329;[BCEL-329] MethodGen duplicates some attributes;Fixed;Resolved;Unassigned;1570814528000;1598747783000;Bug;[];[];[If you use MethodGen to modify a class file that contains RuntimeAnnotations or RuntimeParameterAnnotations then each call to getMethod will duplicate these annotations. This will cause a JVM failure at load time as only one annotation of each type is permitted.];[I have a fix available and will submit a pull request. Merged to git master.];
BCEL-331;[BCEL-331] Enforce contribution guidelines when committing;Unresolved;Open;Unassigned;1572118393000;0;Bug;[];[];[Two of the contribution guidelines at https://github.com/apache/commons-bcel#contributing are: Respect the code style. Create minimal diffs - disable on save actions like reformat source code or organize imports. These guidelines are not being respected in the BCEL codebase. As an example, conisder this commit: https://github.com/apache/commons-bcel/commit/d7292a3d9f2939f785ec74057d255e5df95846bf The commit ought to be just a few lines long, but instead it changed every line in two files by changing the line endings from Unix style to DOS style. This makes the commit history not helpful for understanding the changes, and it is extremely disruptive for people who are maintaining forks. This is not an isolated incident – there have been many other commits with the same problem. Could you please put a mechanism in place to encourage developers to follow the guidelines? Developers should set up their editor to maintain line endings, but that is not currently happening. Here are some suggestions: add a pre-commit hook that prevents commits that change line endings add a pre-commit hook that enforces a uniform line ending style (I don't care whether it is Unix or DOS, so long as no future commits change it). lock the master branch and require code reviews, to catch problems when a developer carelessly changes line endings Maybe you have other ideas for enforcing the guidelines. anything that prevents these disruptive commits from polluting the history would be fine with me. Thanks!];[The problems of line endings can be solved using .gitattributes with the text key. When I run the following on BCEL (these commands are provided on the Git documentation referenced above): $ echo "* text=auto" >.gitattributes$ git add --renormalize .$ git status        # Show files that will be normalized It identifies the following files for line ending changes: modified:   .travis.ymlmodified:   CONTRIBUTING.mdmodified:   NOTICE.txtmodified:   README.mdmodified:   docs/eps/classloader.figmodified:   docs/verifier/V_API_SD.epsmodified:   pom.xmlmodified:   src/changes/changes.xmlmodified:   src/conf/checkstyle.xmlmodified:   src/main/java/org/apache/bcel/classfile/DescendingVisitor.javamodified:   src/main/java/org/apache/bcel/classfile/FieldOrMethod.javamodified:   src/main/java/org/apache/bcel/generic/INVOKEDYNAMIC.javamodified:   src/main/java/org/apache/bcel/generic/InstructionHandle.javamodified:   src/main/java/org/apache/bcel/util/ModularRuntimeImage.javamodified:   src/site/xdoc/download_bcel.xmlmodified:   src/site/xdoc/index.xmlmodified:   src/site/xdoc/issue-tracking.xmlmodified:   src/site/xdoc/mail-lists.xmlmodified:   src/test/java/org/apache/bcel/HandleTestCase.javamodified:   src/test/java/org/apache/bcel/data/PLSETestClass2.javamodified:   src/test/java/org/apache/bcel/util/ClassPathTestCase.javamodified:   src/test/java/org/apache/bcel/util/ModularRuntimeImageTestCase.java So there are a few offending java source files and a few other in there too. I do not think that any files identified are not text files. The EPS files are human readable and editable.];
BCEL-333;[BCEL-333] InovokeStatic may refer to either a MethodRef or an InterfaceMethodRef;Fixed;Resolved;Unassigned;1581800299000;1598747803000;Bug;[];[];[Java 8 added support for static interfaces. This means that an invokestatic instruction may refer to either a CONSTANT_Methodref_info or a CONSTANT_InterfaceMethodref_info. See https://stackoverflow.com/questions/34360718/invokestatic-on-static-method-in-interface for a detailed explanation. Currently, if InstructionFactory.createInvoke sees an Const.INVOKEINTERFACE it generates an InterfaceMethodref and a Methodref otherwise. This is incorrect. I could not figure out any way to make the correct decision programmatically as the original instruction is not available. So I added an additional createInvoke method with a boolean argument that says whether or not to use an InterfaceMethodref. The semantics of the original createInvoke method are unchanged.];[https://github.com/apache/commons-bcel/pull/39 Merged to git master.];
BCEL-335;[BCEL-335] Fix jdk 11 javadoc error;Fixed;Resolved;Unassigned;1582574811000;1598747850000;Bug;[];[];[Some change for Javadoc in newer jdk versions causes src/main/java/org/apache/bcel/util/package.html to get: src/main/java/org/apache/bcel/util/package.html:36: error: unexpected end tag: </p>];[https://github.com/apache/commons-bcel/pull/41 Merged to git master.];
BCEL-337;[BCEL-337] StringIndexOutOfBounds in Pass 2 Verification of empty method names in the constant pool;Unresolved;Open;Unassigned;1588806828000;0;Bug;[A.class];[];[The verifier throws a StringOutOfBoundsException in pass 2 when verifying a malformed class file. It seems that this is related with the constant pool verifier assuming that method names are never empty. Steps to Reproduce: Save the attached file as "example/A.class" and run: java -cp <classpath> org.apache.bcel.verifier.Verifier example.A The class file was generated automatically by a fuzzing tool. Expected Output: VERIFIED_REJECTED Observed Output: JustIce by Enver Haase, (C) 2001-2002. {{ <http://bcel.sourceforge.net>}} {{ <https://commons.apache.org/bcel>}} Now verifying: example.A Pass 1: {{ VERIFIED_OK}} {{ Passed verification.}} Exception in thread "main" java.lang.StringIndexOutOfBoundsException: String index out of range: 0 {{ at java.lang.String.charAt(String.java:658)}} {{ at org.apache.bcel.verifier.statics.Pass2Verifier.validJavaLangMethodName(Pass2Verifier.java:1458)}} {{ at org.apache.bcel.verifier.statics.Pass2Verifier.validMethodName(Pass2Verifier.java:1432)}} {{ at org.apache.bcel.verifier.statics.Pass2Verifier.access$300(Pass2Verifier.java:85)}} {{ at org.apache.bcel.verifier.statics.Pass2Verifier$CPESSC_Visitor.visitMethod(Pass2Verifier.java:624)}} {{ at org.apache.bcel.classfile.Method.accept(Method.java:108)}} {{ at org.apache.bcel.classfile.DescendingVisitor.visitMethod(DescendingVisitor.java:158)}} {{ at org.apache.bcel.classfile.Method.accept(Method.java:108)}} {{ at org.apache.bcel.classfile.DescendingVisitor.visitJavaClass(DescendingVisitor.java:98)}} {{ at org.apache.bcel.classfile.JavaClass.accept(JavaClass.java:213)}} {{ at org.apache.bcel.classfile.DescendingVisitor.visit(DescendingVisitor.java:84)}} {{ at org.apache.bcel.verifier.statics.Pass2Verifier$CPESSC_Visitor.<init>(Pass2Verifier.java:360)}} {{ at org.apache.bcel.verifier.statics.Pass2Verifier$CPESSC_Visitor.<init>(Pass2Verifier.java:316)}} {{ at org.apache.bcel.verifier.statics.Pass2Verifier.constant_pool_entries_satisfy_static_constraints(Pass2Verifier.java:301)}} {{ at org.apache.bcel.verifier.statics.Pass2Verifier.do_verify(Pass2Verifier.java:160)}} {{ at org.apache.bcel.verifier.PassVerifier.verify(PassVerifier.java:70)}} {{ at org.apache.bcel.verifier.Verifier.doPass2(Verifier.java:75)}} {{ at org.apache.bcel.verifier.Verifier.verifyType(Verifier.java:221)}} {{ at org.apache.bcel.verifier.Verifier.main(Verifier.java:206)}}];[Fixed with https://github.com/apache/commons-bcel/pull/117];
BCEL-338;[BCEL-338] org.apache.bcel.generic.InstructionFactory.createInvoke() populates its internal ConstantPoolGen on bad input, then throws exception;Fixed;Resolved;Gary D. Gregory;1591050238000;1591050570000;Bug;[];[];[The method org.apache.bcel.generic.InstructionFactory.createInvoke() populates its internal ConstantPoolGen on bad input, then throws exception. Instead it should validate its input first.];[];
BCEL-339;[BCEL-339] Throw IllegalArgumentException, IllegalStateException, UnsupportedOperationException instead of RuntimeException;Fixed;Resolved;Gary D. Gregory;1591052424000;1591052533000;Bug;[];[];[Throw IllegalArgumentException, IllegalStateException, UnsupportedOperationException instead of RuntimeException. Throwing RuntimeException is a code smell.];[];
BCEL-341;[BCEL-341] Incorrectly reads and writes class version <= 45.2 (oak) class file.;Unresolved;Open;Unassigned;1596958508000;0;Bug;[];[];[Whenever you attempt to parse a class file (version <= 45.2) the parser will incorrectly read the class file due to the code attribute's maxStack, maxLocals, and codeLength being half size data types.];[];
BCEL-357;[BCEL-357] StringIndexOutOfBoundsException when Verifying Java Method Name in Pass2Verifier;Unresolved;Open;Unassigned;1630683697000;0;Bug;[str_index.input];[];[StringIndexOutOfBoundsException found during fuzzing research. Attaching file that triggred the Exception. Stack trace: Exception in thread "main" java.lang.StringIndexOutOfBoundsException: String index out of range: 0at java.lang.String.charAt(String.java:658)at org.apache.bcel.verifier.statics.Pass2Verifier.validJavaLangMethodName(Pass2Verifier.java:1458)at org.apache.bcel.verifier.statics.Pass2Verifier.validMethodName(Pass2Verifier.java:1432)at org.apache.bcel.verifier.statics.Pass2Verifier.validClassMethodName(Pass2Verifier.java:1448)at org.apache.bcel.verifier.statics.Pass2Verifier.access$900(Pass2Verifier.java:85)at org.apache.bcel.verifier.statics.Pass2Verifier$FAMRAV_Visitor.visitConstantMethodref(Pass2Verifier.java:1350)at org.apache.bcel.classfile.ConstantMethodref.accept(ConstantMethodref.java:68)at org.apache.bcel.classfile.DescendingVisitor.visitConstantMethodref(DescendingVisitor.java:347)at org.apache.bcel.classfile.ConstantMethodref.accept(ConstantMethodref.java:68)at org.apache.bcel.classfile.DescendingVisitor.visitConstantPool(DescendingVisitor.java:268)at org.apache.bcel.classfile.ConstantPool.accept(ConstantPool.java:87)at org.apache.bcel.classfile.DescendingVisitor.visitJavaClass(DescendingVisitor.java:104)at org.apache.bcel.classfile.JavaClass.accept(JavaClass.java:213)at org.apache.bcel.classfile.DescendingVisitor.visit(DescendingVisitor.java:84)at org.apache.bcel.verifier.statics.Pass2Verifier.field_and_method_refs_are_valid(Pass2Verifier.java:1290)at org.apache.bcel.verifier.statics.Pass2Verifier.do_verify(Pass2Verifier.java:161)at org.apache.bcel.verifier.PassVerifier.verify(PassVerifier.java:70)at org.apache.bcel.verifier.Verifier.doPass2(Verifier.java:75) ];[];
BCEL-358;[BCEL-358] IllegalArgumentException when loading abstract classes;Unresolved;Open;Unassigned;1630684470000;0;Bug;[illegalarg.input];[];[Found during fuzzing research. IllegalArgumentException due to empty class name passed when loading interfaces. Stack Trace: Exception in thread "main" java.lang.IllegalArgumentException: Invalid class name at org.apache.bcel.util.AbstractClassPathRepository.loadClass(AbstractClassPathRepository.java:67)at org.apache.bcel.util.MemorySensitiveClassPathRepository.loadClass(MemorySensitiveClassPathRepository.java:33)at org.apache.bcel.classfile.JavaClass.getInterfaces(JavaClass.java:847)at org.apache.bcel.verifier.statics.Pass3aVerifier$InstOperandConstraintVisitor.getMethodRecursive(Pass3aVerifier.java:1181)at org.apache.bcel.verifier.statics.Pass3aVerifier$InstOperandConstraintVisitor.visitINVOKESTATIC(Pass3aVerifier.java:1279)at org.apache.bcel.generic.INVOKESTATIC.accept(INVOKESTATIC.java:86)at org.apache.bcel.generic.InstructionHandle.accept(InstructionHandle.java:293)at org.apache.bcel.verifier.statics.Pass3aVerifier.pass3StaticInstructionOperandsChecks(Pass3aVerifier.java:443)at org.apache.bcel.verifier.statics.Pass3aVerifier.do_verify(Pass3aVerifier.java:208)at org.apache.bcel.verifier.PassVerifier.verify(PassVerifier.java:70)at org.apache.bcel.verifier.Verifier.doPass3a(Verifier.java:88)];[];
BCEL-359;[BCEL-359] ClassGenException in Pass3aVerifier;Unresolved;Open;Unassigned;1630688237000;0;Bug;[classgen.input];[];[Found while conducting fuzzing research. ClassGenException within Pass3aVerifier. Exception in thread "main" org.apache.bcel.generic.ClassGenException: org.apache.bcel.generic.ArrayType [[Ljava/util/List. does not represent an ObjectTypeat org.apache.bcel.generic.FieldOrMethod.getLoadClassType(FieldOrMethod.java:138)at org.apache.bcel.verifier.statics.Pass3aVerifier$InstOperandConstraintVisitor.visitLoadClass(Pass3aVerifier.java:521)at org.apache.bcel.generic.INVOKESPECIAL.accept(INVOKESPECIAL.java:85)at org.apache.bcel.generic.InstructionHandle.accept(InstructionHandle.java:293)at org.apache.bcel.verifier.statics.Pass3aVerifier.pass3StaticInstructionOperandsChecks(Pass3aVerifier.java:443)at org.apache.bcel.verifier.statics.Pass3aVerifier.do_verify(Pass3aVerifier.java:208)at org.apache.bcel.verifier.PassVerifier.verify(PassVerifier.java:70)at org.apache.bcel.verifier.Verifier.doPass3a(Verifier.java:88)];[];
BCEL-360;[BCEL-360] LDC with class constant should fail if writing class file for older JDK;Unresolved;Open;Unassigned;1644000514000;0;Bug;[MakeBadClassFile.java];[];[LDC with a constant of type Class is allowed since JDK 5 only. ClassGen should give an error when this command is used in a class file with a too low setMajor() value. Currently ClassGen will happily produce a broken class file in this case. As ClassGen defaults to writing class files for JDK 1.1, this issue is quite easy to be confused by. More info and example program: https://lists.apache.org/thread/psmzvyz46c78wg4xjotx5xfwrrdc7s4y];[];
BCEL-361;[BCEL-361] LineNumber.toString() treats code offset as signed;Unresolved;Open;Unassigned;1647814790000;0;Bug;[];[];[Method code offsets run form 0 to max of 65535, but LineNumber.toString() treats as signed and gets offsets >32767 wrong.];[Fix is https://github.com/apache/commons-bcel/pull/118.];
BCEL-362;[BCEL-362] Handling for Constants.CONSTANT_Dynamic is missing in class ConstantPool;Fixed;Resolved;Unassigned;1656143223000;1660586615000;Bug;[];[];[Disclaimer: I am not a byte code buff, so if I am misunderstanding anything here, please forgive me for raising a stupid issue, try to be patient and explain it to me. When looking at the class ConstantPool, it seems as if condy is not being handled in methods constantToString(Constant), addConstant(Constant, ConstantPool), addConstantDynamic(int, int) (method does not exist, not sure if it would be necessary). I would have expected something like case Constants.CONSTANT_Dynamic with proper handling for this case in the first two methods. When using BCEL in order to parse class files using condy, like JaCoCo creates them, this causes errors. FYI, we are using BCEL code in AspectJ, and whenever people combine it with JaCoCo, corresponding problems occur.];[Some kind of reaction would be much appreciated after one month. Even if you think that this is invalid, an explanation would be helpful. My working hypothesis is that something is wrong in BCEL, but it is entirely possible that I as a layman am simply misunderstanding something here. Hello kriegaex I'm no byte code guru either but I think the a PR with a failing test would help. Then we'd have something concrete to consider. You did not state what version you are using. Well, there must be some byte code gurus among the group of commiters here, I would think. Otherwise, it would be impossible to maintain a project like this in the first place. I would like to get feedback from a maintainer first, if the places in the code base, which I pointed to, are obviously lacking code handling condy or not. Maybe I as a user misunderstand something and my code is wrong. My reproducer would only reproduce a problem we have in AspectJ, which would not help you debug anything in BCEL in isolation. Actually, I do not "speak BCEL" at all. But you could try instrumenting some Java code with JaCoCo and then somehow transform it with BCEL and see if you hit the same problems without involving AspectJ. I think that the details I provided so far should be enough for a BCEL committer to verify this problem. Update: I think I just had an idea how to reproduce this without AspectJ. Locally, I was able to reproduce the problem already, basically by instrumenting code with JaCoCo, writing it to disk and then passing the generated class through your JasminVisitor example class. But I need to clean up the example a little more first with regard to the Maven build. Unfortunately, I am in a hurry to go to a concert this evening, but I guess in the next few days I can upload something for you. It should be easy for you to also reproduce it, simply following my textual description. I am using JaCoCo 0.8.8 and BCEL 6.5.0 in my example project. Hi kriegaex I can't take the time to do the kind of research you are suggesting at this time. I can take the time to review PRs though. Maybe other folks will opine here. My FOSS time is limited Sorry if I am asking a naive question, but not knowing anything about the BCEL project team, I would like to know if you are the only active commiter or if there are others who are both byte code buffs (which you say you are not) and might have time to look into this issue. As an AspectJ committer, my FOSS time is also very limited. In my daytime job, I am not even a developer but an agile coach. My last money I made with coding ~20 years ago. The issue I am raising here is not about some kind of minor bug, but rather about a very basic feature of the JVM which was introduced in Java 11 (released in September 2018) and which BCEL does not seem to fully support to this date. I was and am trying to support you by pre-qualifying this issue on your behalf as best I can with my very limited knowledge, but I think that an active BCEL maintainer should find the root cause and be able to fix it with a very small investment of time. If you want to say that BCEL is not actively maintained anymore but merely kept alive, just say so clearly, and I will talk to the AspectJ project lead, asking him to consider switching from BCEL to ASM. The switch would be a hassle, but the current situation is a blocker, too, which is suboptimal as well. Of course that is none of your concerns, I am merely explaining my situation. Hi kriegaex I am not aware of other developers' schedule so I can only speak for myself and I am indeed an active maintainer here and in all of Apache Commons (over 20 components), I just do not have the need in my current projects to accommodate Java's latest features, but it's interesting stuff for sure. I am not surprised that BCEL has not kept up with Java's twice-a-year release cycle, that is a lot of moving parts! Many people have contributed to BCEL over the years, which can see here https://github.com/apache/commons-bcel/graphs/contributors, and more recently as you can see in the recent commit history https://github.com/apache/commons-bcel/commits/master "fix it with a very small investment of time" Right... how would you know without digging into the code? markro Any thoughts? I did dig into the code (did you?), as much as I as a dilletante could. IMO, this is simply a matter of an incomplete implementation, not a bug as such. My reasoning was that a maintainer should know the code better than a mere user and first-time issue creator by orders of magnitude. We are not talking about keeping up with Java's twice-a-year release cycle here. Java 11 and the advent of condy are a couple of years old. Java 11 was LTS and has since been superseded by LTS version 17. I am not even complaining that the implementation is incomplete, given the fact that condy is not a frequently used feature. All I am asking is that today, in 2022, you deign to look into the issue I raised. The time you spent discussing this with me might be on a par with the time you would have needed to analyse the issue. But that is, of course, just a guess. It feels like you are looking for reasons to reject it. Even if I would take the time to try and understand this complex product BCEL and be able to make it work for my special case, the fix would probably be suboptimal at best, incomplete or outright wrong in the worst case. Anyway, thanks for discussing the issue with me. Your effort is appreciated. Please review and merge the linked PR. Thanks. Test added to PR. In git master and the snapshot repo at https://repository.apache.org/content/repositories/snapshots/org/apache/bcel/bcel/6.6.0-SNAPSHOT/ Please verify and close.];
BCEL-363;[BCEL-363] ConstantPoolGen can generate constant pools that are too large;Fixed;Resolved;Unassigned;1663672217000;1663766483000;Bug;[];[];[ConstantPoolGen does not limit the number of constants it writes to the Constant Pool, and can generate corrupted classfiles.];[Hello richarda Thank you for the report. We welcome PRs on GitHub Hello richarda PR merged to git master, please verify and close.];
